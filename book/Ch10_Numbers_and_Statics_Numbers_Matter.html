<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数字与静态元素：数字为要</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">轻松学Java（Head First Java）</a></li><li class="chapter-item expanded "><a href="Ch01_Dive_in_A_Quick_Dip_Breaking_the_Surface.html"><strong aria-hidden="true">1.</strong> 快速投身于 Java：破冰</a></li><li class="chapter-item expanded "><a href="Ch02_Class_and_Objects_A_Trip_to_Objectville.html"><strong aria-hidden="true">2.</strong> 类与对象：对象村之旅</a></li><li class="chapter-item expanded "><a href="Ch03_Primitives_and_References_Know_Your_Variables.html"><strong aria-hidden="true">3.</strong> 原生与引用变量：了解你的那些变量</a></li><li class="chapter-item expanded "><a href="Ch04_Methods_Use_Instance_Variables_How_Objects_Behave.html"><strong aria-hidden="true">4.</strong> 用到实例变量的那些方法：对象行为机制</a></li><li class="chapter-item expanded "><a href="Ch05_Writing_a_Program_Extra-Strength_Methods.html"><strong aria-hidden="true">5.</strong> 编写一个程序：方法之附加力量</a></li><li class="chapter-item expanded "><a href="Ch06_Get_to_Know_The_Java_API_Using_the_Java_Library.html"><strong aria-hidden="true">6.</strong> 了解 Java API：运用 Java 的库</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">继承和多态机制</li><li class="chapter-item expanded "><a href="Ch07_Inheritance_and_Polymorphism_Better_Living_in_Objectville.html"><strong aria-hidden="true">7.</strong> 继承与多态：在对象村更好的过活</a></li><li class="chapter-item expanded "><a href="Ch08_Interfaces_and_Abstract_Classes.html"><strong aria-hidden="true">8.</strong> 接口及抽象类</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">编译器、堆与栈</li><li class="chapter-item expanded "><a href="Ch09_Constructors_and_Garbage_Collection_Life_and_Death_of_an_Object.html"><strong aria-hidden="true">9.</strong> 构造器与垃圾回收：对象的生与死</a></li><li class="chapter-item expanded "><a href="Ch10_Numbers_and_Statics_Numbers_Matter.html" class="active"><strong aria-hidden="true">10.</strong> 数字与静态元素：数字为要</a></li><li class="chapter-item expanded "><a href="Ch11_Exception_Handling_Risky_Behavior.html"><strong aria-hidden="true">11.</strong> 异常处理：冒险行为</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">GUI</li><li class="chapter-item expanded "><a href="Ch12_Getting_GUI_A_Very_Graphic_Story.html"><strong aria-hidden="true">12.</strong> 得到图形用户界面：一个甚为形象的故事</a></li><li class="chapter-item expanded "><a href="Ch13_Using_Swing_Work_on_Your_Swing.html"><strong aria-hidden="true">13.</strong> 运用 Swing：工作于 Swing 之上</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">对象序列化与数据结构</li><li class="chapter-item expanded "><a href="Ch14_Serialization_and_File_I_O_Saving_Objects.html"><strong aria-hidden="true">14.</strong> 序列化为文件 I/O：保存对象</a></li><li class="chapter-item expanded "><a href="Ch15_Networking_and_Threads_Make_a_Connection.html"><strong aria-hidden="true">15.</strong> 网络通信与线程：构造连接</a></li><li class="chapter-item expanded "><a href="Ch16_Collections_and_Generics_Data_Structure.html"><strong aria-hidden="true">16.</strong> 集合与泛型：数据结构</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">完结部分</li><li class="chapter-item expanded "><a href="Ch17_Package_JARs_and_Deployment_Release_Your_Code.html"><strong aria-hidden="true">17.</strong> 打包、JARs 与部署：发布代码</a></li><li class="chapter-item expanded "><a href="Ch18_Remote_Deployment_with_RMI_Distributed_Computing.html"><strong aria-hidden="true">18.</strong> 远端部署与 RMI：分布式计算</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">附录</li><li class="chapter-item expanded "><a href="Ch19_Appendix_A.html"><strong aria-hidden="true">19.</strong> 附录 A：十个几乎会进到本书的题目</a></li><li class="chapter-item expanded "><a href="Ch20_Appendix_B.html"><strong aria-hidden="true">20.</strong> 附录 B：其他要点</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="数字与静态值数字为要"><a class="header" href="#数字与静态值数字为要">数字与静态值：数字为要</a></h1>
<p><strong>Numbers and Statics: Numbers Matter</strong></p>
<p><strong>做运算（Do the Math）</strong>。除了原生算术运算，数字方面还有更多的要做。可能要获取某个数字的绝对值，或对某个数字四舍五入，或者找出两个数中较大的等等。还可能希望只打印某个数的两位小数，或者要在大数中放进逗号，从而让大数更易于阅读。日期又该怎样处理呢？或许要以各种方式来打印日期，甚至要对日期进行 <em>操作（manipulate）</em>，比如“把今天的日期加上三周”。还有怎样把字符串解析到数字呢？或是把数字转换成字符串？有幸的是，Java API 提供了很多易于上手的数字处理方法（full of handy number-tweaking methods）。但这些方法大多是 <strong>静态的（<code>static</code>）</strong>，因此先要了解某个变量或方法为静态时，以及 Java 中的常量 -- 静态最终变量，是什么意思（But most of them are <code>static</code>, so we'll start by learning what it means for a variable or method to be static, including constants in Java -- <code>static</code> <code>final</code> variables）。</p>
<h2 id="数学方法接近全局方法"><a class="header" href="#数学方法接近全局方法">数学方法：接近全局方法</a></h2>
<p><strong>MATH methods: as close as you'll ever get to a <code>global</code> method</strong></p>
<p>虽然 Java 中不存在全局的 <em>任何东西</em>。但请想想：有个不依赖实例变量值的方法会怎样。就拿类 <code>Math</code> 中的 <code>round()</code> 方法来说。他会每次都会执行相同的操作 -- 将浮点数（该方法的参数）四舍五入到最接近的整数。每次都这样的。就是有一万个类 <code>Math</code> 的实例，都运行 <code>round(42.2)</code> 方法，得到的结果都是 <code>42</code>。每次都是。也就是说，方法在参数上执行，而绝不会受某个实例变量状态影响。改变方法 <code>round()</code>运行方式的唯一值，就是传递给该方法的参数！</p>
<p>看起来为了运行 <code>round()</code> 方法而构造一个类 <code>Math</code> 的实例，确实是浪费了很多高价值的内存堆空间吧？对于 <em>其他</em> 一些 <code>Math</code> 的方法，比如接收两个数字原生值并返回二者中较小的值的 <code>min()</code>，或 <code>max()</code>，或者返回某个数的绝对值的 <code>abs()</code>等等，又会怎样呢？</p>
<p><em><strong>这些方法绝不会用到实例变量值</strong></em>。事实上类 <code>Math</code> 是没有任何实例变量的。那么构造一个类 <code>Math</code> 的实例就没有任何价值。所以猜猜会怎样？所以就不必构造类 <code>Math</code> 的对象。事实上也无法构造类<code>Math</code>的实例。</p>
<p><strong>在尝试构造类 <code>Math</code> 的实例时</strong>：</p>
<pre><code class="language-java">Math mathObj = new Math();
</code></pre>
<p><strong>将得到这个错误消息</strong>：</p>
<pre><code class="language-console">Math() has private access in java.lang.Math
</code></pre>
<blockquote>
<p>该错误消息显示，<code>Math</code> 构造器是被标记为 <code>private</code> 的！那就是说，<strong>绝</strong> 不可以在类 <code>Math</code> 上写 <code>new</code> 来构造一个新的 <code>Math</code> 对象。</p>
</blockquote>
<p><img src="images/Ch10_01.png" alt="类Math的方法" /></p>
<p><em>图 1 - 类<code>Math</code>的方法</em></p>
<h3 id="常规非静态方法与静态方法的区别"><a class="header" href="#常规非静态方法与静态方法的区别">常规（非静态）方法与静态方法的区别</a></h3>
<p>虽然Java作为面向对象语言，不过后面就会发现一个特殊案例，尤其是那些工具方法（就像这些<code>Math</code>的方法），在这些地方就没有必要用到类的实例。关键字 <code>static</code> 让方法在 <em><strong>没有任何其所属类的实例</strong></em> 情况下，就可以运行。静态方法就是指 “其行为不依赖实例变量，因此不需要实例或对象。只需要类就行”。</p>
<p><img src="images/Ch10_02.png" alt="常规方法与静态方法的区别" /></p>
<p><em>图 2 - 常规方法与静态方法的区别</em></p>
<p><img src="images/Ch10_03.png" alt="静态方法与非静态方法的调用" /></p>
<p><em>图 3 - 静态方法与非静态方法的调用</em></p>
<h3 id="让类具有静态方法有什么意义"><a class="header" href="#让类具有静态方法有什么意义">让类具有静态方法有什么意义？</a></h3>
<p>通常（尽管不总是这样），有着静态方法的类，都是些不打算被实例化的类（Often(although not always), a class with static methods is not meant to be instantiated）。在第8章就谈到过抽象类，以及如何使用 <code>abstract</code> 关键字类对类进行标记，从而使得任何人都不可以在那个类类型上写 <code>new</code>。也就是说，<em><strong>绝无可能对抽象类进行实例化</strong></em>。</p>
<p>到这里，还可以通过将构造器标记为 <code>private</code>，来阻止其他代码对 <em>非</em>抽象类进行实例化了。请记住，标记为 <code>private</code> 的方法意味着只有类中的代码才可以运行那个方法。标记成 <code>private</code> 的构造器，基本与标记为 <code>private</code> 的方法一样 -- 只有类中的代码才可以运行构造器。那么在类 <em>外部</em> 就没有人可以对类写 <code>new</code> 了。这就是类 <code>Math</code> 的运作方式。他的构造器是私有的，就不能构造出 <code>Math</code> 的实例。编译器了解你的代码是不能访问私有构造器的。</p>
<p>这又并不是说，有着一个或多个静态方法的类，绝对不会被实例化。事实上，只要放入了一个 <code>main()</code> 方法，那个类中就有了一个静态方法！</p>
<p>通常是要构造一个 <code>main()</code> 方法来启动或测试另一个类的，几乎总是要在 <code>main()</code> 方法中去实例化某个类，且随后会在构造的新实例上运行某个方法。</p>
<p>因此虽然存在一个非静态方法，就意味着一定有某种构造类实例的方式，但在类中结合静态和非静态方法一起使用，是自由的。获取新对象的唯二方式，是通过关键字 <code>new</code>，或者逆序列化（deserialization, 或称为Java Reflection API，附录会讲到）。此外并无他法。不过还有一个非常有趣的问题，那就是到底是 <em>谁</em> 来写下 <code>new</code>，后面会讨论这个问题。</p>
<h3 id="静态方法不能使用非静态实例变量"><a class="header" href="#静态方法不能使用非静态实例变量">静态方法不能使用非静态（实例）变量！</a></h3>
<p><strong>Static methods can't use non-static (instance) variable</strong>!</p>
<p>静态方法的运行，无需对其所属类的任何特定实例有所了解。就如同前面所说的，静态方法所属类甚至没有实例变量。因为静态方法是使用 <em>类</em>（<code>Math.random()</code>），而非 <em>实例引用变量</em> （<code>t2.play()</code>）调用，所以静态方法就不能引用其所属类的任何实例变量。</p>
<p><strong>若尝试编译这样的代码：</strong></p>
<pre><code class="language-java">class Duck {
    private int size;

    public static void main (String [] args) {
        System.out.format(&quot;Size of duck is %s\n&quot;, size);    // 哪个 Duck? 谁的 size ?
    }                                                       // 若在内存堆上的某处有个 Duck, 这里也是对其一无所知的

    public void setSize (int s) {
        size = s;
    }

    public int getSize () {
        return size;
    }
}
</code></pre>
<p><strong>将收到这样的错误信息</strong>：</p>
<pre><code class="language-console">non-static variable size cannot be reference from a static context
</code></pre>
<blockquote>
<p><strong>在某个静态方法中尝试使用实例变量时，编译器就会想 “我不知道你讲的是哪个对象的实例变量”！就算在内存堆上有 10 只鸭子，静态方法也对他们一无所知</strong>。</p>
</blockquote>
<h3 id="静态方法也不能使用非静态方法"><a class="header" href="#静态方法也不能使用非静态方法">静态方法也不能使用非静态方法！</a></h3>
<p>非静态方法是用来做什么的？<em><strong>非静态方法通常要使用实例变量的状态，来影响他们自己的行为</strong></em>。<code>getName()</code>方法，返回的是变量 <code>name</code> 的值。谁的名字？当然是用于运行 <code>getName()</code> 方法的那个对象的 <code>name</code>。</p>
<p><strong>这段代码不会被编译</strong>：</p>
<pre><code class="language-java">class Duck {
    private int size;

    public static void main (String [] args) {
        System.out.format(&quot;Size of duck is %s\n&quot;, getSize());    // 调用 getSize () 方法只是推迟了必然会出现的问题 -- getSize() 使用了实例变量 size
    }

    public void setSize (int s) {
        size = s;
    }

    public int getSize () {
        return size; // 这里又回到同样的问题......到底是谁的 size ？
    }
}
</code></pre>
<p><strong>错误信息</strong>：</p>
<pre><code class="language-console">non-static method getSize() cannot be reference from a static context
</code></pre>
<h3 id="答疑"><a class="header" href="#答疑">答疑</a></h3>
<ul>
<li><strong>去调用那些不使用任何实例变量的非静态方法会怎么样，编译器会允许吗</strong>？</li>
</ul>
<blockquote>
<p>不行。编译器对是否在非静态方法中有没有使用实例变量清楚得很。设想如果那样可以通过编译，而又在未来的某一天，修改了非静态方法的实现而带进了实例变量，会有什么影响？或者更离谱，在某个子类重写了那个非静态方法，并在重写版本中带入了一个实例变量呢？</p>
</blockquote>
<ul>
<li><strong>对天发誓，见到过使用引用变量，而并非类名字去调用静态方法的代码</strong>。</li>
</ul>
<blockquote>
<p>是可以那样做，但就跟你妈妈经常教导你那样，“仅仅因为它是合法的并不意味着它是好的（Just because it's legal doesn't mean it's good）”。虽然使用类实例去调用静态方法可行，但这样写会构造出带误导性（缺乏可读性）代码。你可以这样写：</p>
</blockquote>
<pre><code class="language-java">Duck d = new Duck ();
String[] = {};
d.main(s);
</code></pre>
<blockquote>
<p>这段代码是合法的，但编译器只会将这段代码解析回真正的类（“好的”，<code>d</code> 的类型为 <code>Duck</code>，同时 <code>main()</code> 是静态的，那么我就会调用类 <code>Duck</code> 中的静态 <code>main()</code>）。也就是说，使用实例 <code>d</code> 来运行 <code>main()</code> 并不会让 <code>main()</code> 对这个引用的对象 <code>d</code> 有更多具体知识。这只是另一种调用静态方法的方式而已，方法本身仍然是静态的！</p>
</blockquote>
<p>故有诗云：</p>
<blockquote>
<p>红玫瑰</p>
<p>开得晚</p>
<p><strong>实例变量的状态</strong></p>
<p><strong>静态方法见不到</strong></p>
</blockquote>
<h3 id="静态变量对类的-所有-实例其值保持一致"><a class="header" href="#静态变量对类的-所有-实例其值保持一致">静态变量：对类的 <em>所有</em> 实例，其值保持一致</a></h3>
<p><strong>Static variable: value is the same for ALL instances of the class</strong></p>
<p>设想打算数一下程序运行时创建了多少个 <code>Duck</code> 的实例。怎样才能做到呢？或许需要一个在构造器中递增的实例变量？</p>
<pre><code class="language-java">clas Duck {
    int duckCount = 0;

    Duck () {
        duckCount++; // 这会在每次构造出一个 Duck 时，将 duckCount 设置为 1
    }
}
</code></pre>
<p>这样写是做不到的，因为<code>duckCount</code>是个实例变量，对每个 <code>Duck</code>都是以 <code>0</code> 开始的。当然可以再构造另一个类来完成 <code>Duck</code> 的计数，但那样就显得笨拙。这个时候就需要一个只有某变量的单份拷贝，且所有实例变量都共享那份拷贝的类。</p>
<p>这就是静态变量可以给到的特性：可被所有类实例共享的值。也就是说，每个类一个值，而非每个实例一个值（In other words, one value per <em>class</em>, instead of one value per <em>instance</em>）。</p>
<pre><code class="language-java">class Duck {
    private int size;
    private static int duckCount = 0;   // 这个静态变量 `duckCount` 只会在类第一次加载时初始化
                                        // 而不会在每次构造新实例时初始化

    Duck () {
        duckCount++;    // 因为 duckCount 是静态的，且不会被重置为 0
                        // 所以现在静态变量 duckCount 就会在 Duck 构造器每次运行时递增
    }

    public void setSize (int s) {
        size = s;
    }

    public int getSize () {
        return size;
    }
} 
</code></pre>
<p><img src="images/Ch10_04.png" alt="实例变量与静态变量的区别" /></p>
<p><em>图 4 - 实例变量与静态变量的区别</em></p>
<p><strong>静态变量是共享的</strong>。</p>
<p><strong>同一类的所有实例，共享静态变量的单个拷贝</strong>。</p>
<ul>
<li>实例变量：每个 <strong>实例</strong> 一个</li>
<li>静态变量：每个 <strong>类</strong> 一个</li>
</ul>
<h3 id="脑力锻炼"><a class="header" href="#脑力锻炼">脑力锻炼</a></h3>
<p>在本章早先部分，我们见到了私有构造器表示类不可被类外部的代码实例化。也就是说，只有类里面的代码，才可以使用私有构造器，构造类的新实例。（这里就有了“鸡生蛋蛋生鸡”问题。）</p>
<p>若要编写一个只能构造一个实例，且要使用类实例的所有人，就都只能使用这单个的实例，会怎样呢？</p>
<h3 id="静态变量的初始化"><a class="header" href="#静态变量的初始化">静态变量的初始化</a></h3>
<p><strong>Initializing a static variable</strong></p>
<p>静态变量是在 <em>类加载</em> 的时候初始化的。而类的加载，则是 JVM 判定应该加载他的时候，才加载的。通常情况下，JVM加载某个类，是因为第一次有人尝试构造那个类的新实例，或者使用该类的静态方法或静态变量。作为 Java 程序员，当然还有显式地让JVM去加载某个类的选项，不过极不可能需要去那样做的。在几乎所有情况下，都最好让JVM去决定何时加载类。</p>
<p>同时静态变量初始化有两条定律：</p>
<ul>
<li>类中的静态变量，是在类的所有对象可被创建出来之前初始化的</li>
<li>类中的静态变量，是在类的所有静态方法运行之前初始化的</li>
</ul>
<pre><code class="language-java">class Player {
    static int playerCount = 0; // playerCount 是在类 Player 加载时初始化的。
    private String name;        // 这里显式将其初始化为 0，不过并不需要，因为整数
                                // 的默认值本来就是 0。静态变量获取默认值的方式，与
                                // 实例变量是一样的。
    Player (String n) {
        name = n;
        playerCount++;          // 已声明但未初始化的静态变量与实例变量，他们的默认值
    }                           // 一样：
}                               // 原生整数（长整形、短整型等）：0
                                // 原生浮点数（单精度、双精度）：0.0
                                // 布尔值：false
public class PlayerTestDrive {  // 对象引用变量：null 
    public static void main (String[] args) {
        System.out.println(Player.playerCount);
        Player one = new Player (&quot;Tiger Woods&quot;);
        System.out.println(Player.playerCount);
    }                        // 对静态变量的访问，就如同对静态
}                            // 方法的访问 -- 使用类的名字。
</code></pre>
<p>运行结果：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
0 &lt;-- 在没有构造任何实例时
1 &lt;-- 在构造了一个对象后
</code></pre>
<h3 id="静态最终变量即为常量"><a class="header" href="#静态最终变量即为常量">静态最终变量即为常量</a></h3>
<p><strong><code>static</code> <code>final</code> variables are constants</strong></p>
<p>标记为 <code>final</code> 的变量，就意味着 -- 一旦被初始化 -- 就绝不会再改变。也就是说，静态最终变量的值，从类被加载开始，就始终保持一致。查看 Java API 中的 <code>Math.PI</code> ，就会发现：</p>
<pre><code class="language-java">public static final double PI = 3.1415926535889793;
</code></pre>
<p>变量 <code>PI</code> 被标记为 <code>public</code> 表示所有代码都可以访问他。</p>
<p>标记为<code>static</code>就无需类 <code>Math</code> 的实例就可以使用（还要记住不能创建类 <code>Math</code>的实例）。</p>
<p>还因为 <code>PI</code> 是不会改变的，因此变量 <code>PI</code> 又被标记为了 <code>final</code>（就Java 这个编程语言来说）。</p>
<p>除了上面这种方式，就再没有其他方式将变量指定为常量了，但对常量命名的约定，可以帮助我们识别出其为常量。<em><strong>常量的名字，应全为大写</strong></em>！</p>
<blockquote>
<p><strong>静态初始化器（static initializer），是一个在类加载时，于外部代码可以使用这个类前，运行的一个代码块，因此这个代码块就是对静态最终变量进行初始化的好地方</strong>。</p>
</blockquote>
<pre><code class="language-java">class Foo {
    final static int X;

    static {
        X = 42;
    }
}
</code></pre>
<p><img src="images/Ch10_05.png" alt="静态最终变量 -- 常量，与静态初始化器" /></p>
<p><em>图 5 - 静态最终变量 -- 常量，与静态初始化器</em></p>
<h3 id="final-不止于-static-变量"><a class="header" href="#final-不止于-static-变量"><code>final</code> 不止于 <code>static</code> 变量</a></h3>
<p>也可使用关键字 <code>final</code> 去修改非静态变量，包括实例变量、本地变量，甚至方法的参数。在每种情况下，关键字 <code>final</code> 都意味着同样的事情：再也不能改变值了。还可以使用关键字 <code>final</code> 去阻止别人重写方法，或构造子类。</p>
<ul>
<li><strong><code>final</code> 的那些非静态变量</strong></li>
</ul>
<pre><code class="language-java">class Foof {
    final int size = 3; // 现在就再不能修改 size 了
    final int whuffie;

    Foof () {
        whuffie = 42; // 这里是不能修改 whuffie 的
    }

    void doStuff (final int x) {
        // 就无法改变 x 了
    }

    void doMore () {
        final int z = 7;
        // 就无法改变 z 了
    }
}
</code></pre>
<blockquote>
<p>实际上这里有个问题。其中的 <code>final int whuffie;</code> 语句中的 <code>whuffie</code> 实例变量，其默认值不是 <code>0</code> 吗？怎么后面又可以再构造器中赋值呢？说明构造器是最先运行的。</p>
</blockquote>
<ul>
<li><strong><code>final</code> 的方法</strong></li>
</ul>
<pre><code class="language-java">class Poof {
    final void calcWhuffie () {
        // 必须保证不被重写的
        // 一些重要事务
    }
}
</code></pre>
<ul>
<li><strong><code>final</code> 的类</strong></li>
</ul>
<pre><code class="language-java">final class MyMostPerfectClass {
    // 这个类就不能被扩展了
}
</code></pre>
<blockquote>
<p><strong><code>final</code> 的 <em>变量</em>，就是说不能修改他的值</strong>。</p>
<p><strong><code>final</code> 的 <em>方法</em>，就是说不能重写这个方法</strong>。</p>
<p><strong><code>final</code> 的 <em>类</em>，就是说不能对这个类进行扩展（即不能构造他的子类）</strong>。</p>
</blockquote>
<h2 id="答疑-1"><a class="header" href="#答疑-1">答疑</a></h2>
<ul>
<li><strong>静态方法不能访问非静态变量。那么非静态方法可以访问静态变量吗</strong>？</li>
</ul>
<blockquote>
<p>当然，类中的非静态方法，总是可以调用类中的静态方法，以及类的静态变量。</p>
</blockquote>
<ul>
<li><strong>将类标记为 <code>final</code> 的目的是什么？这样做不就与面向对象的整体目标相违背了吗</strong>？</li>
</ul>
<blockquote>
<p>是的，不会。将类构造成 <code>final</code>的典型原因，是为了安全性。比如就无法构造类 <code>String</code> 的子类。设想有人扩展了类 <code>String</code>，并以多态方式，在原本是 <code>String</code> 对象的地方，使用他们自己的<code>String</code>子类对象，会是多大的麻烦。在需要一些方法保持特定实现时，就要把他们的类标记为 <code>final</code>。</p>
</blockquote>
<ul>
<li><strong>如果类已经是 <code>final</code>了，那么再把其中的方法标记为 <code>final</code>，不就是多余的吗</strong>？</li>
</ul>
<blockquote>
<p>在类为 <code>final</code> 时，就不需要将方法标记为 <code>final</code>了。想想吧 -- 在类为 <code>final</code> 时，就不能被扩展为子类，那么当然他的方法就不能被重写了。</p>
<p>此外，在确实打算允许其他人对你编写的类进行扩展，又不想要他们重写其中的一些而不是全部的方法时，就可以不将这个类整个标记为 <code>final</code>，而是有选择性地将特定方法标记为 <code>final</code>就行了。最终方法指的就是子类不能对其进行重写。</p>
</blockquote>
<h2 id="知识点"><a class="header" href="#知识点">知识点</a></h2>
<ul>
<li>
<p>调用静态方法应使用类名字，而不是对象引用变量：</p>
<p><code>Math.random()</code> 与 <code>myFoo.go()</code></p>
</li>
<li>
<p>无需堆上静态方法所属类上的任何实例变量，就可以运行静态方法；</p>
</li>
<li>
<p>对于不依赖特定实例变量值的那种工具性方法，写成静态方法是不错的选择；</p>
</li>
<li>
<p>静态方法不与特定实例关联 -- 而只与类关联 -- 因此静态方法就访问不到其所属类的所有实例变量。静态方法不知道该去使用那个实例的值；</p>
</li>
<li>
<p>静态方法无法访问到非静态方法，这是因为非静态方法通常是与实例变量状态关联起来的；</p>
</li>
<li>
<p>在类只有静态方法时，就不希望整个类被实例化，从而可将类构造器标记为 <code>private</code>；</p>
</li>
<li>
<p><em>静态变量</em>是类的全体实例共享的变量。类中的静态变量只有一份拷贝，而不是实例变量那样每个实例都有一份拷贝；</p>
</li>
<li>
<p>静态方法可以访问静态变量；</p>
</li>
<li>
<p>在 Java 语言中要构造一个常量，是将某个变量同时标记为 <code>static</code> 与 <code>final</code>实现的；</p>
</li>
<li>
<p>最终静态变量必须被赋值，要么在声明时，要么在某个静态初始化器中。</p>
</li>
</ul>
<pre><code class="language-java">static {
    DOG_CODE = 420;
}
</code></pre>
<ul>
<li>常量（<code>final</code> <code>static</code> variables）的命名约定是要将名字全部大写；</li>
<li>标记为 <code>final</code> 的变量，一经赋值后就不能在改变了；</li>
<li>给某个 <code>final</code> 的实例变量赋值，要么在该变量声明时，要么在构造器中；</li>
<li><code>final</code> 的方法不能被重写；</li>
<li><code>final</code>的类无法被扩展（子类化操作）。</li>
</ul>
<h2 id="类math的那些方法"><a class="header" href="#类math的那些方法">类<code>Math</code>的那些方法</a></h2>
<p>既然已经知道静态方法工作的方式，不如现在来看看类 <code>Math</code>中的一些静态方法。这里举例的只是其中一些常用的。对照 API 文档，就可以查看到剩余的那些，包括 <code>sqrt()</code>、<code>tan()</code>、<code>ceil()</code>、<code>floor()</code>以及 <code>asin()</code>等等。</p>
<ul>
<li><strong><code>Math.random()</code></strong></li>
</ul>
<blockquote>
<p>返回一个<code>0.0</code>到<code>1.0</code>（不包括<code>1.0</code>）之间的双精度数。</p>
</blockquote>
<pre><code class="language-java">double r1 = Math.round();
int r2 = (int) (Math.random() * 5);
</code></pre>
<ul>
<li><strong><code>Math.abs()</code></strong></li>
</ul>
<blockquote>
<p>返回一个双精度数，为参数的绝对值。该方法有多个过载方法，因此如果传入的是整数，那么返回的也是整数；传入的是双精度数，返回的也是双精度数。</p>
</blockquote>
<pre><code class="language-java">int x = Math.abs(-240); // 返回 240
double d = Math.abs(240.45); // 返回 240.45
</code></pre>
<ul>
<li><strong><code>Math.round()</code></strong></li>
</ul>
<blockquote>
<p>返回参数被取整到最近的整数或长整数（取决于参数是单精度或是双精度数）。</p>
</blockquote>
<pre><code class="language-java">int x = Math.round(-24.8f); // 返回 -25
int y = Math.round(24.45f); // 返回 24
                        //请记住，浮点数在没有加上字母 ‘f’ 时，默认都假定是双精度数
</code></pre>
<ul>
<li><strong><code>Math.min()</code></strong></li>
</ul>
<blockquote>
<p>返回两个参数中较小的数。该方法也具有多个过载方法，用于接收整数、长整数、单精度浮点数或双精度数。</p>
</blockquote>
<pre><code class="language-java">int x = Math.min(24, 240); // 返回 24
double y = Math.min(90876.5, 90876.49); // 返回 90876.5
</code></pre>
<ul>
<li><strong><code>Math.max()</code></strong></li>
</ul>
<blockquote>
<p>与 <code>Math.min()</code> 类似，返回两个参数中的较大值。也是过载的方法。</p>
</blockquote>
<h2 id="对原生值进行包装"><a class="header" href="#对原生值进行包装">对原生值进行包装</a></h2>
<p><strong>Wrapping a primitive</strong></p>
<p>一些时候要将原生值当作对象来对待。比如在 Java 早于5.0的全部版本中，是无法把原生值直接放入到 <code>ArrayList</code>或 <code>HashMap</code>等数据结构中去的：</p>
<pre><code class="language-java">int x = 32;
ArrayList list = new ArrayList();
list.add(x);    // 在 5.0 之前的 Java 版本中，这样写是不行的！！ 
                // 那个时候 ArrayList 还没有 add(int) 方法
                // 来接收整数！（那个时候的 ArrayList 只有
                // 接收对象引用变量，而非原生值的 add() 方法）
</code></pre>
<p>每种原生值类型都有一个打包类，且因为这些打包类都是在 <code>java.lang</code> 包中，所有不必导入他们。由于这些类的名字，都是将（全小写字母的）原生值类型的首字母改为大写得来，因此就很容易识别和区分这些类。</p>
<p>由于某种无人所知的原因，JAVA API 设计者们，决定了不把这些类的名字，按照原生值类型与类类型准确地映射起来（Oh yeah, for reasons absolutely nobody on the planet is certain of, the API designers decided not to map the names <em>exactly</em> from primitive type to class type）。后面就会明白这句话说的是什么。</p>
<p><img src="images/Ch10_06.png" alt="原生类型包装类的名字：例外" /></p>
<p><em>图 6 - 原生类型包装类的名字：例外</em></p>
<p><img src="images/Ch10_07.png" alt="什么是原生值包装类" /></p>
<p><em>图 7 - 什么是原生值包装类</em></p>
<h3 id="在-50-版本之前的-java-中就不得不自己去做"><a class="header" href="#在-50-版本之前的-java-中就不得不自己去做">在 5.0 版本之前的 Java 中，就不得不自己去做...</a></h3>
<blockquote>
<p>太TM愚蠢了，那时候不能构造整数的 <code>ArrayList</code>？必须把每个整数都包装成新的 <code>Integer</code> 对象，然后再在要访问 <code>ArrayList</code> 中的值的时候，从 <code>Integer</code>对象解包为 整数？这样真是浪费时间，并必然会出错的......</p>
</blockquote>
<p>在先于 5.0 版本的所有 Java 版本中，原生值就是原生值，对象引用就是对象引用，二者直接绝不会视为可互换的（In all versions of Java prior to 5.0, primitives were primitives and object references were object references, and they were NEVER treated interchangeably）。都是依赖程序员去完成打包和解包。并无将原生值传递给期望得到对象引用变量的方法，也没有方法来把方法返回的对象引用变量，直接赋值给原生值变量 -- 就算是返回的引用变量指向的是一个 <code>Integer</code>对象，要赋值的是个原生的 <code>int</code> 变量也是不行的。<code>Integer</code>与<code>int</code>两个类型之间，就是没有联系，而实际上 <code>Integer</code>是有一个类型为 <code>int</code> 的实例变量的（用于保存 <code>Integer</code> 所包裹的原生值）。这些事情，都有由程序员来亲自做。</p>
<p><strong>一个原生整数的 <code>ArrayList</code></strong></p>
<p><em><strong>在没有 “自动装箱” 特性时（Java 5.0 之前的版本）</strong></em></p>
<pre><code class="language-java">public void doNumsOldWay () {
    ArrayList listOfNumbers = new ArrayList (); // 构造一个 ArrayList。（请记住，在 5.0 之前是无法
                                                // 指定类型的，因此所有的 ArrayList 都是 Object 的
                                                // 清单）
    listOfNumbers.add(new Interger(3)); // 是不能将原生值 '3' 加入到清单的，因此
                                        // 必须首先将其包装为一个 Integer
    Integer one = (Integer) listOfNumbers.get(0);   // 从 listOfNumbers 这个 ArrayList 中出来的
                                                    // 是个 Object, 不过可以将其强制转换为 Integer
    int intOne = one.intValue(); // 终于可以从 Integer 得到整个原生值了。
}
</code></pre>
<h3 id="自动装箱模糊原生值与对象之间的界线"><a class="header" href="#自动装箱模糊原生值与对象之间的界线"><a id="autoboxing"></a>自动装箱：模糊原生值与对象之间的界线</a></h3>
<p><em><strong>Autoboxing: bluring the line between primitive and object</strong></em></p>
<p>Java 5.0 加入进来的自动装箱特性（the autoboxing feature），就可以 <em>自动</em> 完成原生值到包装对象的转换！</p>
<p>下面瞧瞧在构造一个保存整数的 <code>ArrayList</code> 时，发生了什么。</p>
<p><strong>一个原生整数的 <code>ArrayList</code></strong></p>
<p><em><strong>有着自动装箱时（Java 5.0 及以后的版本中）</strong></em></p>
<pre><code class="language-java">public void doNumsNewWay () {
                                    // 构造一个类型为 Integer 的 ArrayList 
    ArrayList&lt;Integer&gt; listOfNumbers = new ArrayList&lt;Integer&gt;;

    listOfNumbers.add(3); // 这样就加入进去了！
                                    // 尽管 ArrayList 中没有 add(int) 的方法，编译器
                                    // 仍然为你做了所有包装（打包）的工作。也就是说
                                    // 现在确实有一个 Integer 对象存储在这个 ArrayList
                                    // 中了，只不过这里 “假装” ArrayList 接收的是整数而已
                                    // （既可以把整数，也可以把 Integer 对象添加到
                                    // ArrayList&lt;Integer&gt;中去）

    int num = listOfNumbers.get(0);
        // 编译器还会自动将 Integer 对象解包，从而可将整数值直接赋值到原生变量
        // 无需调用 Integer 对象上的 intValue() 方法
}
</code></pre>
<ul>
<li><strong>既然要保存 <code>int</code>s, 为什么不声明一个 <code>ArrayList&lt;int&gt;</code> 呢</strong>？</li>
</ul>
<blockquote>
<p>因为...不可以这样。请记住，泛型规则（the rule for generic types）就是，你只能指定的，仅为类或接口的类型，并非原生类型。因此 <code>ArrayList&lt;int&gt;</code> 是不会被编译的。不过就如同上面的代码，实际上这并不重要，因为编译器允许把整数放到 <code>ArrayList&lt;Integer&gt;</code> 中去。事实上，在使用兼容Java 5.0 的编译器时，对于把原生值放入到清单为原生值包装类类型的 <code>ArrayList</code>，是没有办法阻止的，也因为在这样的编译器下，自动装箱是默认启用的。那么就可以把原生布尔值放入到 <code>ArrayList&lt;Boolean&gt;</code>中，把字符放入到 <code>ArrayList&lt;Character&gt;</code>里。</p>
</blockquote>
<h3 id="自动装箱几乎无处不在"><a class="header" href="#自动装箱几乎无处不在">自动装箱几乎无处不在</a></h3>
<p><strong>Autoboxing works almost everywhere</strong></p>
<p>自动装箱特性不光是可以完成数据集（a collection）中原生值的打包和解包......还可以让我们在几乎所有期望得到原生值，或原生值包装的任何地方，去方便地直接二者互用。这就非常方便了！</p>
<p><strong>自动装箱的乐趣</strong></p>
<ul>
<li><strong>作为方法的参数使用</strong></li>
</ul>
<blockquote>
<p>在某个方法接收原生值包装类类型时，既可以传递一个引用变量，也可以直接传递一个与包装类类型匹配的原生值。反之依然 -- 在某个方法接收原生值时，既可以传递一个兼容的原生值，也可以传递一个原生值类型对应的包装类类型的引用变量。</p>
</blockquote>
<ul>
<li><strong>在返回值处运用</strong></li>
</ul>
<blockquote>
<p>在某个方法声明了一个原生的返回类型时，既可以返回一个兼容的原生类型值，也可以返回一个声明的原生类型对应的包装类类型的引用变量。反之依然，在某个方法声明了一个原生的包装类类型时，既可以返回一个引用变量，也可以返回一个兼容原生类型的值。</p>
</blockquote>
<ul>
<li><strong>在布尔表达式中运用</strong></li>
</ul>
<blockquote>
<p>在希望得到一个布尔值的任何地方，都既可以使用一个可以计算得到布尔值的表达式（比如：<code>4 &gt; 2</code>），也可以直接使用一个原生布尔值，还可以使用一个到 <code>Boolean</code> 包装类的对象引用变量。</p>
</blockquote>
<ul>
<li><strong>在数字运算中的运用</strong></li>
</ul>
<blockquote>
<p>这可能时最奇怪的运用了 -- 是的，运算中即使期望的是原生值，但仍然可以使用包装类类型。这就意味着可以把自增运算符（<code>++</code>）运用在类 <code>Integer</code> 的对象上！</p>
<p>但不必焦虑，这只是编译器的小把戏。并没有对Java语言本身进行修改来支持这样的在对象上应用运算符的特性；编译器只是在执行运算前，简单地把对象转换成了对象的原生值类型。不过这看起来还是很奇怪的。</p>
</blockquote>
<pre><code class="language-java">Integer i = new Integer(42);
i++;
</code></pre>
<p>同样可以这样写：</p>
<pre><code class="language-java">Integer j = new Integer (5);
Integer k = j + 3;
</code></pre>
<ul>
<li><strong>用在赋值中</strong></li>
</ul>
<blockquote>
<p>可把包装类类型对象或原生值，赋值给匹配的包装类类型引用变量或原生值。比如，一个原生值的 <code>int</code> 变量，就可以赋值给一个 <code>Integer</code>类类型的引用变量，反之亦然。</p>
</blockquote>
<p>下面的这个 <code>TestBox</code> 类，可以通过编译，但运行时会报错。</p>
<pre><code class="language-java">package com.xfoss.learningJava;

public class TestBox {
    Integer i;
    int j;

    public static void main (String [] args) {
        TestBox t = new TestBox ();
        t.go();
    }

    public void go () {
        j = i;
        System.out.format(&quot;j is %s\n&quot;, j);
        System.out.format(&quot;i is %s\n&quot;, i);
    }
}
</code></pre>
<p>错误信息为：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
Exception in thread &quot;main&quot; java.lang.NullPointerException
        at com.xfoss.learningJava.TestBox.go(TestBox.java:13)
        at com.xfoss.learningJava.TestBox.main(TestBox.java:9)
</code></pre>
<h3 id="等等还有些东西呢这些包装类还有自己的静态工具方法"><a class="header" href="#等等还有些东西呢这些包装类还有自己的静态工具方法">等等！还有些东西呢！这些包装类还有自己的静态工具方法！</a></h3>
<p><strong>But wait! There's more! Wrappers hava static utility methods too!</strong></p>
<p>除了可以像普通类那样行事，包装类还有一大堆相当有用的静态方法。前面就用到过一个 -- <code>Integer.parseInt()</code>。</p>
<p>这些解析方法接收一个字符串，并返回一个原生值。</p>
<p><strong>把字符串转换成原生值就很容易</strong>：</p>
<pre><code class="language-java">String s = &quot;2&quot;;
int x = Integer.parseInt(s); // 把 “2” 解析为 2 是没问题的。
double d = Double.parseDouble(&quot;420.24&quot;);

boolean b = Boolean.parseBoolean(&quot;True&quot;);
                        // Java 1.5 中新的 parseBoolean() 方法会忽略那个字符串参数中的大小写字母。
</code></pre>
<p><strong>但如果这样写</strong>：</p>
<pre><code class="language-java">String t = &quot;two&quot;;
int y = Integer.parseInt(t);    //  噢。这可以通过编译，但在运行时会报错。所有不能被解析为数字的
                                // 的东西，都将导致一个 NumberFormatException 的报错
</code></pre>
<p><strong>将收到这样的运行时例外</strong>：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;two&quot;
        at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
        at java.base/java.lang.Integer.parseInt(Integer.java:652)
        at java.base/java.lang.Integer.parseInt(Integer.java:770)
        at com.xfoss.learningJava.TestBox.go(TestBox.java:13)
        at com.xfoss.learningJava.TestBox.main(TestBox.java:9)
</code></pre>
<p><strong>对字符串进行解析的所有方法或构造器，都可能抛出 <code>NumberFormatException</code>。这是运行时例外，因此可以不必对其加以处理或进行例外声明。不过或许会想要对其进行处理或进行例外声明的</strong>。</p>
<blockquote>
<p>（在下一章就会讲到例外<code>Exception</code>。）</p>
</blockquote>
<h3 id="现在反过来把原生值转换成字符串"><a class="header" href="#现在反过来把原生值转换成字符串">现在反过来......把原生值转换成字符串</a></h3>
<p><strong>And now in reverse......turning a primitive number into a String</strong></p>
<p>把数字转换成字符串的方法有好几种。最容易的就是，把数字直接连接到一个既有的字符串上。</p>
<pre><code class="language-java">double d = 42.5;
String doubleString = &quot;&quot; + d;   // 请记住这里的 ‘+’ 运算符，是 Java 中唯一的一个过载的
                                // 运算符，在这里是一个字符串连接器。所有添加到某个字符串
                                // 的东西，都将被字符串化。

double d = 42.5;
String doubleString = Double.toString(d);   // 另一种使用类 Double 中静态方法 toString()
                                            // 的方式
</code></pre>
<h3 id="数字的格式化操作"><a class="header" href="#数字的格式化操作">数字的格式化操作</a></h3>
<p><strong>Number formatting</strong></p>
<p>在 Java 语言中，对数字进行格式化，不必与 <code>I/O</code> 相关联。细想一下。把数字展示给用户的一种典型方式，就是经由 GUI 途径。把数字放在一个滚动的文本框、或者在表格里。若把格式化写在打印语句中，那么就根本没办法把数字格式化到可以在 GUI 中很好呈现的字符串了。在 Java 5.0 之前的版本中，大部分的格式化操作，是通过 <code>java.text</code> 包中的类来完成的，而这个包在现在版本的本书中甚至没有提及，因为现在Java中已经不是这样的了。</p>
<p>在 Java 5.0 中，Java 团队通过 <code>java.util</code> 包中的 <code>Formatter</code> 类，带来了更加强大且灵活的格式化功能。不过无需自己去创建和调用<code>Formatter</code>类上的方法，因为Java 5.0 已经将一些便捷方法，添加到部分 <code>I/O</code> 类（包括 <code>printf()</code>）及<code>String</code>类了。因此调用 <code>String.format()</code>并把需要格式化的东西，以及格式化指令传递给他，就变得相当简单了。</p>
<p>当然，还是必须知道该怎样去提供这些格式化指令，同时如果对 <code>C/C++</code> 中的 <code>printf()</code> 函数不熟悉，那就要费点劲儿了。幸运的是，就算不知道<code>printf()</code>，也可以按照指引，完成一些最基本的格式化操作（就是这里所展示的）。但如果要进行混合与匹配，来得到想要的全部，那么就要对<code>printf()</code>有所掌握了。</p>
<p>下面以一个基本例子开始，并在其后看看数字格式化是怎样运作的。（注意：在 <code>I/O</code> 那一章，将再度回顾格式化）</p>
<ul>
<li><strong>将数字格式化为逗号分组样式</strong></li>
</ul>
<p><strong>Formatting a number to use commas</strong></p>
<pre><code class="language-java">package com.xfoss.learningJava;

public class TestFormats {
    public static void main (String [] args) {
                                    // '1234567890' -- 要格式化的数字
                                    // 这里希望让他有些逗号
        System.out.format(&quot;%,d\n&quot;, 1234567890);
                        // &quot;%,d&quot; 就是用于指示如何对作为第二个参数的数字（在
                        // 此示例中，就是一个整数）进行格式化的指令。
                        // 请记住，format() 方法仅有两个参数 -- 第一个逗号是
                        // 在字符串字面值（the String literal, &quot;%,d&quot;）里面的
                        // 因此这个逗号，与第二个逗号不同，他不是把参数分开
                        // 提供给 format() 方法的。
    }
}
</code></pre>
<p>输出：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
1,234,567,890
</code></pre>
<blockquote>
<p>于是就得到了插入到数字中的多个逗号了。</p>
</blockquote>
<h3 id="对格式化的解构"><a class="header" href="#对格式化的解构">对格式化的解构</a></h3>
<p><strong>Formatting deconstructed...</strong></p>
<p>在格式化的最底层（At the most basic level），包含了两个主要部分（当然还有其他东西，不过这里为了简明目的，只讨论两个）：</p>
<ol>
<li>
<p><strong>格式化指令，Formatting instructions</strong></p>
<p>使用了特定的，用于描述如何对参数进行格式化的 <em>格式化说明符</em>（You use special <em>format specifiers</em> that describe how the argument should be formatted）。</p>
</li>
<li>
<p><strong>要格式化的参数，The argument to be formatted</strong></p>
<p>虽然可以有多个参数，但这里会从一个开始。这个参数并非任何类型都可以的...... 只能是可以使用前面格式化指令的格式化说明符可以格式化的。比如在格式化指令指定了一个 <em>浮点数</em> 时，就不能传入一个 <code>Dog</code>，甚至一个看起来像浮点数的 <code>String</code>也是不可以的。</p>
<blockquote>
<p>注意：假如已经了解 <code>C/C++</code> 中的 <code>printf()</code> 函数，那么只要跳过接下来的本节的内容就好。</p>
</blockquote>
<p><img src="images/Ch10_08.png" alt="解构格式化" /></p>
<p><em>图 8 - 解构格式化</em></p>
</li>
</ol>
<p><strong>那么这些指令到底说了什么呢</strong>？</p>
<p>“取该方法的第二个参数，并将其作为一个十进制整数进行格式化，并插入 <strong>逗号</strong> （Take the second argument to this method, and format it as a <strong>d</strong>ecimal and insert <strong>commas</strong>）”。</p>
<p><strong>这些指令是怎样来描述的呢（How do they say that）</strong>？</p>
<p>接下来的内容将深入分析语法 <code>&quot;%, d&quot;</code> 的具体意义，但对于初学者来说，当你在某个格式化字符串（a format String, 格式化字符串始终是 <code>format()</code> 方法的第一个参数）中，看到百分号（<code>%</code>）时，把他想作表示某个变量就行了，而这个变量就是<code>format()</code>方法的第二个参数。百分号后其余的字符，描述的就是那个参数的格式指令。</p>
<p><em><strong>百分号（<code>%</code>）说，“在这里插入参数”（并使用这些指令来对参数进行格式化）</strong></em></p>
<pre><code class="language-java">System.out.format(&quot;%, d&quot;, 1234567890);
                // 注意：这里的 &quot;%, d&quot; 和 &quot;%,d&quot; 有区别
                // &quot;%,&quot; 和 &quot;d&quot; 之间，只能有两种情况：
                // 1. 什么也没有
                // 2. 一个空格
                // 不能有其他任何字符，包括转义字符
                // 两个空格都不可以
</code></pre>
<p><img src="images/Ch10_09.png" alt="&quot;%.2f&quot;示例" /></p>
<p><em>图 9 - <code>%.2f</code>示例</em></p>
<p>百分号 <code>%</code> 告诉格式化器（the formatter）把<code>format()</code> 方法的另一个参数（即那个数字），插入到这里，<strong>并</strong> 使用百分号后的 <code>.2f</code>字符对其进行格式化。随后将格式化字符串的其余部分，添加到最终输出。</p>
<p><strong>加上一个逗号</strong></p>
<p><img src="images/Ch10_10.png" alt="&quot;%,.2f&quot;示例" /></p>
<p><em>图 10 - <code>&quot;%,.2f&quot;</code>示例</em></p>
<blockquote>
<p>注意：浮点数加入逗号，只会在整数部分，小数部分始终不会添加逗号。</p>
</blockquote>
<pre><code class="language-java">System.out.format(&quot;I have %,d bugs to fix.\n&quot;, 476578.09876);
</code></pre>
<p>上面的语句，可以通过编译，但会报出运行时例外报错：</p>
<pre><code class="language-console">Exception in thread &quot;main&quot; java.util.IllegalFormatConversionException: d != java.lang.Double
</code></pre>
<blockquote>
<p>那么到底是怎样知道指令在何处结束，以及剩余字符从哪里开始的呢？又为何没有把 <code>&quot;%.2f&quot;</code> 中的 <code>f</code> 打印出来呢？怎样才知道 <code>.2f</code> 是格式化指令的一部分，而不是字符串的一部分的呢？</p>
</blockquote>
<p><strong>格式化字符串，使用了他自己的小语言语法（The format String uses its' own little language syntax）</strong></p>
<p>显然在百分号 <code>%</code> 后面是不能放上任意字符的。跟在百分号后面的东西的语法，要遵循非常明确的规则，这些百分号后面的部分，描述了对要插入到结果（已格式化）字符串的那个点上的参数，如何进行格式化（The syntax for what goes after the percent sign follows very specific rules, and describes how to format the argument that gets inserted at that point in the result(formatted) String）。</p>
<p>已经见到的两个示例：</p>
<ul>
<li><code>%,d</code> 是指“插入逗号，并把那个数字作为十进制整数进行格式化” </li>
</ul>
<p>以及</p>
<ul>
<li><code>%.2f</code> 指 “将那个数字作为具有两位小数精度的浮点数进行格式化”</li>
</ul>
<p>还有</p>
<ul>
<li><code>%,.2f</code> 指 “插入逗号，并将那个数字作为具有两位小数精度的浮点数进行格式化”</li>
</ul>
<p>真正的问题在于，“怎么知道，到底该在百分号后面放上什么，才能让 <code>format()</code> 按照自己的想法去执行？” 这就包括了对这些符号的掌握（比如<code>d</code>表示十进制，而<code>f</code>表示浮点数），以及百分号后面的指令放置顺序。比如在把逗号放在<code>d</code>后面，就像这样<code>%d,</code>，而不是<code>%,d</code>，就不会工作的！</p>
<p>或者说，下面这个语句会输出什么呢：</p>
<pre><code class="language-java">String.format(&quot;I have %.2f, bugs to fix.&quot;, 476578.09876);
</code></pre>
<p>其输出为：</p>
<pre><code class="language-console">I have 476578.10, bugs to fix.
</code></pre>
<h3 id="格式化说明符the-format-specifier"><a class="header" href="#格式化说明符the-format-specifier">格式化说明符（The format specifier）</a></h3>
<p>百分号后面直到类型指示符（the type indicator, 比如<code>d</code>或<code>f</code>），且包含类型指示符在内，就是格式化指令部分（part of the formatting instructions）。在类型指示符后，格式化器（the formatter）假定其余的字符集，是作为输出字符串的部分了，直到他遇到另一个百分号（<code>%</code>）。嗯......可能会在遇到百分号吗？可以有多个被格式化的参数变量吗？此时现把这个问题放一放；很快就会回到这个问题。现在就来看看格式化说明符 -- 就是百分号后面，描述参数该如何格式化的东西，他的语法。</p>
<p><strong>格式化说明符可以有最多5个不同的部分（不包括<code>%</code>在内）。下面的在 <code>[]</code> 中的每一样，都是可选的，因此只有百分号（<code>%</code>）和类型是必须的。不过他们的顺序也有强制要求，因此要用到的任何部分，都必须以这个顺序放置</strong>。</p>
<p><img src="images/Ch10_11.png" alt="格式化指示符，The format specifier" /></p>
<p><em>图 11 - 格式化指示符，The format specifier</em></p>
<h3 id="唯一必需的说明符是类型the-only-required-specifier-is-for-type"><a class="header" href="#唯一必需的说明符是类型the-only-required-specifier-is-for-type">唯一必需的说明符是类型（The only required specifier is for TYPE）</a></h3>
<p>虽然类型是唯一必需的说明符，但请记住若放入了其他任何部分时，类型都必须放在最后！类型修饰符（type modifiers）有十余种之多（还不包括日期和时间，他们有自己的修饰符集），但绝大多数时候，都会用到 <code>%d</code>（十进制）或 <code>%f</code>（浮点数）。且通常会将<code>%f</code>与精度指示符（a precision indicator）结合使用，来设置输出中所要的小数位数。</p>
<p><strong>类型是强制要求的，其他都是可选的</strong>。</p>
<ul>
<li><strong><code>%d</code> -- 十进制数</strong></li>
</ul>
<pre><code class="language-java">format(&quot;%d&quot;, 42);
            // '42.25' 就不会工作！这与尝试
            // 直接把双精度数赋值给整数变量
            // 一样。
</code></pre>
<p>这里的参数，必须与整数兼容，因此就只有 <code>byte</code>、<code>short</code>、<code>int</code>与<code>char</code>（或者他们的包装类类型）。</p>
<ul>
<li><strong><code>%f</code> -- 浮点数</strong></li>
</ul>
<pre><code class="language-java">format(&quot;%.3f&quot;, 42.000000);
        // 这里将 'f' 与精度指示符 '.3'结合
        // 因此输出就以 3 个 '0' 结束
</code></pre>
<p>参数必须是某种浮点类型，因此就只有单精度数和双精度数（原生值或包装类类型），还有一种叫做 <code>BigDecimal</code>的类类型。</p>
<ul>
<li><strong><code>%x</code> -- 十六进制数</strong></li>
</ul>
<pre><code class="language-java">format(&quot;%x&quot;, 42);
</code></pre>
<p>输出：</p>
<pre><code class="language-console">2a
</code></pre>
<p>这里的参数必须是 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>（包括他们的原生值和包装类类型），以及 <code>BigInteger</code> 类类型。</p>
<ul>
<li><strong><code>%c</code> -- 字符</strong></li>
</ul>
<pre><code class="language-java">format(&quot;%c&quot;, 42);
            // 数字 '42' 表示了字符 '*'
</code></pre>
<p>这里的参数必须是 <code>byte</code>、<code>short</code>、<code>char</code> 或 <code>int</code>（包括他们的原生值与包装类类型）。</p>
<h3 id="不止一个参数时会发生什么呢"><a class="header" href="#不止一个参数时会发生什么呢">不止一个参数时会发生什么呢？</a></h3>
<p>设想需要一个看起来像这样的字符串：</p>
<blockquote>
<p>“排名为 100,567,890.24 中的第 20,456,654 位。”</p>
</blockquote>
<p>而其中的数字则是来自变量。应该怎么办呢？只需在格式化字符串（第一个参数）后加上两个参数就可以了，那就意味着调用 <code>format()</code> 时，会有三个参数，而不再是两个了。在第一个参数（即格式化字符串）内部，将有两个不同的格式化说明符（两个都以<code>%</code>开头）。第一个格式化说明符将插入该方法的第二个参数，同时第二个格式化说明符会插入该方法的第三个参数。也就是说，格式化字符串中的变量插入，使用的是其余参数传入到<code>format()</code>方法的先后顺序。</p>
<pre><code class="language-java">int one = 20456654;
double two = 100567890.248907;
// 这里演示了格式化说明符种的第一个标志（flag），第一个标志可以是 '&lt;', 'n$'（其中'n'是参数编号，从1开始）
System.out.format(&quot;排名为 %,.2f(%&lt;,.4f, %1$f) 中的第 %,d(%2$16d) 位。\n&quot;, two, one);
</code></pre>
<blockquote>
<p>按照图11 中的说明，似乎格式化字符串（the format String）中的格式化说明符（the format specifier）中的第一个标志（总共四个标志），可以指定使用哪个参数变量的。</p>
</blockquote>
<p>到了日期格式化，就会看到可能会对同一参数变量运用不同格式化说明符的情况。在了解日期是如何格式化（与这里的数字格式化正好相反）之前，是很难设想这样的情况的。马上就会了解这方面的内容，就会看到怎样来更精细地控制哪个格式化说明符与哪个参数相对应。</p>
<ul>
<li><strong>这里可真是有些奇怪的东西呢。就是到底可以传入多少个参数？我的意思是，在<code>String</code>类中到底有多少个<code>format()</code>的重载方法呀？那么在把10个的参数传递给某个单独的输出字符串进行格式化时，会发生什么呢？</strong></li>
</ul>
<blockquote>
<p>问得好。是的，这里确实有了一些奇怪的东西（至少是新东西，且与以往有所不同），然而并不存在一堆的过载<code>format()</code>方法，用来处理未知个数的参数变量。为了支持Java语言中的这个新的格式化功能（类似<code>printf</code>），Java 语言就需要另一个新特性 -- <em>可变参数清单（variable arguments list）</em> （简称为 <code>varargs</code>）。对于设计良好的系统，基本不会用到这个可变参数清单特性。</p>
</blockquote>
<h3 id="讲了这么多的数字关于日期又是怎样的呢"><a class="header" href="#讲了这么多的数字关于日期又是怎样的呢">讲了这么多的数字，关于日期又是怎样的呢？</a></h3>
<p>设想需要这样的一个字符串：&quot;2004年11月28日，星期天&quot;。</p>
<p>是不是并没有什么特别的？好吧，如果全部从一个 <code>Date</code> -- Java中可以表示时间戳的类，类型的变量开始呢，现在就要取用这样的一个对象（与数字有所不同），并将其发送给格式化器。</p>
<p>数字与日期格式化的主要不同，在于日期的各种格式，都使用到一种以<code>t</code>开头的两字符的类型（a two-character type，这一点与数字格式化中使用的 <code>d</code> 或 <code>f</code> 是不同的）。下面的几个示例，可以给你一个日期格式化的运作有大致了解：</p>
<ul>
<li><strong>完整的日期和时间 -- <code>%tc</code></strong></li>
</ul>
<pre><code class="language-java">String.format(&quot;%tc&quot;, new Date());
</code></pre>
<p>输出为：</p>
<pre><code class="language-console">周日 12月 26 16:48:23 CST 2021
</code></pre>
<ul>
<li><strong>只显示时间 -- <code>%tr</code></strong></li>
</ul>
<pre><code class="language-java">String.format(&quot;%tr&quot;, new Date());
</code></pre>
<p>输出为：</p>
<pre><code class="language-console">04:51:24 下午
</code></pre>
<ul>
<li><strong>显示周几，几月，几日 -- <code>%tA</code>, <code>%tB</code>, <code>td</code></strong></li>
</ul>
<p>并没有单个的格式化说明符，来实现这里要求的显示内容，因此就要结合其中三个：周几（<code>%tA</code>）、月份（<code>%tB</code>），以及几号（<code>%td</code>）。</p>
<pre><code class="language-java">Date today = new Date();
String.format(&quot;%tA, %tB %td&quot;, today, today, today);
                // 这个逗号不是格式化的部分......他只是
                // 这里希望在第一个插入的格式化参数之后
                // 打印出来的一个字符。
</code></pre>
<p>的输出为：</p>
<pre><code class="language-java">星期日, 十二月 26
</code></pre>
<blockquote>
<p>不过这样写意味着必须传递 <code>today</code> 这个 <code>Date</code> 对象三次，对于格式化的每个部分，都有传递一次。换句话说，其中的 <code>%tA</code> 只会给到周几，随后还不得不再次传递 <code>today</code> 来获取月份，之后还要为获取几号再传递。</p>
</blockquote>
<p>这样写:</p>
<pre><code class="language-java">System.out.format(&quot;%tA, %tB %td&quot;, now);
</code></pre>
<p>会报出告警：</p>
<pre><code class="language-console">[WARNING] 
java.util.MissingFormatArgumentException: Format specifier '%tB'
</code></pre>
<ul>
<li><strong>与上一个相同，但无需重复的参数 -- <code>%tA, %&lt;tB %&lt;td</code></strong></li>
</ul>
<pre><code class="language-java">Date today = new Date();
String.format(&quot;%tA, %&lt;tB %&lt;td&quot;, today);
</code></pre>
<blockquote>
<p>这里的简括符 <code>&lt;</code>，只是说明符中的一个标志，他告诉格式化器去 “再次使用上一个参数（use the previous argument again）”。如此就避免了参数的重复，而是对同一个参数，进行三次不同方式的格式化。</p>
<p>可以把这样的用法想作是在<code>today</code>这个日期对象上调用三个不同的读取器（getter），来获取这个日期对象的三个不同片段的数据。</p>
</blockquote>
<h2 id="处理日期数据"><a class="header" href="#处理日期数据">处理日期数据</a></h2>
<p><strong>Working with Dates</strong></p>
<blockquote>
<p>来看看这个问题......如果项目是从二月27号开始，八月5号结束，期间有多数个工时呢？</p>
</blockquote>
<p>对于日期数据，除了获取当前日期外，往往还有更多的方面需要处理。比如需要程序去调整日期、找出已使用的时间、排定优先级、进度告警（heck）以及构建进度表等等。那么就需要具备一些工业能力的日期处理能力。</p>
<p>当然可以构造自己的一套日历......（还请不要搞忘了那些闰年！）还有那些时不时的、讨厌的润秒。这样一来情况就会变得很复杂了。不过好消息是 Java API有着丰富的、可帮助对日期进行处理的一些类。甚至有的时候感觉这些类过于丰富了......</p>
<h3 id="在时间中穿梭"><a class="header" href="#在时间中穿梭">在时间中穿梭</a></h3>
<p><strong>Moving backward and forward in time</strong></p>
<p>假设公司的工作安排是周一至周五。安排的任务是找出今年各个日历月中的最后一个工作日......</p>
<p><strong>这样看来<code>java.util.Date</code>，实际上就落伍了......</strong></p>
<p>早先使用了 <code>java.util.Date</code>类来找出当天的日期，那么逻辑上看，这个类在需要一些临时日期处理能力时，比较适合，但只有翻阅一下 API 文档，就会发现 <code>Date</code> 的大部分方法，都已经弃用了！</p>
<p>在获取一个表示当前日期和时间的对象，因此在想要表达“给我当下（give me NOW）”时，就要用到的时间戳时，类<code>Date</code>仍是一个不错的选择。</p>
<blockquote>
<p>在需要一个“现在”的时间戳时，使用类 <code>Date</code>。除此之外，都用类 <code>Calendar</code>。</p>
</blockquote>
<p>好消息时，API推荐使用 <strong><code>java.util.Calender</code></strong> 来代替类 <code>Date</code>，所以就要检视一下这个类：</p>
<p><strong>使用 <code>java.util.Calendar</code> 来操作日期</strong></p>
<p><code>Calendar</code> API 的设计者们，希望从全局、字面上进行思考（The designers of the <code>Calendar</code> API wanted to think globally, literally）。基本概念是在与日期打交道时，就会请求一个日历系统（通过类<code>Calendar</code>的一个静态方法），同时 JVM 把一个<code>Calendar</code>具体子类的实例递送回来。（<code>Calendar</code>实际上是一个抽象类，因此总是与某个具体子类打交道。）</p>
<p>更有趣的时，所获取到的日历系统类别，将适配你的语言环境（More interesting, though, is that the <em>kind</em> of calendar you get back will be <em>appropriate for your locale</em>）。世界上大部分地区都使用的是格里历，而如果不在使用格里历的地区，也可以让 Java 库处理其他的比如佛历、伊斯兰历法或日本历法（Much of the world uses the Gregorian calendar, but if you're in an area that doesn't use a Gregorian calendar you can get Java libraries to handle other calendars such as Buddhist, or Islamic or Japanese）。</p>
<p>标准 Java API 本身带有 <code>java.util.GregorianCalendar</code>类，因此这里将使用格里历。大部分情况下，都不需要了解所使用的 <code>Calendar</code>资料属于何种类别，而是要关注类 <code>Calendar</code>的那些方法。</p>
<h3 id="获取一个对类-calendar进行扩展的对象"><a class="header" href="#获取一个对类-calendar进行扩展的对象">获取一个对类 <code>Calendar</code>进行扩展的对象</a></h3>
<p><strong>Getting an object that extends <code>Calendar</code></strong></p>
<p>要获取某个抽象类的“实例”时，该怎么办呢？当然不会像下面这样，这样写是不行的：</p>
<p><strong>这 <em>不会</em> 工作</strong>：</p>
<pre><code class="language-java">Calendar cal = new Calendar();
                // 编译器不会允许这样干的！
</code></pre>
<p><strong>而是要使用静态的 <code>getInstance()</code> 方法</strong>：</p>
<pre><code class="language-java">Calendar cal = Calendar.getInstance();
                // 到这里这个语法应该看起来不陌生了 --
                // 这里运行了一个静态方法。
</code></pre>
<blockquote>
<p><strong>关于 call 和 invoke</strong>：前者是 “调用”，后者是 “运行”。</p>
</blockquote>
<blockquote>
<p>等一下。既然不能构造类 <code>Calendar</code> 的实例，那到底赋值给那个 <code>Calendar</code> 类型的引用变量了什么呢？</p>
</blockquote>
<p><strong>确实不能获取到一个类 <code>Calendar</code> 的实例，但可以获取一个<code>Calendar</code>具体子类的实例呀</strong>。</p>
<p>显然是无法获取到类 <code>Calendar</code> 的实例的，因为<code>Calendar</code>是一个抽象类。但对于调用 <code>Calendar</code>的静态方法没有影响，仍可以自由调用，因为静态方法是在类上，而不是某个特定实例上调用的。因此对<code>Calendar</code>类上的<code>getInstance()</code>方法进行调用，同时这个方法返回......一个具体子类的实例。这个实例对 <code>Calendar</code>进行扩展（也就是说这个实例可以多态地赋值给 <code>Calendar</code>类型的引用变量），且根据合约，这个实例还可以对类 <code>Calendar</code>的那些方法进行响应。</p>
<p>在世界上大多数地方，同时大多数的 Java版本，都将从<code>getInstance()</code>获取到一个 <code>java.util.GregorianCalendar</code>的实例。</p>
<h2 id="运用-calendar-对象"><a class="header" href="#运用-calendar-对象">运用 <code>Calendar</code> 对象</a></h2>
<p>为了运用好 <code>Calendar</code> 对象，就需要理解几个关键概念：</p>
<ul>
<li><strong>字段保存 <em>状态</em>（Fields hold <em>state</em>）</strong> -- <code>Calendar</code>类类型的对象，有着多个用于表示其最终状态、日期与时间等的字段。举例来说，可以设置某个 <code>Calendar</code> 的 <em>年份</em> 或者 <em>月份</em>；</li>
<li><strong>日期和时间，是可以 <em>增加</em> 的</strong> -- 类 <code>Calendar</code>有一些允许对不同字段的值进行加减的方法，比如“在月份上加一”，或“减去三年”；</li>
<li><strong>日期和时间可以 <em>毫秒</em> 表示</strong> -- 类 <code>Calendar</code> 允许把日期转换成其毫秒表示，以及把毫秒表示转换成日期形式。（需要指出的是，毫秒表示指从 1970年元旦到具体日期的毫秒数。）这样既可以执行诸如“两个时间之间所经历的时间”，或者“在此时间上加63小时23分12秒”等这样的精确计算。</li>
</ul>
<p><strong>运用 <code>Calendar</code>对象的示例</strong>：</p>
<pre><code class="language-java">Calendar c = Calendar.getInstance();

// 将时间设置为 2022年1月7日，15：40：01（注意月份是从零开始的）
c.set(2022, 0, 7, 15, 40);
// 把这个时间转换成一个相当大的毫秒数
//（Convert this to a big ol' amount of milliseconds.）
long day1 = c.getTimeInMillis();
System.out.format(&quot;以毫秒表示: %,d，正常表示：%s\n&quot;, day1, c.getTime());

// 加上相当于一个小时的毫秒数，随后更新这个时间。
// （注意这里的 '+='，作用与 day1 = day1 + ... 一样的）
day1 += 1000*60*60;
c.setTimeInMillis(day1);
System.out.format(&quot;新的几点钟： %d\n&quot;, c.get(c.HOUR_OF_DAY));

// 在日期上加 35， 这就会把我们带到二月份。
c.add(c.DATE, 35);
System.out.format(&quot;加上了35天后： %s\n&quot;, c.getTime());

// 在此日期上往前“滚动” 35天。此操作把日期往前滚动 35天，但不会改变月份！
c.roll(c.DATE, 35);
System.out.format(&quot;往前滚动 35 天： %s\n&quot;, c.getTime());

// 这里没有进行增减，而只是对日期字段执行了一个 “设置”。
c.set(c.DATE, 1);
System.out.format(&quot;日期设置到 1 号： %s\n&quot;, c.getTime());
</code></pre>
<p>输出为：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
以毫秒表示: 1,641,541,202,162，正常表示：Fri Jan 07 15:40:02 CST 2022
新的几点钟： 16
加上了35天后： Fri Feb 11 16:40:02 CST 2022
往前滚动 35 天： Fri Feb 18 16:40:02 CST 2022
日期设置到 1 号： Tue Feb 01 16:40:02 CST 2022
</code></pre>
<p><em>此输出就确认了以上的 <code>getTimeMillis()</code>、<code>add()</code>、<code>roll()</code>以及<code>set()</code>等方法是如何运作的</em>。</p>
<blockquote>
<p><strong>注意</strong>：The <code>java.util.Calendar.roll()</code> method adds(up) or subtracts(down) a single unit of time on the given time field without changing larger fields. -- <em>Java API</em> </p>
<p>这个方法有点古怪。</p>
</blockquote>
<h3 id="calendar-api的一些亮眼之处"><a class="header" href="#calendar-api的一些亮眼之处"><code>Calendar</code> API的一些亮眼之处</a></h3>
<p><strong>Highlights of the <code>Calendar</code> API</strong></p>
<p>上面刚粗略涉及了类 <code>Calendar</code> 中的一些字段及方法。<code>Calendar</code>作为一个大型API，因此这里只能展示一些会用到的最常用字段与方法。在理解了下面的少数几个字段与方法后，就应该能够游刃有余地使用这个API了。</p>
<ul>
<li>
<p><strong><code>Calendar</code>类的关键方法</strong></p>
<ul>
<li>
<p><strong><code>add(int field, int amount)</code></strong></p>
<p>在该日历字段上加减时间。</p>
</li>
<li>
<p><strong><code>get(int field)</code></strong></p>
<p>返回给定日历字段的值。</p>
</li>
<li>
<p><strong><code>getInstance()</code></strong></p>
<p>返回一个 <code>Calendar</code> 类类型对象，这里可以指定一个语言环境（<code>locale</code>）。</p>
</li>
<li>
<p><strong>getTimeInMillis()</strong></p>
<p>以长整型数形式，返回此 <code>Calendar</code> 对象的时间毫秒数。</p>
</li>
<li>
<p><strong><code>roll(int field, boolean up)</code></strong></p>
<p>在不改变较大字段的情况下加上或减去时间（Adds or subtracts time without changing larger fields）。</p>
</li>
<li>
<p><strong><code>set(int field, int value)</code></strong></p>
<p>对给定<code>Calendar</code>字段进行设置。</p>
</li>
<li>
<p><strong><code>set(year, month, day, hour, minute)</code>（全为整数）</strong></p>
<p><code>set()</code> 方法的一个常用变种，用来设置一个完整时间。</p>
</li>
<li>
<p><strong><code>setTimeInMillis(long millis)</code></strong></p>
<p>使用一个长整型的时间，来设置某个 <code>Calendar</code> 类类型对象的时间。</p>
</li>
<li>
<p>其余...</p>
</li>
</ul>
</li>
<li>
<p><strong><code>Calendar</code> 类的关键字段</strong></p>
<ul>
<li>
<p><strong><code>DATE</code>/<code>DATE_OF_MONTH</code></strong></p>
<p>获取/设置日期中的几号。</p>
</li>
<li>
<p><strong><code>HOUR</code>/<code>HOUR_OF_DAY</code></strong></p>
<p>获取/设置 12 小时或 24 小时值。</p>
</li>
<li>
<p><strong><code>MILLISECOND</code></strong></p>
<p>获取/设置毫秒数。</p>
</li>
<li>
<p><strong><code>MINUTE</code></strong></p>
<p>获取/设置分钟。</p>
</li>
<li>
<p><strong><code>MONTH</code></strong></p>
<p>获取/设置月份。</p>
</li>
<li>
<p><strong><code>YEAR</code></strong></p>
<p>获取/设置年份。</p>
</li>
<li>
<p><strong><code>ZONE_OFFSET</code></strong></p>
<p>以毫秒数形式，来获取/设置与GMT的偏移量（Get/set raw offset of GMT in millis）。</p>
</li>
<li>
<p>更多字段......</p>
</li>
</ul>
</li>
</ul>
<h2 id="更多的静态静态的导入"><a class="header" href="#更多的静态静态的导入">更多的静态！......静态的导入</a></h2>
<p><strong>Even more Statics!...static imports</strong></p>
<p>这是 Java 5.0 引入的新特性......这是是喜忧参半的一个特性。一些人喜爱这个主意，另一些则讨厌这个点子。静态导入之所以存在，只是因为他可以节省一些按键输入的时间。在讨厌键盘输入时，就可能会喜欢上这个特性。静态导入的弊端就是 -- 在不注意的时候 -- 他们的使用会造成代码难于阅读。</p>
<p>静态导入背后的基本概念就是，只要使用到静态类、静态变量，或者枚举变量（关于枚举变量，后续会涉及，an enum），就可以将其导入进来，从而节省一些键盘输入。</p>
<p><strong>一些老式代码</strong>：</p>
<pre><code class="language-java">import java.lang.Math;

class NoStatic {
    public static void main(String [] args) {
        System.out.println(&quot;sqrt &quot; + Math.sqrt(2.0));
        System.out.println(&quot;tan &quot; + Math.tan(60));
    }
}
</code></pre>
<p><strong>具有静态导入特性时的代码</strong>：</p>
<pre><code class="language-java">// 在声明静态导入时，所用到的语法
import static java.lang.System.out;
import static java.lang.Math.*;

class WithStatic {
    public static void main(String[] args){
        out.println(&quot;sqrt &quot; + sqrt(2.0));
                            // 运作中的静态导入
        out.println(&quot;tan &quot; + tan(60));
        // 运作中的静态导入
    }
}
</code></pre>
<blockquote>
<p><strong>注意事项（Caveats &amp; Gotchas）</strong></p>
<ul>
<li>
<p>在只打算为数不多地使用某个静态成员时，为了让代码更具可读性，建议避免使用静态导入；</p>
</li>
<li>
<p>在要大量使用某个静态成员时（比如要执行大量的数学计算），这个时候使用静态导入可能就不错；</p>
</li>
<li>
<p>注意在静态导入声明中，可以使用通配符（<code>.*</code>）；</p>
</li>
<li>
<p>静态导入的一个大问题是，容易造成命名冲突（A big issue with static imports is that it's not too hard to create naming conflicts）。
比如，在两个不同类都有 <code>add()</code>方法时（<code>Math</code>和<code>Calendar</code>就是这样的情况），编译器和你自己就不知道到底该使用那个 <code>add()</code> 方法了。</p>
</li>
</ul>
</blockquote>
<h2 id="围炉夜话"><a class="header" href="#围炉夜话">围炉夜话</a></h2>
<p><strong>Fireside Chats</strong></p>
<p>今日主题：<strong>实例变量鄙视静态变量</strong></p>
<p><strong>Tonight's Talk: <em>An instance variable takes cheap shots at a static variable</em></strong></p>
<ul>
<li><strong>实例变量（IV，Instance Variable）</strong>：我甚至不明白为什么我们会在这里讨论。人人皆知静态变量只用在常量上。有几个静态变量啊？我想整个的 API 也就只有四个吧？又没人会用到。</li>
<li><strong>静态变量（SV，Static Variable）</strong>：你真的应该检讨一下了。你都多久没有关注 API 了啊？API整个就是由静态加载的（It's frickin' loaded with statics）！API的一些类，全部都保存的常量值。比如就有一个名为 <code>SwingConstants</code>的类，其中就全是常量值。</li>
<li><strong>IV</strong>：全都是。当然了，你还可以讲出来好几个这样子的。不错，在 <code>Swing</code>库中是有几个这样的，但大家都知道 <code>Swing</code> 只是个特殊案例。</li>
<li><strong>SV</strong>：那可能只是个特例，但他确实是个重要的东西！那类 <code>Color</code>又怎么说？为了构造那些标准颜色去记住各种 RGB 数值，会不会很痛苦呢？可是类 <code>Color</code> 已经有着预先定义好的各种颜色了。这就非常方便了啊。</li>
<li><strong>IV</strong>：好吧，不过除了这少数几个 GUI 的东西外，请举个人人都会实实在在用到静态变量的例子好吗。在具体场合会用到的。</li>
<li><strong>SV</strong>：新手会用到的 <code>System.out</code>怎么样？<code>System.out</code>中的 <code>out</code>就是类 <code>System</code>的一个静态变量。就代码编写者本人而言，并没有构造新的 <code>System</code>的实例，只是请求<code>System</code>提供了他的 <code>out</code>变量。</li>
<li><strong>IV</strong>：好吧，这也不过是另一个特殊用例。而且除了调试之外，没人会用到那个的。</li>
<li><strong>SV</strong>：哦，难道程序调试不重要吗？
有些东西绝对是心胸狭隘的你不知道的 -- 请接受吧，静态变量更具效率。静态变量是每个类有一个的，而不像实例变量，是一个实例一个。这样节省下来的内存，是多么巨大！</li>
<li><strong>IV</strong>：嗯，你是不是搞忘了什么？</li>
<li><strong>SV</strong>：什么？</li>
<li><strong>IV</strong>：静态变量天生就是反面向对象的吧！既然要使用静态变量，那为何不倒退回去，使用过程编程呢（Static variables are about as un-OO as it gets!! Gee why not just go take a giant backwards step and do some procedural programming while we're at it）？</li>
<li><strong>SV</strong>：你说反面向对象是什么意思？</li>
<li><strong>IV</strong>：你静态变量就像是个全局变量，但凡是个程序员，就知道那通常不是件好事（any programmer worth his PDA knows that's usually a Bad Thing）。</li>
<li><strong>SV</strong>：我不是全局变量。Java里根本就没有全局变量。我是存活在类中的！你应该明白，类是一个相当面向对象的东西。我只是呆在那里，在内存空间中的某个地方；我是对象状态的一个天数部分；唯一区别在于，我是类的全体对象所共有的。非常有效率。</li>
<li><strong>IV</strong>：你是存活在类中，不过人们并没有把Java叫做面向类的编程。那样叫得多蠢。你就是个遗迹。你得存在是为了让那些旧时代的程序员过渡到 Java（You're a relic. Something to help the old-timers make the leap to java）。</li>
<li><strong>SV</strong>：好吧就此打住。你真是一派胡言。某个系统的一些静态变量，对于系统至关重要。就算是不那么重要的静态变量，也是为了编码的便利。</li>
<li><strong>IV</strong>：好吧，看起来静态变量/方法的使用似乎有点道理（Well, OK, every once in a while sure, it makes sense to use a static）。不过我告诉你，滥用静态变量（及方法），就是不成熟的面向对象程序员的标志。设计师应该考虑 <em>对象</em> 状态，而不是 <em>类</em> 的状态。</li>
<li><strong>SV</strong>：你说这个做什么？静态方法有什么问题吗？</li>
<li><strong>IV</strong>：静态方法是这中间最糟糕的了，因为使用静态方法常常意味着程序员是在进行过程思维，而没有以对象按照对象的独有状态来行事。</li>
<li><strong>SV</strong>：当然，我知道应该把对象作为面向对象涉及的焦点，但正是由于有那么些无知的程序员......请不要全盘否定过程编程好吧。静态变量/方法仍然有其存在的必要，同时在需要到他们时，他们可以说是无可比拟的（don't throw the baby out with the bytecode. There's a time and place for statics, and when you need one, nothing else beats it）。</li>
<li><strong>IV</strong>：好吧......你就自欺欺人吧（Riiiiiight. Whatever you need to tell yourself...）</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Ch09_Constructors_and_Garbage_Collection_Life_and_Death_of_an_Object.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="Ch11_Exception_Handling_Risky_Behavior.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Ch09_Constructors_and_Garbage_Collection_Life_and_Death_of_an_Object.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="Ch11_Exception_Handling_Risky_Behavior.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
