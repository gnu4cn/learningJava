<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>了解 Java API：运用 Java 的库</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">轻松学Java（Head First Java）</a></li><li class="chapter-item expanded "><a href="Ch01_Dive_in_A_Quick_Dip_Breaking_the_Surface.html"><strong aria-hidden="true">1.</strong> 快速投身于 Java：破冰</a></li><li class="chapter-item expanded "><a href="Ch02_Class_and_Objects_A_Trip_to_Objectville.html"><strong aria-hidden="true">2.</strong> 类与对象：对象村之旅</a></li><li class="chapter-item expanded "><a href="Ch03_Primitives_and_References_Know_Your_Variables.html"><strong aria-hidden="true">3.</strong> 原生与引用变量：了解你的那些变量</a></li><li class="chapter-item expanded "><a href="Ch04_Methods_Use_Instance_Variables_How_Objects_Behave.html"><strong aria-hidden="true">4.</strong> 用到实例变量的那些方法：对象行为机制</a></li><li class="chapter-item expanded "><a href="Ch05_Writing_a_Program_Extra-Strength_Methods.html"><strong aria-hidden="true">5.</strong> 编写一个程序：方法之附加力量</a></li><li class="chapter-item expanded "><a href="Ch06_Get_to_Know_The_Java_API_Using_the_Java_Library.html" class="active"><strong aria-hidden="true">6.</strong> 了解 Java API：运用 Java 的库</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">继承和多态机制</li><li class="chapter-item expanded "><a href="Ch07_Inheritance_and_Polymorphism_Better_Living_in_Objectville.html"><strong aria-hidden="true">7.</strong> 继承与多态：在对象村更好的过活</a></li><li class="chapter-item expanded "><a href="Ch08_Interfaces_and_Abstract_Classes.html"><strong aria-hidden="true">8.</strong> 接口及抽象类</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">编译器、堆与栈</li><li class="chapter-item expanded "><a href="Ch09_Constructors_and_Garbage_Collection_Life_and_Death_of_an_Object.html"><strong aria-hidden="true">9.</strong> 构造器与垃圾回收：对象的生与死</a></li><li class="chapter-item expanded "><a href="Ch10_Numbers_and_Statics_Numbers_Matter.html"><strong aria-hidden="true">10.</strong> 数字与静态元素：数字为要</a></li><li class="chapter-item expanded "><a href="Ch11_Exception_Handling_Risky_Behavior.html"><strong aria-hidden="true">11.</strong> 异常处理：冒险行为</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">GUI</li><li class="chapter-item expanded "><a href="Ch12_Getting_GUI_A_Very_Graphic_Story.html"><strong aria-hidden="true">12.</strong> 得到图形用户界面：一个甚为形象的故事</a></li><li class="chapter-item expanded "><a href="Ch13_Using_Swing_Work_on_Your_Swing.html"><strong aria-hidden="true">13.</strong> 运用 Swing：工作于 Swing 之上</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">对象序列化与数据结构</li><li class="chapter-item expanded "><a href="Ch14_Serialization_and_File_I_O_Saving_Objects.html"><strong aria-hidden="true">14.</strong> 序列化为文件 I/O：保存对象</a></li><li class="chapter-item expanded "><a href="Ch15_Networking_and_Threads_Make_a_Connection.html"><strong aria-hidden="true">15.</strong> 网络通信与线程：构造连接</a></li><li class="chapter-item expanded "><a href="Ch16_Collections_and_Generics_Data_Structure.html"><strong aria-hidden="true">16.</strong> 集合与泛型：数据结构</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">完结部分</li><li class="chapter-item expanded "><a href="Ch17_Package_JARs_and_Deployment_Release_Your_Code.html"><strong aria-hidden="true">17.</strong> 打包、JARs 与部署：发布代码</a></li><li class="chapter-item expanded "><a href="Ch18_Remote_Deployment_with_RMI_Distributed_Computing.html"><strong aria-hidden="true">18.</strong> 远端部署与 RMI：分布式计算</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">附录</li><li class="chapter-item expanded "><a href="Ch19_Appendix_A.html"><strong aria-hidden="true">19.</strong> 附录 A：十个几乎会进到本书的题目</a></li><li class="chapter-item expanded "><a href="Ch20_Appendix_B.html"><strong aria-hidden="true">20.</strong> 附录 B：其他要点</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="了解java-api使用java的库"><a class="header" href="#了解java-api使用java的库">了解Java API：使用Java的库</a></h1>
<p>Java语言本身，就带有多达数百个的预构建类。若掌握了如何从 Java 库，也就是常说的 <strong>Java API</strong>中找到你所需要的功能，那么就不必去重新发明轮子了（You don't have to reinvent the wheel if you know how to find what you need in the Java library, known as the <strong>Java API</strong>）。<em>还有更好的事情等着你去做</em>。若要编写代码，也只是要去编写对于你的应用来说，真正特有的代码。你知道那些下午5点就下班，早上10点都还没到公司的程序员吗？<strong>他们就是善于使用 Java API</strong>。Java的核心库，有着大量的类，就等着你去使用，可以像使用砖块一样，从大量预构建的代码，组装出你自己的程序。本书中用到的写好Java程序示例，就是无需从头再编写的代码，但还是必须输入到你的程序中去。而Java API则是些甚至不用输入的代码。你只需要学会怎样去使用他们就可以了。</p>
<p>Java标准版带有数百个预构建类（除非使用的是针对小型设备的微型版本，那么Java标准版就是你手头的版本，The Java Standard Edition，which is what you have unless you're working on the Micro Edition for small devices and believe me, you'd know）。他们就和本书中这些编写好的代码一样，只是这些内建的类，时已经编译好的。</p>
<p><strong>这就是说这些内建类无需再次输入了</strong> 。直接使用他们就好。</p>
<p><code>ArrayList</code> 是Java库中无数内建类之一。你可以在自己的代码中，如同是你自己编写的<code>ArrayList</code>一样使用他。</p>
<p><em>我该怎么来知道，Java API里有些什么呢？</em></p>
<p>这正是如何成为一名正式的Java程序员的关键所在。这并不是说在构建软件时尽可能的懒，而是说在有人已经完成了这门语言中大多数最重要的部分后，你可以节省那么多的时间，而你只需要花点时间去了解这些API，去完成你的软件中有趣的部分即可。</p>
<p>有点离题了，这个问题的答案，往短了说，就是你得花点时间来学习，在Java核心API中有些什么。往大了说，就是在完成本章学习后，就知道该怎么去获知Java API中有些什么了。</p>
<p><em>怎么才知道我要用到Java API的某个类，该如何从“要完成某个功能”过渡到“找到实现某个功能的方法”？</em></p>
<p>你已经发现了问题的本质了。在学完本书后，你将会对Java这门语言有很好的掌握。之后你的学习曲线，就是了解如何从找到问题，到通过编写尽可能少的代码，来得到问题的解决方案了。随后将讨论这个问题。</p>
<h2 id="arraylist-与-array-的不同"><a class="header" href="#arraylist-与-array-的不同"><code>ArrayList</code> 与 <code>array</code> 的不同</a></h2>
<p><code>ArrayList</code> 是一个对象。<code>array</code>也是对象，与其他对象一样，也是存活在内存堆（heap）上的。但 <code>array</code>仍然只是<code>array</code>，不会是<code>ArrayList</code>，只是个冒牌货的。对象是同时有 <strong>状态</strong> 和 <strong>行为</strong> 的（state and behavior）。<code>array</code>就没有可调用的方法。Java 中的 <code>array</code> 一旦初始化，就再也不能追加或移除其中的元素了。<code>ArrayList</code>作为头等对象，就有着移除其中元素的能力，可以动态地改变大小。<code>ArrayList</code>有着极大的灵活性。<strong>不可以直接将原生类型变量放入到 <code>ArrayList</code>中</strong> 。但将原生类型变量，封装到一个原生类型封装器类中之后，就可以将原生变量放入到 <code>ArrayList</code>中了（You can put a primitives in an <code>ArrayList</code>, as long as it's wrapped in a primitive wrapper class）。自 Java 5.0 开始，原生类型变量的封装（以及在取出原生类型变量时的解封装），就已经是自动的了。可以确定的说，在运用由原生变量构成的 <code>ArrayList</code>时，可能比使用<code>array</code>还要快，因为所有的原生变量封装与解封装，都是........话又说回来，如今谁还会用到原生类型变量呢？</p>
<p>对于 <code>ArrayList</code>，只是在操作一个普通的 <code>ArrayList</code> 类型的对象，只是调用普通对象上的方法，使用普通对象上的 <code>.</code> 运算符。而对于一个 <code>array</code>，就要使用 <em>特殊的数组语法</em> （比如 <code>myList[0] = foo</code>），这些语法只能在数组上使用，其他地方都用不到。就算数组也是对象，但数组是存在于他自己的世界中，你无法调用他上面的任何方法。可以访问到的，也只是他唯一的实例变量 <code>length</code>。</p>
<ol>
<li>
<p>普通的老式 <code>array</code>，在创建出来时就必须知道大小。</p>
<p>但对于 <code>ArrayList</code> 来说，就只需要生成一个类型为 <code>ArrayList</code>的对象就行。因为随着有对象加入或移除，<code>ArrayList</code>对象的大小会增加或收缩。</p>
<pre><code class="language-java">String[] a = new String[2];
ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt; ();
</code></pre>
</li>
<li>
<p>要将某个对象放入到常规数组中，就必须为其指定一个特定位置。</p>
<p>（而且这个位置，必须要是从 <code>0</code> 到小于该数组长度的一个值。）</p>
<pre><code class="language-java">myList[1] = b;
</code></pre>
<p>在指定的索引位置超出了该数组的边界时（比如对于一个声明了大小为2的数组，在尝试将某个值赋给索引3时），运行时就会报错（<code>java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</code>）。但对于 <code>ArrayList</code>，就可以使用 <code>add(anInt, anObject)</code> 方法，或是只写 <code>add(anObject)</code>，就可以为新加入的对象，分配到空间。</p>
<pre><code class="language-java">myList.add(b);
</code></pre>
</li>
<li>
<p>数组所使用的语法，在Java中的其他任何地方都不会用到。</p>
<p>但 <code>ArrayList</code> 就是普通的 Java 对象，因此没有特殊的语法。</p>
<pre><code class="language-java">myList[1];
</code></pre>
</li>
<li>
<p>自 Java 5.0 开始，<code>ArrayList</code> 就已经是参数化的了（parameterized）。</p>
<pre><code class="language-java">ArrayList&lt;String&gt;
</code></pre>
<p>这里的在尖括号中的 <code>String</code> 是一个 “类型参数”（<code>type parameter</code>）。 <code>ArrayList&lt;String&gt;</code> 的意思是，“一个字符串清单”，以示与 <code>ArrayList&lt;Dog&gt;</code> 表示“一个 Dog 的清单”的不同。</p>
<p>如今使用 <code>&lt;type&gt;</code> 这样的语法，就可以声明并创建 <code>ArrayList</code> 变量所能保存的对象类型。在“集合”章节将会仔细审视 <code>ArrayList</code> 中的参数化类型语法。现在只需要知道，这种语法是一种强制编译器，只允许特定类型的对象，放入到 <code>ArrayList</code> 中的办法。</p>
</li>
</ol>
<h2 id="构造器函数the-constructor-function"><a class="header" href="#构造器函数the-constructor-function">构造器函数（The <code>constructor</code> function）</a></h2>
<p>构造器函数是一个与类名称同名的特殊函数，在某个对象创建时运行，返回的是其所创建的对象（非 <code>void</code>），故构造器函数如下面这样：</p>
<pre><code class="language-java">public class DotCom {
...

public DotCom (...) {
    ...
}

...
}
</code></pre>
<h2 id="超级强大的布尔表达式supper-powerful-boolean-expressions"><a class="header" href="#超级强大的布尔表达式supper-powerful-boolean-expressions">超级强大的布尔表达式（Supper Powerful Boolean Expressions）</a></h2>
<p>在 <code>DotComBust</code> 类中的循环或 <code>if</code> 条件测试里，就已经用到了布尔表达式，这些布尔表达式是很简单的。在后续代码中，将用到更加强大的布尔表达式。</p>
<h3 id="与及或运算符"><a class="header" href="#与及或运算符">“与”及“或”运算符（<code>&amp;&amp;</code>、<code>||</code>）</a></h3>
<p>假设我写一个 <code>chooseCamera()</code> 方法，有很多如何去选择一台相机的规则。也许要选择价钱在 $50 到 $1000 的相机，在某种情形下，要更精细地去限定价格范围。可能会这样：</p>
<ul>
<li>“加入价钱在 $300 到 $400, 那么就选择 X”:</li>
</ul>
<pre><code class="language-java">if (price &gt;= 300 &amp;&amp; price &lt; 400) {
    camera = &quot;X&quot;;
}
</code></pre>
<ul>
<li>在有10个相机品牌可供选择时，有一些适用于品牌清单中少数几个的规则：</li>
</ul>
<pre><code class="language-java">if (brand.equals(&quot;A&quot;) || brand.equals(&quot;B&quot;)) {
    // 仅针对品牌 A 和 B 进行某些操作
}
</code></pre>
<p>布尔表达式可以时相当大且复杂的：</p>
<pre><code class="language-java">if ((zoomType.equals(&quot;optical&quot;) &amp;&amp;
    (zoomDegree &gt;= 3 &amp;&amp; zoomDegree &lt;= 8)) ||
    (zoomType.equals(&quot;digital&quot;) &amp;&amp; 
    (zoomDegree &gt;= 5 &amp;&amp; zoomDegree &lt;= 12))) {
        // 对这种变焦，执行相应操作
}
</code></pre>
<p>若要真的熟知布尔表达式，就要了解这些运算符的优先级（the precedence of these operators）。除了深入了解他们的优先级，还可以使用括号，来令到代码中的复杂布尔表达式更加清晰明了。</p>
<h3 id="不等于-和-"><a class="header" href="#不等于-和-">不等于（<code>!=</code> 和 <code>!</code>）</a></h3>
<p>假设有这样的一个逻辑：“10个相机型号中，除开其中的一个型号”：</p>
<pre><code class="language-java">if (model != 2000) {
    // 针对型号不是 2000 的相机，执行一些操作
}
</code></pre>
<p>或者对字符串等一些对象进行比较：</p>
<pre><code class="language-java">if (!brand.equals(&quot;X&quot;)) {
    // 对品牌不是 X 的相机进行一些操作
}
</code></pre>
<h3 id="短路运算符short-circuit-operators-"><a class="header" href="#短路运算符short-circuit-operators-">短路运算符（Short circuit operators, <code>&amp;&amp;</code>、<code>||</code>）</a></h3>
<p>对于 <code>&amp;&amp;</code> 运算符，是要其两边都是 <code>true</code> 时，表达式才是 <code>true</code> 的。所以只要虚拟机看到其左边的值为 <code>false</code>，就不会在计算运算符右边的表达式了。所以他叫做短路运算符。</p>
<p>同样对于 <code>||</code> 也是这样的，只要 JVM 看到他的左边是 <code>true</code>，会得出整个表达式就是 <code>true</code>，就不会再计算右边的值了。</p>
<p>说这个有什么用呢？比如不确定某个引用变量是否已经被赋值了某个对象，就去调用某个使用了这个空引用变量（null reference variable, 也就是，尚未将对象赋值给该引用变量）的方法时，就会得到一个 <code>NullPointerException</code>的错误代码。那么就可以这样写：</p>
<pre><code class="language-java">if (refVar != null &amp;&amp; refVar.isValidType()) {
    // 执行“已有某种类型”下的操作
}
</code></pre>
<h3 id="非短路运算符non-short-circuit-operators-"><a class="header" href="#非短路运算符non-short-circuit-operators-">非短路运算符（Non Short Circuit Operators, <code>&amp;</code>、<code>|</code>）</a></h3>
<p>在布尔表达式中使用 <code>&amp;</code> 与 <code>|</code> 运算符时，他们的表现，就跟他们的同伴 <code>&amp;&amp;</code> 与 <code>||</code> 相似，不同之处在于，这两个运算符，是要强制JVM对运算符的两边，都要进行检查。通常情况下，<code>&amp;</code> 与 <code>|</code> 是用在不同的情形下的，比如对二进制位的操作。</p>
<h2 id="使用库java-api"><a class="header" href="#使用库java-api">使用库（Java API）</a></h2>
<p>由于使用了 <code>ArrayList</code>，前面完成了 <code>DotComBust</code> 游戏。现在就是学习怎么用好 Java 库的时间了。</p>
<p><strong>在 Java API 中，类是以包的形式分组的（In the Java API, classes are grouped into packages）</strong>。</p>
<p><img src="images/Ch06_01.png" alt="在 Java API 中，类被分组为各种包" /></p>
<p><em>图 1 - 在 Java API 中，类被分组为各种包</em></p>
<p><strong>要使用API中的某个类，就要知道他在哪个包里头</strong>。</p>
<p>Java 库中的每一个类，都是属于某个包的。那个包有个名字，比如 <code>javax.swing</code> （一个有着一些 Swing GUI 类的包）。<code>ArrayList</code>则是在名为 <code>java.util</code>的包中，这个包有一堆的 <em>工具（utility）</em> 类。在第17章，将会学到更多的有关包的知识，包括如何将自己编写的类，放入自己组织的包中。</p>
<p>在代码中使用API的类，是很简单的。只需将那个类当成自己编写的，自己编译的，就在那里等着使用就可以了。有一个不同点在于，在代码中的一些地方，需要用库类的 <em>完整</em> 名字来表示，完整名字就是，包的名字 + 类的名字。</p>
<p>就算对这个不了解，<em>实际上很早就用到了来自某个包的类</em>。<code>System</code>（<code>System.out.println</code>），<code>String</code>，以及 <code>Math</code> （<code>Math.random()</code>），这些类，都是属于 <code>java.lang</code> 包的。</p>
<p><strong>对于在代码中要用到的类，就必须知道他的完整名字</strong>。</p>
<p><code>ArrayList</code> 并不是 <code>ArrayList</code> 的完整名字，就如同 <code>Kathy</code> 不是一个全名一样（除非像是 Madonna 或 Cher 这样的人）。<code>ArrayList</code>的全名实际上是：</p>
<pre><code class="language-java">java.util.ArrayList
</code></pre>
<p>其中 <code>java.util</code>是包的名字，<code>ArrayList</code>是类的名字。</p>
<p><strong>必须告诉 Java，你要使用哪个 <code>ArrayList</code></strong>，有两种做法：</p>
<ul>
<li>
<p>导入（<code>IMPORT</code>）</p>
<p>在源代码文件的顶部，放上一个导入语句：</p>
</li>
</ul>
<pre><code class="language-java">import java.util.ArrayList;
public class MyClass {...}
</code></pre>
<ul>
<li>
<p>手动输入（TYPE）</p>
<p>在代码中使用到 <code>ArrayList</code> 的各处，输入完整的名字。</p>
<p>在声明或初始化某个 <code>ArrayList</code> 变量时：</p>
</li>
</ul>
<pre><code class="language-java">java.util.ArrayList&lt;Dog&gt; list = new java.util.ArrayList&lt;Dog&gt; ();
</code></pre>
<p>在使用 <code>ArrayList</code> 变量作为参数类型时：</p>
<pre><code class="language-java">public void go (java.util.ArrayList&lt;Dog&gt; list) {...}
</code></pre>
<p>在将 <code>ArrayList</code> 作为返回值的类型时：</p>
<pre><code class="language-java">public java.util.ArrayList&lt;Dog&gt; foo () {...}
</code></pre>
<p><em>为什么这些库类，都必须有一个全名呢？难道这就是Java包的目的吗？</em></p>
<p>包的重要性，有三个方面。首先，包有助于某个项目或库的良好组织。相比于有着可怕的一大堆类文件，使用包就可以将众多的类文件，以不同目的（比如GUI的、数据结构的，或者数据库方面的等等），组织成包。</p>
<p>其次，包的使用，可以带来名称上的范围限制，从而有助于防止冲突的发生。比如你和公司的其他12名程序员，都以同样的名字编写类文件时。再比如你自己编写了一个名为 <code>Set</code> 的类文件，其他人（包括 Java 的 API）也有同名的类文件，那么就要需要一种告诉 JVM，到底要使用那个 <code>Set</code> 类的机制。</p>
<p>第三，包在一定程度上提供了安全性。因为可以对所编写的代码做限制，从而只有同一包里的其他类，才能访问到这个包。这一点在第17章将会讲到。</p>
<p>Java语言有一个命名约定，通常可以阻止冲突的发生。</p>
<p><strong>包名字中 <code>x</code> 表示什么意思</strong></p>
<p>在第一版和第二版的 Java 中（<code>1.02</code> 和 <code>1.1</code>），与 Java 语言一起发布的类（也就是标准库），都是以 <code>java</code> 打头的。这些都是 <code>java.lang</code> 的，也就是不必加以导入的。同时还有 <code>java.net</code>、<code>java.io</code>、<code>java.util</code>（尽管那个时候还没有 <code>ArrayList</code>），以及一些其他的类库，包括保存GUI相关类的 <code>java.awt</code>包。</p>
<p>逐渐的，标准库中未包含的其他包逐一出现。这些类也就是我们所说的 <strong>扩展（extensions）</strong>，这些扩展又有两种： <em>标准（standard）</em> 与 <em>非标准（not standard）</em> 扩展。标准扩展是那些 Sun 公司认为的官方扩展，他们与实验性扩展、早期版本或者说 beta 版等，或许永远也不会投入使用的包，有所不同。</p>
<p>按照惯例，标准扩展都是在原本作为开头的 <code>java</code> 之后，追加了 <code>x</code> 打头的。而所有标准扩展的开创者，就是 Swing 库。这个库包含了若干个包，这些包都是以 <code>javax.swing</code> 开头的。</p>
<p>而某些标准扩展，就有机会得到提升，从而成为头等的、Java自带的、标准的即开即用的库文件包。从 Java 1.2 开始，Swing就享受到了这样的待遇。</p>
<p>“真不赖” ，所有人都这样想，“往后所有装了Java的人就都有了 Swing 类文件了，就再也不需要给我们的终端用户去安装这个类了”。</p>
<p>但麻烦随之而来，在这些包得到提升之后，理所当然他们就不得不以 <code>java</code> 打头，而再也不是 <code>javax</code>打头了。所有人都知道标准库都不带有 <code>x</code>，而只有扩展才有。那么，就在 <code>1.2</code> 版本终结的时候，Sun公司就修改了这些包的名字，把其中的 <code>x</code> 删除掉了（以及其他的一些改变）。这个时候很多即将印刷以及在书店售卖的Java书，将 Swing 代码以新名字加以介绍。命名约定得到遵守。在Java世界里万事大吉。</p>
<p>但对于超过 20k 的开发者来说，他们意识到这样简单的名字改变，却带来了灾难！他们的所有用到 Swing 的代码，都不得不进行修改！多么可怕！想想那些以 <code>javax</code> 开头的代码...</p>
<p>在最后时刻，伴随着希望变得渺茫，他们绝望了，这些开发者说服了 Sun 公司，去“打破惯例，拯救他们的代码”。剩下的事情就成了历史。因此当你看到在库中以 <code>javax</code> 打头的某个包，就应该知道这个包是以某个扩展诞生，随后获得了提升（进入到标准库中）。</p>
<h2 id="知识点"><a class="header" href="#知识点">知识点</a></h2>
<ul>
<li><code>ArrayList</code> 是 Java API 中的一个类</li>
<li>使用 <code>add()</code> 方法，往 <code>ArrayList</code> 中放入某些东西</li>
<li>要从<code>ArrayList</code>中移除某物，使用 <code>remove()</code> 方法</li>
<li>使用 <code>indexOf()</code>方法，来确定某对象是否在 <code>ArrayList</code> 中</li>
<li>要确定某个 <code>ArrayList</code> 是否为空，使用 <code>isEmpty()</code> 方法</li>
<li>使用 <code>size()</code> 方法，来获取某个 <code>ArrayList</code> 的大小（元素个数）</li>
<li>对于常规的老式数组，要获取其长度（length, 元素个数），使用的是其变量<code>length</code></li>
<li><code>ArrayList</code> 引用变量的大小，可以根据需要动态的改变。在添加了对象后，就会变大；在移除对象后，相应地会变小</li>
<li>在声明<code>ArrayList</code>引用变量的数组类型时，使用的是 <strong>类型参数（type parameter）</strong>，也就是在尖括号中的一个类型名称。比如，<code>ArrayList&lt;Button&gt;</code> 意思是这个 <code>ArrayList</code> 将只能保存类型为 <code>Button</code> 的对象（或者 <code>Button</code> 的子类，后续章节会学习相关的内容）。</li>
<li>尽管 <code>ArrayList</code> 保存的是对象而非原生变量，但编译器会自动地对原生变量进行封装（ <strong>wrap</strong>, 并在从 <code>ArrayList</code> 中取出原生变量时，进行解封装， <strong>unwrap</strong>），使其成为一个对象，从而放入到 <code>ArrayList</code> 中的，就是封装后的对象，而不在时原来的原生变量了。</li>
<li>类是以包的形式进行组织的。</li>
<li>类有着由其所属包的名字，和类本身名字，组合而成的全名。类 <code>ArrayList</code> 实际上是 <code>java.util.ArrayList</code></li>
<li>要使用除 <code>java.lang</code> 之外的其他包中的某个类，就必须告诉 Java 那个类的全名</li>
<li>要么在源代码文件的顶部使用一条导入语句，要么就在代码中所有要用到类的地方，输入这个类的全名</li>
</ul>
<h2 id="关于-import-语句"><a class="header" href="#关于-import-语句">关于 <code>import</code> 语句</a></h2>
<p><code>import</code> 与 C 语言中的 <code>include</code> 不同。因此 <code>import</code> 的使用不会令到类变得更大，同时也不会将所导入的类或包，编译到自己的代码中去。<code>import</code> 的使用，是从大量的敲代码中拯救你的。无需担心过多地使用 <code>import</code> 会导致代码臃肿或变慢。<code>import</code>就只是一种你让Java知道某个类的全名的方式而已。</p>
<p><strong>为什么不需要导入 <code>String</code> 或 <code>System</code> 类呢？</strong></p>
<p>那是因为 <code>java.lang</code> 是特殊的 <strong>预导入（pre-imported）</strong> 包。因为在 <code>java.lang</code>中的那些类是相当基础的类，因此就不必使用他们的全名。这样的也就只有两个： <code>java.lang.String</code> 和 <code>java.lang.System</code>，Java 很清楚可以在哪里找到他们。</p>
<p><strong>必须把自己编写的类也放入Java包里吗？怎样才能放入包里，可以这样做吗？</strong></p>
<p>在生产中，是应该把自己编写的类文件，放入到包中的。在第17章会讲到这个问题。</p>
<h2 id="牢牢记住"><a class="header" href="#牢牢记住">牢牢记住</a></h2>
<pre><code class="language-console">Roses are red,
apples are ripe,
if you don't import
you'll just have to type
</code></pre>
<p>在没有使用导入语句时，除了那些 <code>java.lang</code>包中的类之外，就 <strong>必须告诉Java所用到的每个类的全名</strong>。在源代码文件顶部，使用一个类或包的<code>import</code>导入语句，是一种简便方法。否则，就必须在使用到那个类或包的所有地方，都敲入他的全名！</p>
<h2 id="使用-api-的方法"><a class="header" href="#使用-api-的方法">使用 API 的方法</a></h2>
<p>两个问题：</p>
<ol>
<li>在库中有哪些类文件？</li>
<li>在找到某个类之后，怎样才能知道他是用来做什么的？</li>
</ol>
<p>有两个途径：</p>
<ol>
<li>
<p>翻书</p>
<p>一本 Java 参考书，就是去发现Java库里有些什么的最好办法。</p>
</li>
<li>
<p>查看线上的 HTML API 文档</p>
<p>Java 本身就有着一套良好的线上文档，名字就叫 Java API。这套文档又是另外一套更大的名为 Java 5 标准版文档的一部分，这些线上文档还必须得去单独下载；这些文档不是和 Java 程序一起提供的。</p>
<p>这些API文档，在要进一步了解某个类及其方法时，最好的参考资料。比如在查阅参考书时，在 <code>java.util</code>包中发现一个名为 <code>Calendar</code> 的类时，参考书只能告诉你这个类的有限的、仅能让你明白这个类正是你要用到的一点点内容，在你需要了解更多的有关这个类的信息时，就可以在线上文档里找到。</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Ch05_Writing_a_Program_Extra-Strength_Methods.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="Ch07_Inheritance_and_Polymorphism_Better_Living_in_Objectville.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Ch05_Writing_a_Program_Extra-Strength_Methods.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="Ch07_Inheritance_and_Polymorphism_Better_Living_in_Objectville.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
