<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>序列化为文件 I/O：保存对象</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">轻松学Java（Head First Java）</a></li><li class="chapter-item expanded "><a href="Ch01_Dive_in_A_Quick_Dip_Breaking_the_Surface.html"><strong aria-hidden="true">1.</strong> 快速投身于 Java：破冰</a></li><li class="chapter-item expanded "><a href="Ch02_Class_and_Objects_A_Trip_to_Objectville.html"><strong aria-hidden="true">2.</strong> 类与对象：对象村之旅</a></li><li class="chapter-item expanded "><a href="Ch03_Primitives_and_References_Know_Your_Variables.html"><strong aria-hidden="true">3.</strong> 原生与引用变量：了解你的那些变量</a></li><li class="chapter-item expanded "><a href="Ch04_Methods_Use_Instance_Variables_How_Objects_Behave.html"><strong aria-hidden="true">4.</strong> 用到实例变量的那些方法：对象行为机制</a></li><li class="chapter-item expanded "><a href="Ch05_Writing_a_Program_Extra-Strength_Methods.html"><strong aria-hidden="true">5.</strong> 编写一个程序：方法之附加力量</a></li><li class="chapter-item expanded "><a href="Ch06_Get_to_Know_The_Java_API_Using_the_Java_Library.html"><strong aria-hidden="true">6.</strong> 了解 Java API：运用 Java 的库</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">继承和多态机制</li><li class="chapter-item expanded "><a href="Ch07_Inheritance_and_Polymorphism_Better_Living_in_Objectville.html"><strong aria-hidden="true">7.</strong> 继承与多态：在对象村更好的过活</a></li><li class="chapter-item expanded "><a href="Ch08_Interfaces_and_Abstract_Classes.html"><strong aria-hidden="true">8.</strong> 接口及抽象类</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">编译器、堆与栈</li><li class="chapter-item expanded "><a href="Ch09_Constructors_and_Garbage_Collection_Life_and_Death_of_an_Object.html"><strong aria-hidden="true">9.</strong> 构造器与垃圾回收：对象的生与死</a></li><li class="chapter-item expanded "><a href="Ch10_Numbers_and_Statics_Numbers_Matter.html"><strong aria-hidden="true">10.</strong> 数字与静态元素：数字为要</a></li><li class="chapter-item expanded "><a href="Ch11_Exception_Handling_Risky_Behavior.html"><strong aria-hidden="true">11.</strong> 异常处理：冒险行为</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">GUI</li><li class="chapter-item expanded "><a href="Ch12_Getting_GUI_A_Very_Graphic_Story.html"><strong aria-hidden="true">12.</strong> 得到图形用户界面：一个甚为形象的故事</a></li><li class="chapter-item expanded "><a href="Ch13_Using_Swing_Work_on_Your_Swing.html"><strong aria-hidden="true">13.</strong> 运用 Swing：工作于 Swing 之上</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">对象序列化与数据结构</li><li class="chapter-item expanded "><a href="Ch14_Serialization_and_File_I_O_Saving_Objects.html" class="active"><strong aria-hidden="true">14.</strong> 序列化为文件 I/O：保存对象</a></li><li class="chapter-item expanded "><a href="Ch15_Networking_and_Threads_Make_a_Connection.html"><strong aria-hidden="true">15.</strong> 网络通信与线程：构造连接</a></li><li class="chapter-item expanded "><a href="Ch16_Collections_and_Generics_Data_Structure.html"><strong aria-hidden="true">16.</strong> 集合与泛型：数据结构</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">完结部分</li><li class="chapter-item expanded "><a href="Ch17_Package_JARs_and_Deployment_Release_Your_Code.html"><strong aria-hidden="true">17.</strong> 打包、JARs 与部署：发布代码</a></li><li class="chapter-item expanded "><a href="Ch18_Remote_Deployment_with_RMI_Distributed_Computing.html"><strong aria-hidden="true">18.</strong> 远端部署与 RMI：分布式计算</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">附录</li><li class="chapter-item expanded "><a href="Ch19_Appendix_A.html"><strong aria-hidden="true">19.</strong> 附录 A：十个几乎会进到本书的题目</a></li><li class="chapter-item expanded "><a href="Ch20_Appendix_B.html"><strong aria-hidden="true">20.</strong> 附录 B：其他要点</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="对象序列化与文件-io-对象的保存"><a class="header" href="#对象序列化与文件-io-对象的保存">对象序列化与文件 <code>I/O</code>: 对象的保存</a></h1>
<p><strong>serialization and file <code>I/O</code>: Saving Objects</strong></p>
<p><img src="images/Ch14_01.png" alt="第14章题图" /></p>
<p><em>图  1 - 第14章题图</em></p>
<p><strong>对象可被放气或充气（Objects can be flattened and inflated）</strong>。对象具有状态和行为。关于对象的那些 <em>行为</em>，是存活在 <em>类</em> 中，而 <em>状态</em> 则是存活在各个单独 <em>对象</em> 中的（<em>Behavior</em> lives in the <em>class</em>, but <em>state</em> lives within each individual <em>object</em>）。那么在对对象状态进行保存时，会发生什么呢？比如在编写某个游戏时，就会需要一个特性来保存/恢复游戏。又比如在编写某个创建图表的app时，就需要一个保存/打开文件的特性。在程序需要保存状态时，<em>可以笨办法来完成</em>，对各个对象进行询问，然后费力地将各个示例变量的值，以某种自创格式，写到一个文件。或者，<strong>可以轻松的面向对象方式完成</strong> -- 简单地将对象本身冻干/压平/持久化/脱水，然后再通过重组/填充/恢复/注水，来取回对象。不过 <em>某些时候</em> 仍然需要以笨办法来完成对象状态的保存，尤其是app保存的文件必定会被其他非Java语言的 app 读取的时候，所以本章会对这两种保存对象状态的方式加以审视（If your program needs to save state, <em>you can do it the hard way</em>, interrogating each object, then painstakingly writing the value of each instance variable to a file, in a format you create. Or, <strong>you can do it the easy OO way</strong> -- you simply freeze-dry/flatten/persist/dehydrate the object itself, and reconstitue/inflate/restore/rehydrate it to get it back. But you'll still have to do it the hard way <em>sometimes</em>, especially when the file your app saves has to be read by some other non-Java application, so we'll look at both in this chapter）。</p>
<h2 id="对节拍进行捕获"><a class="header" href="#对节拍进行捕获">对节拍进行捕获</a></h2>
<p><strong>Capture the Beat</strong></p>
<p>现在 <em>构造</em> 好了完美的音乐曲目。那么就要把这个曲目 <em>存储</em> 起来。当然可以拿张纸然后摘抄下来，不过这里是要做成点击 <em><strong>保存</strong></em> 按钮的方式（或者从“文件”菜单中选择“保存”）。接着就要提供一个名称，选取某个目录，并确保这首优美的曲子，不会因为系统蓝屏司机而丢失（You could grab a piece of paper and start scribbling it down, but instead you hit the <em><strong>Save</strong></em> button(or choose Save from the File menu). Then you give it a name, pick a directory, and exhale knowing that your masterpiece won't go out the window with the blue screen of death）。</p>
<p>对于保存Java 程序状态来说，有很多个选项，至于具体选用何种选项，将取决于计划怎样去 <em>使用</em> 所保存的状态（You have lots of options for how to save the state of your Java program, and what you choose will probably depend on how you plan to <em>use</em> the saved state）。本章要检视的几种选项如下所示。</p>
<p><strong>在数据只会被生成数据的 Java 程式使用到时（If your data will be used by only the Java program that generated it）</strong>：</p>
<ol>
<li>
<p><strong>运用对象序列化</strong></p>
<p><strong>Use <em>serialization</em></strong></p>
<p>对留存了被压扁（序列化的）对象的一个文件进行写入。随后程序就从这个文件读取这些序列化的对象，并将他们充实回到活生生的、有呼吸的、存在于内存堆的对象（Write a file that holds flattened(serialized) objects. Then have your program read the serialized objects from the file and inflate them back into living, breathing, heap-inhabiting objects）。</p>
<p><strong>在数据会被其他程序使用到时</strong>：</p>
</li>
<li>
<p><strong>写入 <em>普通文本</em> 文件</strong></p>
<p><strong>Write <em>a plain text</em> file</strong></p>
<p>写入到一个带有分隔符，从而可被其他程序解析的文件。比如就可以写入到一个由制表符分隔的、可被电子表格或数据库应用使用的文件（Write a file, with delimiters that other programs can parse. For example, a tab-delimited file that a spreadsheet or database application can use）。</p>
<p>当然并非只有这两个选项。可以所选的任意格式来保存数据。除了往文件中写入字符，还可以将数据写为字节（Instead of writing characters, for example, you can write your data as bytes）。还可以把那些 Java 原生值当作 Java 原生值来写入文件 -- 对于整数、长整数、布尔值等原生值类型，是有相应方法来写入文件的。但不管使用何种方法来保存数据，文件<code>I/O</code>的基本技巧总是不变的：把一些数据写入到 <em>某个东西（something）</em>，而通常这某个东西要么是磁盘上的文件、要么就是来自网络连接的流（But regardless of the method you use, the fundamental <code>I/O</code> techniques are pretty much the same: write some data to <em>something</em>, and usually that something is either a file on disk or a stream coming from a network connection）。读取数据则是同样的过程，只是反过来而已：从磁盘上的文件或某个网络连接，读取到一些数据。同时本章所讨论的内容，是在未使用到某种具体数据库时，所涉及的数据保存。</p>
</li>
</ol>
<h2 id="对状态进行保存"><a class="header" href="#对状态进行保存">对状态进行保存</a></h2>
<p><strong>Saving State</strong></p>
<p>设想有这么一个程序，比方说，一个奇幻冒险游戏，需要与玩家进行多次会话才能完成。随着游戏的进展，游戏中的角色变得愈加强大、弱小、灵巧等等，并会收集（或丢失）各种武器。那么就肯定不愿意每次启动游戏都又从头开始玩 -- 那样你的游戏角色就永远不会在某次激烈战斗中有最佳状态。那么就需要一种保存游戏角色状态的方式，以及在继续游戏时对状态进行恢复的方式。而由于作为游戏程序的编写者，就会希望整个保存与恢复，应该尽可能是容易实现（且简单明了）。</p>
<ol>
<li>
<p>选项一</p>
<p><strong>把这三个序列化的游戏角色写到某个文件</strong></p>
<p>创建出一个文件，并写入三个序列化角色对象。这个文件在作为文本进行读取时，并无任何意义：</p>
<pre><code class="language-console"> ̈ÌsrGameCharacter 
 ̈%gê8MÛIpowerLjava/lang/
 String;[weaponst[Ljava/lang/
 String;xp2tlfur[Ljava.lang.String;≠“VÁ
 È{Gxptbowtswordtdustsq~»tTrolluq~tb
 are handstbig axsq~xtMagicianuq~tspe
 llstinvisibility
</code></pre>
</li>
<li>
<p>选项二</p>
<p><strong>写入普通文本文件</strong></p>
<p>创建出一个文件，并写入三行文本，每行一个游戏角色，用逗号分隔角色状态的各个部分：</p>
<pre><code class="language-console">50,Elf,bow, sword,dust
200,Troll,bare hands,big ax
120,Magician,spells,invisibility
</code></pre>
<p><img src="images/Ch14_02.png" alt="对象存储图解" /></p>
<p><em>图 2 - 对象存储图解</em></p>
</li>
</ol>
<h2 id="把序列化对象写到某个文件"><a class="header" href="#把序列化对象写到某个文件">把序列化对象写到某个文件</a></h2>
<p>以下就是将对象进行序列化（保存）的步骤（Here are the steps for serializing(saving) an object）。不用纠结于把这些步骤都记住；本章后续会深入讲解。</p>
<ol>
<li>
<p><strong>构造一个 <em><code>FileOutputStream</code></em> 对象</strong></p>
<pre><code class="language-java">// 构造出一个 FileOutputStream 对象。FileOutputStream 知道怎样去
// 连接（并创建出）一个文件。
// 
// 若这个 “MyGame.ser” 文件不存在，那么他就会被自动创建出来。
FileOutputStream fileStream = new FileOutputStream(&quot;MyGame.ser&quot;);
</code></pre>
</li>
<li>
<p><strong>构造一个 <em><code>ObjectOutputStream</code> 对象</em></strong></p>
<pre><code class="language-java">// ObjectOutputStream 实现对象写到文件，但他无法直接连接到
// 文件。他需要喂入一个“helper”。这实际上就是把一个流“链接”
// 到另一个上（This is actually called 'chaining' one stream
// to another）。
ObjectOutputStream oStream = new ObjectOutputStream(fileStream);
</code></pre>
</li>
<li>
<p><strong>写入对象</strong></p>
<pre><code class="language-java">// 对这些由 characterOne, Two, Three 所表示的对象进行序列化操作
// 并将他们写到文件 “MyGame.ser” 中。
oStream.writeObject(characterOne);
oStream.writeObject(characterTwo);
oStream.writeObject(characterThree);
</code></pre>
</li>
<li>
<p><strong>关闭 <code>ObjectOutputStream</code></strong></p>
<pre><code class="language-java">// 关闭了顶部的流，就会关闭其下所有的其他流，因此 `FileOutputStream` 
// （及那个文件）就会自动关闭。
oStream.close();
</code></pre>
</li>
</ol>
<p><strong>在各种流中，数据从一处往另一处移动（Data moves in streams from one place to another）</strong>。</p>
<p>Java 的 <code>I/O</code> API，有着各种表示到诸如文件或网络套接字这类目的与源的连接，以及将那些只有被链接到其他流才会工作的流 <em><strong>链接</strong></em> 起来的 <em>连接性</em> 流（The Java <code>I/O</code> API has <em><strong>connection</strong></em> streams, that represent connections to destinations and sources such as files or network sockets, and <em><strong>chain</strong></em> streams that work only if chained to other streams）。</p>
<p>通常，要至少同时钩起两个流流，才能完成有用的事情 -- <em>一个</em> 表示连接，而 <em>另一个</em> 则是要调用到他的方法。为什么是两个呢？因为 <em>连接</em> 流通常都是很低级别的。就拿 <code>FileOutputStream</code>（就是一个连接流）来说，就有写入 <em>字节</em> 的一些方法。但这里并不想要写入 <em>字节</em>！这里要的是写入 <em>对象</em>，因此就需要一个高级别的 <em>链接</em> 流（Often, it takes at least two streams hooked together to do something useful -- <em>one</em> to represent the connection and <em>another</em> to call methods on. Why two? Because <em>connection</em> streams are usually too low-level. <code>FileOutputStream</code>(a connection stream), for example, has methods for writing <em>bytes</em>. But we don't want to write <em>bytes</em>! We want to write <em>objects</em>, so we need a higher-level <em>chain</em> stream）。</p>
<p>好，那么又为什么不只要精准完成所需的单个流呢？一个实现对象写入并同时将对象转换成字节的流？这就要考虑良好的面向对象了。每个类做好 <em>一件</em> 事情。<code>FileOutputStream</code> 就是把字节写入到文件。<code>ObjectOutputStream</code> 就是把对象转换成可写入到流的数据。所以这里构造一个 <code>FileOutputStream</code> 来实现到文件的写入，并在 <code>FileOutputStream</code> 末尾钩起一个 <code>ObjectOutputStream</code>（一个链接流）。在调用<code>ObjectOutputStream</code>上的 <code>writeObject()</code> 方法时，对象就被泵入到流中，随后就移动到 <code>FileOutputStream</code>，在那里最终被作为一些字节，写到某个文件。</p>
<p>不同连接与链接流组合的混搭能力，赋予到我们惊人的灵活性！若强制要求使用仅仅 <em>单个</em> 的流类，那么就会受 API 设计者们的支配，就会希望他们能考虑到咱们所期望的所有功能。然而有了流链接特性，就可以组装出自己 <em>定制</em> 的各种流链（The ability to mix and match different combinations of connection and chain streams gives you tremendous flexibility! If you were forced to use only a <em>single</em> stream class, you'd be at the mercy of the API designers, hoping they'd thought of <em>everything</em> you might ever want to do. But with chaining, you can patch together your own <em>custom</em> chains）。</p>
<p><img src="images/Ch14_03.png" alt="Java对象写入文件过程" /></p>
<p><em>图 3 - Java对象写入文件过程</em></p>
<h2 id="在对象被序列化时到底发生了什么"><a class="header" href="#在对象被序列化时到底发生了什么">在对象被序列化时，到底发生了什么？</a></h2>
<p><strong>What really happens to an object when it's serialized</strong>?</p>
<p><img src="images/Ch14_04.png" alt="图解存活对象与序列化对象的区别" /></p>
<p><em>图 4 - 图解存活对象与序列化对象的区别</em></p>
<p><img src="images/Ch14_05.png" alt="Java保存对象实例" /></p>
<p><em>图 5 - Java保存对象实例</em></p>
<h3 id="然而对象状态-究竟是-个什么呢到底需要保存什么呢"><a class="header" href="#然而对象状态-究竟是-个什么呢到底需要保存什么呢">然而对象状态 <em>究竟是</em> 个什么呢？到底需要保存什么呢？</a></h3>
<p><strong>But what exactly <em>IS</em> an object's state? What needs to be saved</strong>?</p>
<p>现在就开始变得有趣起来了。要保存 <em>原生</em> 值 <code>37</code> 与 <code>70</code> 是相当容易。但如果对象有着一个是对象 <em>引用</em> 的实例变量呢？某个对象有着五个的对象引用的实例变量又会怎样呢？如果这些对象实例变量本身又有实例变量的话，又会怎样呢（Easy enough to save the <em>primitive</em> values <code>37</code> and <code>70</code>. But what if an object has an instance variable that's an object <em>reference</em>? What about an object that has five instance variables that are object references? What if those object instance variables themselves have instance variables）？</p>
<p>请想想。对象的什么部分，是潜在唯一的？试想一下为了获得一个与所保存对象一致的对象，究竟需要恢复的是什么。当然对象将有着不同的内存位置，然而对于这一点我们并不关心。这里所关心的，全是在内存堆上得出的结果，将获取到一个与对象被保存时有着相同状态的一个内存堆上的存活对象。</p>
<h2 id="脑力锻炼"><a class="header" href="#脑力锻炼">脑力锻炼</a></h2>
<p><img src="images/Ch14_06.png" alt="如何保存带有到其他对象引用变量的对象" /></p>
<p><em>图 6 - 如何保存带有到其他对象引用变量的对象</em></p>
<p>必须要怎样保存 <code>Car</code> 对象，才能从 <code>Car</code> 副本中恢复到其原先的状态？</p>
<p>试想一下要保存 <code>Car</code> 对象会需要些什么 -- 以及怎样去保存他。</p>
<p>同时在 <code>Engine</code> 对象又有着到 <code>Carburetor</code> 对象的引用时，会怎样呢？以及在 <code>Tire []</code> 这个数组对象中又有着什么呢？</p>
<p><strong>在某个对象被序列化时，自其实例变量引用到的全部对象同时被实例化。这些被引用对象引用到的对象亦被实例化。这些被引用到的对象所引用的对象，亦被实例化......而最妙的地方就是，这些都是自动发生的</strong>！</p>
<p>这个 <code>Kennel</code> 对象有着一个到 <code>Dog []</code> 数组对象的引用。而 <code>Dog []</code> 中留存了对两个 <code>Dog</code> 对象的引用。每个 <code>Dog</code> 对象留存了到一个字符串及一个 <code>Collar</code> 对象的引用。字符串对象有着一个字符集合，同时 <code>Collar</code> 对象有着一个整数。</p>
<p><img src="images/Ch14_07.png" alt="对象保存时涉及实例变量为对象引用的情形" /></p>
<p><em>图 7 - 对象保存时涉及实例变量为对象引用的情形</em></p>
<blockquote>
<p><strong>序列化保存了完整的 <em>对象图面（object graph）</em>。自所保存对象开始，全部的实例变量引用到对象，都会被序列化</strong>。</p>
</blockquote>
<h2 id="在希望所编写的类可被序列化时就要实现-serializable-接口"><a class="header" href="#在希望所编写的类可被序列化时就要实现-serializable-接口">在希望所编写的类可被序列化时，就要实现 <code>Serializable</code> 接口</a></h2>
<p><strong>If you want your class to be serializable, implement <code>Serializable</code></strong></p>
<p>由于 <code>Serializable</code> 接口没有要实现的方法，因此又被称作 <em>标记</em> 或者说 <em>标签</em> 接口（The <code>Serializable</code> interface is known as a <em>marker</em> or <em>tag</em> interface, because the interface doesn't have any methods to implement）。 其唯一目的，就是通告实现了他的类，是 <em>可被序列化的（serializable）</em>。也就是说，<code>Serializable</code> 类型的类，可通过序列化机制加以保存（In other words, objects of that type are saveable through the serialization mechanism）。在有超类是可序列化的类时，那么其子类将自动成为可序列化类，即使其子类并未显示声明 <em><code>implements Serializable</code></em>。（这也是接口一贯的 <em>运作</em> 方式。在某个类的超类 <code>IS-A</code> <code>Serializable</code>时，那么这个类同样是 <code>Serializable</code>的）。</p>
<pre><code class="language-java">// 这里传递给 writeObject() 方法的参数，必须 实现了 Serializable
// 接口，否则在运行时就会失败
objectOutputStream.writeObject(myBox);
</code></pre>
<p>--</p>
<pre><code class="language-java">package com.xfoss.learningJava;

// 接口 Serializable 是在 java.io 包中，因此要需要这个 import 语句
import java.io.*;

// 虽然没有要实现的方法，但在写下这里的 &quot;implements Serializable&quot;
// 时，就等于告诉了JVM，“可对这种类型的对象进行序列化。”
public class Box implements Serializable {

    // 这两个值将会被保存起来
    private int width;
    private int height;

    public void setWidth (int w) {
        width = w;
    }

    public void setHeight (int h) {
        height = h;
    }

    public static void main (String[] args) {
        Box box = new Box();
        box.setWidth(50);
        box.setHeight(20);

        // I/O 操作可能抛出异常。
        try {
            // 若存在一个名为“Box.ser”的文件，那么就连接到这个文件。而若不
            // 存在，就构造一个新的名为 “Box.ser” 的文件。
            FileOutputStream fStream = new FileOutputStream(&quot;Box.ser&quot;);
            // 构造一个链接到连接流 FileOutputStream 的 ObjectOutputStream 对象
            // 让他写入对象 box。
            ObjectOutputStream oStream = new ObjectOutputStream(fStream);
            oStream.writeObject(box);
            oStream.close();
        } catch (Exception ex) {ex.printStackTrace();}
    }
}
</code></pre>
<p>运行这段代码将创建出一个 <code>Box.ser</code> 的文件，其内容为：</p>
<pre><code class="language-console">¬í sr com.xfoss.learningJava.Boxý	¼%~FH I heightI widthxp      2
</code></pre>
<p>以后不管运行多少次，<code>Box.ser</code> 的内容都不会改变。</p>
<h2 id="序列化就是全部或者全无"><a class="header" href="#序列化就是全部或者全无">序列化就是全部，或者全无。</a></h2>
<p><strong>Serialization is all or nothing</strong>.</p>
<p><strong>设想一下如果对象的某些状态没有正确保存，会发生什么呢</strong>？</p>
<p><img src="images/Ch14_08.png" alt="序列化对象恢复的风险" /></p>
<p><em>图 8 - 序列化对象恢复的风险</em></p>
<p><strong>要么整个的对象图面被正确序列化，但凡有一个差错，那么就算作序列化失败（Either the entire object graph is serialized correctly or serialization fails）</strong>。</p>
<p><strong>在对一个 <code>Pond</code> 对象进行序列化时，若他 <code>Duck</code> 实例变量拒绝被实例化（因为没有对 <code>Serializable</code> 接口进行实现），那么就无法实例化这个 <code>Pond</code> 对象</strong>。</p>
<pre><code class="language-java">package com.xfoss.learningJava;

import java.io.*;

// Pond 的对象，可被序列化
public class Pond implements Serializable {
    // 类 Pond 有一个实例变量，是到一个 Duck 
    // 对象的引用。
    private Duck duck = new Duck();
    
    public static void main (String[] args) {
        Pond pond = new Pond();

        try {
            FileOutputStream fStream = new FileOutputStream(&quot;Pond.ser&quot;);
            ObjectOutputStream oStream = new ObjectOutputStream(fStream);

            // 在对 pond （一个 Pond 的对象）进行序列化时，该对象
            // 的 Duck 实例变量会自动被序列化。
            oStream.writeObject(pond);
            oStream.close();
        } catch (Exception ex) { ex.printStackTrace(); }
    }
}

// 然而！！Duck（在 com.xfoss.learningJava.UseADuck中声明） 并
// 不是可序列化的！Duck 类并没有实现 Serializable, 因此在对
// Pond 对象进行序列化时，由于该 Pond 对象的 Duck 实例变量
// 无法被保存，而失败。
</code></pre>
<p>将报出以下错误：</p>
<pre><code class="language-console">Quack... My size is 32, my number is 1
java.io.NotSerializableException: com.xfoss.learningJava.Duck
        at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1185)
        at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1553)
        at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1510)
        at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433)
        at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179)
        at java.base/java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:349)
        at com.xfoss.learningJava.Pond.main(Pond.java:15)
</code></pre>
<p><img src="images/Ch14_09.png" alt="非 Serializable 对象无法被序列化的麻烦" /></p>
<p><em>图 9 - 非 <code>Serializable</code> 对象无法被序列化的麻烦</em></p>
<p><strong>在实例变量无法（或不应）被保存时，就要把他标记为 <em>瞬态</em> 实例变量（Mark an instance variable as <em>transient</em> if it can't (or shouldn't) be saved）</strong>。</p>
<p>若希望某个实例变量跳过对象的序列化过程，那么就要使用 <code>transient</code> 关键字，对该变量进行标记。</p>
<pre><code class="language-java">import java.net.*;

class Chat implements Serializable {
    // 关键字 transient, 说的是 “在序列化期间不要
    // 保存这个变量，只要跳过他就好。”
    transient String currentID;

    // 在序列化期间，变量 userName 将被保存为该对象
    // 的一部分。
    String userName;

    // 其他代码
}
</code></pre>
<p>在有着一个因为本身不是可序列化，而无法被保存的实例变量时，就可以使用 <code>transient</code> 关键字对那个变量进行标记，从而序列化过程就会精准地跳过他。</p>
<p><strong>然而一个变量无法被序列化的原因又究竟为何呢</strong>？其中可能简单地就是，那个类的设计者仅仅是 <em>忘了</em> 把其构造为对 <code>Serializable</code> 接口进行实现。或者由于对象依赖于一些特定于运行时信息，因此就直接无法保存。虽然 Java 类库中绝大多数物件都是可序列化的，但对于诸如网络连接、线程或文件对象等物件，是无法保存的。这些物件，全都依赖于（特定于）某种特别运行时 “体验”。也就是说，这些对象是以专为所编在程序，在特定平台上、在特定的JVM中的一次特定运行，而进行初始化的。一旦程序关闭，就没有了将这些物件，以任何有意义的方式，再复活过来的办法；这些对象，每次都要从头创建出来（So why would a variable not be seralizable? It could be that the class designer simply <em>forgot</em> to make the class implement <code>Serializable</code>. Or it might be because the object relies on runtime-specific information that simply can't be saved. Although most things in the Java class libraries are serializable, you can't save things like network connections, threads, or file systems. They're all dependent on (and specific to) a particular runtime 'experience'. In other words, they're instantiated in a way that's unique to a particular run of your program, on a particular platform, in a particular JVM. Once the program shuts down, there's no way to bring those thins back to life in any meaningful way; they have to be created from scratch each time）。</p>
<h2 id="答疑"><a class="header" href="#答疑">答疑</a></h2>
<ul>
<li><strong>既然序列化如此重要，那为何不是全部类都默认可序列化呢？为何类 <code>Object</code> 没有实现 <code>Serializable</code> 接口，这样所有子类就自动地可被序列化了呀</strong>？</li>
</ul>
<blockquote>
<p>尽管绝大多数类都会，且都应对 <code>Serializable</code> 接口进行实现，不过仍然可以选择选择不予实现此接口。对于所设计的类，必须逐一审视，在是否要通过实现 <code>Serializable</code> 来 “开启” 序列化功能上，作出慎重决定。那么首先，如果序列化作为默认了，又该怎样把他关掉呢？<strong>接口就意味着功能，而非功能的消减（Interfaces indicate functionality, not a <em>lack</em> of functionality）</strong>，那么如果这样来告诉外部世界某个对象无法保存：<code>implements NonSerializable</code>，多态机制模型就会无法正确运作了。</p>
</blockquote>
<ul>
<li><strong>究竟为何要编写一个不可序列化的类</strong>？</li>
</ul>
<blockquote>
<p>编写不可序列化类的理由极少，比如在不希望某个口令对象被存储起来地方，如果将其编写为可序列化对象而被保存了起来，那么就会有着安全问题。有比如在有着某个由于其关键实例变量就是不可序列化的他们本身，而保存起来没什么意义的类时，那么这个时候如果再把他们构造为可序列化的类，就没有什么有用处，多此一举了（There are very few reasons, but you might, for example, have a security issue where you don't want a password object stored. Or you might have an object that makes no sense to save, because its key instance variables are themselves not serializable, so there's no useful way for you to make your class serializable）。</p>
</blockquote>
<ul>
<li><strong>在所使用的类不是可序列化的，又没有什么好的理由去来让这个类不可序列化（仅仅由于这个类的设计者忘记给这个类实现 <code>Serializable</code> 接口，或由于其设计者的愚蠢），那么可以对这个“不良”的类进行子类化，从而将子类构造为可序列化的吗</strong>？</li>
</ul>
<blockquote>
<p>当然可以！在类本身为可扩展时（即非 <code>final</code>），就可以构造一个可序列化子类，并只要在那些期望那个超类类型的地方，用这个子类去替换即可。（请记住，多态机制是允许这样做的。）不过这又提出了另一个有趣的问题：超类不可序列化究竟意味着什么呢？</p>
</blockquote>
<ul>
<li><strong>你所提到的：从不可序列化类构造出可序列化类，意味着什么</strong>？</li>
</ul>
<blockquote>
<p>这里就要先看看在类解序列化时，会发生什么，（后面很快就会讨论到这个问题）。简而言之，在对象被解序列化且对象的超类为不可序列化的情况下，那么其超类的构造器就会运行，从而创建出那种类型的一个对象来。在没有让某个类成为不可序列化类的适当理由的情况下，那么构造一个可序列化的子类，将是一种良好的做法（In a nutshell, when an object is deserialized and its superclass is not serializable, the superclass constructor will run just as though a new object of that type were bebing created. If there's no decent reason for a class to not be serializable, make a serializable subclass might be a good solution）。</p>
</blockquote>
<ul>
<li><strong>噢！我是不是发现了了不起的东西......只要使某个变量成为“瞬态（<code>transient</code>）”，就意味着在序列化过程中该变量的值被跳过。那么这个瞬态变量究竟发生了什么？这里通过将不可序列化实例变量构造为瞬态变量的方式，解决了实例变量不可序列化问题，然而在将其所属对象复活时，难道就不再需要那个瞬态变量了吗？也就是说，难道整个序列化操作的目的，不就是保留对象的状态吗</strong>？</li>
</ul>
<blockquote>
<p>是的，这确实是个问题，不过幸运的是，有办法解决这个问题。在对某个对象进行序列化操作时，不论瞬态引用实例变量在保存时的值为何，他们都将将恢复到 <code>null</code>。这就意味着连接到那个特定实例变量的整个对象图面，都不会被保存。显然，这样处理会有坏处，因为可能需要那个变量为非空值（Yes, this is an issue, but fortunately there's a solution. If you serialize an object, a transient reference instance variable will be brought back as <code>null</code>, regardless of the value it had at the time it was saved. That means the entire object graph connected to that particular instance variable won't be saved. This could be bad, obviously, because you probably need a <code>non-null</code> value for that variable）。</p>
<p>这个时候就有两个选项：</p>
<ol>
<li>
<p>在将对象恢复过来时，将那个 <code>null</code> 的实例变量，重新初始化回某种默认状态。在所解序列化的对象不依赖特定值的那个瞬态变量时，这种做法是可行的。也就是比如对于<code>Dog</code>对象，带有一个 <code>Collar</code> 的属性，就比较重要，而或许所有的 <code>Collar</code> 对象都是同样的，那么在给到所有复活过来的 <code>Dog</code> 一个全新的 <code>Collar</code>，就无关紧要；没有人会知道其中的差别（When the object is brought back, reinitialize that <code>null</code> instance variable back to some default state. This works if your deseralized object isn't dependent on a particular value for that transient variable. In other words, it might be important that the <code>Dog</code> have a <code>Collar</code>, but perhaps all <code>Collar</code> objects are the same so it doesn't matter if you give the resurrected <code>Dog</code> a brand new <code>Collar</code>; nobody will know the difference）。</p>
</li>
<li>
<p>在瞬态变量的取值确实至关重要时（比如每个 <code>Dog</code> 对象的瞬态变量 <code>Collar</code> 的颜色与式样都不相同），那么就需要对 <code>Collar</code> 的关键属性值进行保存，并在复活 <code>Dog</code> 对象时，使用这些关键属性值来再造一个与原先一致的全新 <code>Collar</code> 对象出来。</p>
</li>
</ol>
</blockquote>
<ul>
<li><strong>若对象图面中的两个对象引用变量，指向了相同对象，这个时候会怎样呢？比如说，在 <code>Kennel</code> 中有两个不同的 <code>Cat</code> 对象引用变量，但这两个<code>Cat</code>引用变量都是同一具体对象的引用。那么那个具体<code>Cat</code>对象会被保存两次吗？我倒希望不会</strong>。 </li>
</ul>
<blockquote>
<p>非常棒的问题！Java的序列化特性是足够聪明的，可以了解到图面中那两个对象是同样的。在图面中有两个同样对象时，那么就只有其中一个会被保存，而在解序列化过程中，所有到那个对象引用，都会被恢复出来。</p>
</blockquote>
<h2 id="解序列化恢复对象"><a class="header" href="#解序列化恢复对象">解序列化：恢复对象</a></h2>
<p><strong>Deserialization: restoring an object</strong></p>
<p><img src="images/Ch14_10.png" alt="序列化对象与解序列化对象" /></p>
<p><em>图 10 - 序列化对象与解序列化对象</em></p>
<p>给对象进行序列化的关键，就是在往后某一天，与不同JVM的“运行”里（甚至在不同于对象被序列化时所运行的同一JVM里），可以把对象恢复到其原本状态。解序列化与序列化十分相像，只是过程相反。</p>
<ol>
<li>
<p><strong>构造一个 <code>FileInputStream</code></strong></p>
<pre><code class="language-java">// 构造一个 FileInputStream 对象。这里的 FileInputStream 就
// 知道怎样去连接上要给既有的文件。
//
// 在文件 &quot;MyGame.ser&quot; 不存在时，将得到一个异常。
FileInputStream fileStream = new FileInputStream(&quot;MyGame.ser&quot;);
</code></pre>
</li>
<li>
<p><strong>构造一个 <code>ObjectInputStream</code></strong></p>
<pre><code class="language-java">// ObjectInputStream 允许读取对象，但他无法直接连接到某个
// 文件。他需要被链接到一个连接性流，这个示例中就是链接到
// 的一个 FileInputStream。
ObjectInputStream os = new ObjectInputStream(fileStream)
</code></pre>
</li>
<li>
<p><strong>读取那些对象</strong></p>
<pre><code class="language-java">// 在每次写下 readObject() 方法时，就获得了流中的下一个
// 对象。因此将以这些对象被写入的同样顺序，把这些对象读取
// 回来。若尝试读取多于写入的对象时，就会得到一个大大的异常。
Object one = os.readObject();
Object two = os.readObject();
Object three = os.readObject();
</code></pre>
</li>
<li>
<p><strong>对读取到的这些对象，进行类型强制转换</strong></p>
<pre><code class="language-java">// readObject() 方法的返回值是类型 Object 的（就跟
// ArrayList那里的情况一样），因此就必须将其强制
// 转换回所知的真实类型。
GameCharacter elf = (GameCharacter) one;
GameCharacter troll = (GameCharacter) two;
GameCharacter magician = (GameCharacter) three;
</code></pre>
</li>
<li>
<p><strong>关闭 <code>ObjectInputStream</code></strong></p>
<pre><code class="language-java">// 关闭了顶部的流也就关闭了其下的那些流，因此 FileInputStream
// （以及那个文件）就会自动关闭。
os.close();
</code></pre>
</li>
</ol>
<h3 id="解序列化期间发生了什么"><a class="header" href="#解序列化期间发生了什么">解序列化期间发生了什么？</a></h3>
<p><strong>What happens during deserialization</strong>?</p>
<p>在对象被解序列化时，JVM尝试通过在内存堆上构造一个新的、与对象在被序列化时有着同样状态的对象，来把对象复活过来。当然，这是排除了那些瞬态变量的，那些瞬态变量要么以<code>null</code>值（对于那些对象的引用变量）再现，要么以默认原生值再现。</p>
<p><img src="images/Ch14_11.png" alt="对象解序列化的过程" /></p>
<p><em>图 11 - 对象解序列化的过程</em></p>
<ol>
<li>
<p>从流 <strong>读取到</strong> 对象；</p>
</li>
<li>
<p>JVM推断出对象的 <strong>类类型</strong>（通过序列化的对象中存储的信息，The JVM determines (through info stored with the serialized object) the object's <strong>class type</strong>）；</p>
</li>
<li>
<p>JVM 尝试 <strong>找到并加载</strong> 该对象的 <strong>类</strong>。若 JVM 无法找到并/或加载该类，那么 JVM 就会抛出一个异常，同时解序列化宣告失败（The JVM attempts to <strong>find and load</strong> the object's <strong>class</strong>. If the JVM can't find and/or load the class, the JVM throws an exception and the deserialization fails）；</p>
</li>
<li>
<p>在内存堆上，一个新的对象被分配到空间，但 <strong>被序列化对象的构造器并 <em>不会</em> 运行</strong>！显然，若该构造器运行，就会把那个对象的状态，恢复到其原本的“新”状态，不过这并不是这里所想要的。这里要的时对象被恢复到他被序列化时所具有的状态，而不是他最开始被创建出时的状态（A new object is given space on the heap, but the <strong>serialized object's constructor doess NOT run</strong>! Obviously, if the constructor ran, it would restore the state of the object back to its original 'new' state, and that's not what we want. We want the object to be restored to the state it had <em>when it was serialized</em>, not when it was first created）;</p>
</li>
<li>
<p>若该对象在其继承树往上的某处，有着一个不可序列化类，那么随着这个不可序列化类之上的其他全部构造器的运行（即使这些往上的类是可序列化的）， <strong>那个不可序列化类的构造器也将运行起来</strong>。一旦构造器链式运行起来，就无法停止了，这就意味着从第一个不可序列化类开始的所有超类，都会重新初始化出他们的状态（If the object has a non-serializable class somewhere up its inheritance tree, the <strong>constructor for that non-serializable class will runn</strong> along with any constructors above that(even if they're serializable). Once the constructor chaining begins, you can't stop it, which means all superclasses, beginning with the first non-serializable one, will reinitialize their state）;</p>
</li>
<li>
<p>对象的 <strong>那些实例变量，都被赋予到来自序列化状态时的值</strong>。那些瞬态变量，被赋予对象引用变量的默认值 <code>null</code>，以及原生类型下相应的默认值（<code>0</code>、<code>false</code>等等）。</p>
</li>
</ol>
<h2 id="答疑-1"><a class="header" href="#答疑-1">答疑</a></h2>
<ul>
<li><strong>为何类没有作为对象的一部分，被保存起来？那样的话，就不存在类不会被找到的问题了</strong>。</li>
</ul>
<blockquote>
<p>确实，Java/JVM 的设计者们原本可以让序列化特性以那种方式运作。不过那样会造成巨大的浪费和开销。相比于运用序列化特性，将对象写到本地硬盘上的某个文件这种不是那么拮据的操作，那么通过序列化特性而通过网络来发送对象，就会困难得多。若把类绑定到各个被序列化（可传送）的对象，那么对带宽的要求就要比现在大得多（Sure, they could have made serialization work that way. But what a tremendous waste and overhead. And while it might not be such a hardship when you're using serialization is also used to send objects over a network connection. If a class was bundled with each serialized (shippable) object, bandwidth would become a much larger problem than it already is）。</p>
<p>然而对于那些被序列化来透过网络传输的对象，实际上有着一种，可将此种序列化对象 “盖戳上” 一个，表示在何处可以找到他的类的URL的机制。这个机制在 Java 的远程方法调用中有运用到，从而可以将序列化对象，作为方法参数的一部分进行传送，这个时候如果接收到的调用的JVM没有这个类，那么JVM就可以使用该URL，来从网络获取到这个类并进行加载，此过程全部是自动进行的。（在第 17 章将讨论到RMI，For objects serialized to ship over a network, though, there actually is a mechanism where the serialized object can be 'stamped' with a URL for where its class can be found. This is used in Java's Remote Method Invocation(RMI) so that you can send a serialized object as part of, say, a method argument, and if the JVM receiving the call doesn't have the class, it can use the URL to fetch the class from the network and load it, all automatically. (We'll talk about RMI in chapter 17.)）</p>
</blockquote>
<ul>
<li><strong>那些静态变量呢？他们会被序列化吗</strong>？</li>
</ul>
<blockquote>
<p>不会。请记住，静态就表示“每个类一个”，而不是“每个对象一个”。静态变量不被保存，且在某个对象被解序列化时，该对象的类 <em>当前</em> 有什么静态变量，那么该对象就会有什么静态变量。谨记：不要构造那些对动态改变的静态变量有依赖的可序列化对象！那样的话在恢复出对象时，就会出现与原先不一致的情况（Nope. Remember, static means &quot;one per class&quot; not &quot;one per object&quot;. Static variables are not saved, and when an object is deserialized, it will have whatever static variable its calss <em>currently</em> has. The moral: don't make serializable objects dependent on a dynamically-changing static variable! It might not be the same when the object comes back）。</p>
</blockquote>
<h2 id="游戏角色的保存与恢复"><a class="header" href="#游戏角色的保存与恢复">游戏角色的保存与恢复</a></h2>
<p><strong>Saving and restoring the game characters</strong></p>
<pre><code class="language-java">
package com.xfoss.learningJava;

import java.io.*;
import com.xfoss.Utils.*;

public class GameSaverTest {
    public static void main (String[] args) {
        // 构造一些角色......
        GameCharacter one = new GameCharacter(50, &quot;Elf&quot;, new String[] {&quot;bow&quot;, &quot;sword&quot;, &quot;dust&quot;});
        GameCharacter two = new GameCharacter(200, &quot;Troll&quot;, new String[] {&quot;bare hands&quot;, &quot;big ax&quot;});
        GameCharacter three = new GameCharacter(120, &quot;Magician&quot;, new String[] {&quot;spells&quot;, &quot;invisibility&quot;});

        XPlatformThings th = new XPlatformThings();
        String dataDir = th.getWorkingDir(&quot;learningJava&quot;);

        File dir = new File(dataDir);
        if(!dir.exists()) dir.mkdirs();
        
        String serFile = String.format(&quot;%s/GameCharacter.ser&quot;, dataDir);

        // 设想对这些角色进行操作的代码，可能改变这些角色的状态
        try {
            ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(serFile));
            os.writeObject(one);
            os.writeObject(two);
            os.writeObject(three);
            os.close();
        } catch (IOException ex) {ex.printStackTrace();}

        // 这里把这些角色设置为 null, 这样就无法在内存堆上访问到这些对象了
        one = null;
        two = null;
        three = null;

        try {
            // 现在从文件把这些角色读取回来......
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(serFile));
            GameCharacter oneRestore = (GameCharacter) is.readObject();
            GameCharacter twoRestore = (GameCharacter) is.readObject();
            GameCharacter threeRestore = (GameCharacter) is.readObject();
            is.close();

            // 检查一下这样的保存与读取是否可行。
            System.out.format(&quot;One's type: %s\n&quot;, oneRestore.getType());
            System.out.format(&quot;Two's type: %s\n&quot;, twoRestore.getType());
            System.out.format(&quot;Three's type: %s\n&quot;, threeRestore.getType());
        } catch (Exception ex) {ex.printStackTrace();}
    }
}
</code></pre>
<p><img src="images/Ch14_12.png" alt="对象序列化实例运行效果" /></p>
<p><em>图 12 - 对象序列化实例运行效果</em></p>
<h3 id="类-gamecharacter"><a class="header" href="#类-gamecharacter">类 <code>GameCharacter</code></a></h3>
<pre><code class="language-java">// 这是一个简单的仅用于测试序列化操作的类，同时这里也并没有一个
// 真正的游戏，不过实现游戏的过程，可以自己去完成。
package com.xfoss.learningJava;

import java.io.*;

public class GameCharacter implements Serializable {
    int power;
    String type;
    String [] weapons;

    public GameCharacter (int p, String t, String [] w) {
        power = p;
        type = t;
        weapons = w;
    }

    public int getPower () {
        return power;
    }

    public String getType () {
        return type;
    }

    public String getWeapons () {
        String weaponList = &quot;&quot;;

        for (int i = 0; i &lt; weapons.length; i++) {
            String.format(&quot;%s %s&quot;, weaponList, weapons[i]);
        }

        return weaponList;
    }
}
</code></pre>
<h2 id="对象序列化的重点"><a class="header" href="#对象序列化的重点">对象序列化的重点</a></h2>
<p><strong>Object Serialization, BULLET POINTS</strong></p>
<ul>
<li>通过将对象序列化，可保存对象的状态；</li>
<li>要序列化某个对象，就需要一个 <code>ObjectOutputStream</code>（来自 <code>java.io</code>包） 对象；</li>
<li>流要么是连接流，要么是链式流；</li>
<li>连接流可表示到源或目的地，典型的就是某个文件、网络套接字，或控制台，的一个连接；</li>
<li>链式流无法连接到源或目的地，而必须链接到连接（或其他）流；</li>
<li>要将对象序列化到文件，就要构造一个 <code>FileOutputStream</code> 对象，并将这个对象链接进入一个 <code>ObjectOutputStream</code>;</li>
<li>调用 <code>ObjectOutputStream</code> 对象上的 <em><code>writeObject(theObject)</code></em> 方法，来对这个 <code>theObject</code> 进行序列化。这里无需调用 <code>FileOutputStream</code> 上的那些方法；</li>
<li>对象要被序列化，就必须实现 <code>Serializable</code> 接口。在该类的超类实现了 <code>Serializable</code>，那么进行这个子类没有特别声明 <em>implements Serializable</em>，也自动成为可被序列化；</li>
<li>在对象被序列化时，他的整个对象图面都被序列化了。那就意味着被该序列化对象的那些实例变量所引用的全部对象，以及这些被引用对象所应用的全部对象......等等都被序列化了；</li>
<li>若图面中有任何对象不可被序列化，那么在运行时就会抛出异常，除非指向这个不可序列化对象的实例变量被跳过；</li>
<li>若希望序列化操作跳过某个变量，使用关键字 <code>transient</code> 标记这个变量即可。这个被 <code>transient</code> 关键字标记过的变量，将被恢复到 <code>null</code> （对于对象引用变量），或默认值（对于原生类型变量）；</li>
<li>在解序列化过程中，对象图面中所有对象的类，必须对JVM可用；</li>
<li>读取对象（使用 <code>readObject()</code> 方法）是以所读取的那些对象原先写入的顺序读出；</li>
<li><code>readObject()</code> 方法返回值类型为 <code>Object</code> 类型，因此解序列化出的对象，必须被强制转换（<code>cast</code>）到他们真实类型；</li>
<li>静态变量不会被序列化！将静态变量作为特定对象状态的一部分进行保存没有意义，因为那种类型的所有对象，都共享着仅仅这一个值 -- 就是类中的那个；</li>
</ul>
<h2 id="写入一个字符串到文本文件"><a class="header" href="#写入一个字符串到文本文件">写入一个字符串到文本文件</a></h2>
<p><strong>Writing a <code>String</code> to a <code>Text</code> File</strong></p>
<p>经由序列化特性保存对象，是在某个Java程序的不同运行之间，进行数据保存与恢复的最容易方式（Saving objects, through serialization, is the easiest way to save and restore data between runnings of a Java program）。不过有时候仍需要把数据保存到普通老式文本文件。设想有Java程序必须把数据，写入到某个其他（极有可能为非Java的）程序需要读取的简单文本文件。比如说，有这样一个Java编写的、获取用户输入到浏览器的表单数据的小服务程序（a servlet），并把这些表单数据，写入到一个其他程序也会加载到某个电子表单进而加以分析的文本文件。</p>
<p>写入文本数据（实际上是一个字符串），跟写入对象类似，只是写入的是一个字符串而不再是对象，还有使用的是 <code>FileWriter</code>而不是<code>FileOutputStream</code>（并且也不是链接到 <code>ObjectOutputStream</code>的）。</p>
<p><img src="images/Ch14_13.png" alt="以文本文件方式保存对象数据" /></p>
<p><em>图 13 - 以文本文件方式保存对象数据</em></p>
<p><strong>要写入序列化对象</strong>：</p>
<pre><code class="language-java">objectOutputStream.writeObject(someObject);
</code></pre>
<p><strong>而要写入一个字符串</strong>：</p>
<pre><code class="language-java">fileWriter.write(&quot;My first String to save&quot;);
</code></pre>
<pre><code class="language-java">// 这里需要 java.io 包来提供到 FileWriter 类
import java.io.*;

class WriteAFile {
    public static void main (String[] args) {
        // 所以 I/O 操作，都必须在一个 try/catch 代码块中。其中的
        // 全部操作都能抛出 IOException 异常！！
        try {
            // 如果这个 “Foo.txt” 文件不存在，FileWriter就会创建他。
            FileWriter writer = new FileWriter(&quot;Foo.txt&quot;);
            
            // write() 方法取的是一个字符串参数
            writer.write(&quot;hello foo!&quot;);

            // 在完成写入后要关闭这个 FileWriter 对象！
            writer.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
}
</code></pre>
<h2 id="文本文件示例e-flashcards"><a class="header" href="#文本文件示例e-flashcards">文本文件示例：<code>e-Flashcards</code></a></h2>
<p><strong>Text File Example: <code>e-Flashcards</code></strong></p>
<p>还记得上学时用过的那些学习卡片（flashcards）吗？那种卡片一面有个问题，背后就是问题的答案。虽然这些学习卡片对于掌握理解某些内容没有帮助，但用于简单操练和死记硬背，他们是无可比拟的。<em>尤其是在必须把某个事实刻入脑中的时候</em>。同时这样的卡牌，用于益智猜谜竞赛中也非常棒。</p>
<p><img src="images/Ch14_14.png" alt="老式3x5索引卡牌" /></p>
<p><em>图 14 - 老式3x5索引卡牌</em></p>
<p><strong>接下来就要构造以恶有三个类的电子版卡牌</strong>：</p>
<ol>
<li>
<p>类<code>QuizCardBuilder</code>，用于一套电子卡牌的创建及存储的一个简单创作工具；</p>
</li>
<li>
<p>类 <code>QuizCardPlayer</code>，一个可加载进一套电子卡牌，并给用户玩这套卡牌的回放引擎；</p>
</li>
<li>
<p>类<code>QuizCard</code>，一个表示卡牌数据的简单类。这里会贯穿卡牌构建器与卡牌播放器的代码，而把 <code>QuizCard</code>类留给读者自己取构造，使用下表：</p>
</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><b><code>QuizCard</code></b></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>QuizCard(q, a)</code></td></tr>
<tr><td style="text-align: left"><code>question</code> <br /> <code>answer</code></td></tr>
<tr><td style="text-align: left"><code>getQuestion()</code> <br /> <code>getAnswer()</code></td></tr>
</tbody></table>
</div>
<p><img src="images/Ch14_15.png" alt="QuizCardBuilder" /></p>
<p><em>图 15 - <code>QuizCardBuilder</code></em></p>
<p>有着带有用于把当前这套卡牌，保存到文本文件的 “保存” 选项的 “文件” 菜单。</p>
<p><img src="images/Ch14_16.png" alt="QuizCardPlayer" /></p>
<p><em>图 16 - <code>QuizCardPlayer</code></em></p>
<p>有着用于从文本文件加载一套卡牌的“加载”选项的“文件”菜单。</p>
<h3 id="quizcardbuilder-代码大纲"><a class="header" href="#quizcardbuilder-代码大纲"><code>QuizCardBuilder</code> （代码大纲）</a></h3>
<pre><code class="language-java">public class QuizCardBuilder {
    // 构建并显示GUI，包括事件收听者的构造与注册。
    public void go () {
        // GUI的构建及显示
    }

    // 内部类
    private class NextCardListener implements ActionListener {
        // 当用户点击 “下一卡片” 按钮时，触发这个事件处理
        // 方法；表示用户希望把那个卡片存储在清单中，并
        // 开始制作一张新卡片。
        public void actionPerformed (ActionEvent ev) {
            // 将当前卡牌添加到清单并清空那两个文本区
        }
    }

    // 内部类
    private class SaveMenuListener implements ActionListener {
        // 在用户选择了文件菜单中的 “保存” 菜单项时触发
        // 这个事件处理方法；表示用户希望以“套”的形式
        // （比如，“量子力学卡套（Quantum Mechanics Set）”，“好莱坞
        // 趣闻（Hollywood Trivia）”，“Java规则集”等等），保存当前
        // 清单中的全部卡片。
        public void actionPerformed (ActionEvent ev) {
            // 拉起一个文件对话框
            // 让用户命名并保存这套卡片
        }
    }

    // 内部类
    private class NewMenuListener implements ActionListener {
        // 在点选了文件菜单中的“新建”菜单项后触发这个事件处理
        // 方法；表示用户希望开始创建一套全新卡片（因此就要
        // 情况卡片清单及文本区）。
        public void actionPerformed (ActionEvent ev) {
            // 清空卡片清单，还要情况那两个文本区
        }
    }

    // 此方法被 SaveMenuListener 调用；完成具体的文件写入。
    private void saveFile(File file) {
        // 对卡片清单进行遍历，并把各个卡片，以可解析的方式（也就是
        // 在卡片各个部分之间有明确的间隔），写入到一个文本文件
    }
}
</code></pre>
<h3 id="quizcardbuilder-代码"><a class="header" href="#quizcardbuilder-代码"><code>QuizCardBuilder</code> 代码</a></h3>
<pre><code class="language-java">package com.xfoss.QuizCard;

import java.util.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.net.*;

public class QuizCardBuilder {
    private JTextArea question;
    private JTextArea answer;
    private ArrayList&lt;QuizCard&gt; cardList;
    private JFrame frame;

    public static void main (String[] args) {
        QuizCardBuilder builder = new QuizCardBuilder();
        builder.go();
    }

    private void go() {
        // 构建出 GUI
        // 
        // 这里全是 GUI 的代码。没有什么特别的，不过可能会
        // 看看这里的 MenuBar、Menu及 MenuItems 等代码。
        frame = new JFrame(&quot;测试卡构建器&quot;);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        URL icoURI = getClass().getResource(&quot;/images/flashcards.png&quot;);
        ImageIcon ico = new ImageIcon(icoURI);
        frame.setIconImage(ico.getImage());

        JPanel mainPanel = new JPanel();

        Font bigFont = new Font(&quot;sanserif&quot;, Font.BOLD, 24);

        question = new JTextArea(6, 20);
        question.setLineWrap(true);
        question.setWrapStyleWord(true);
        question.setFont(bigFont);

        JScrollPane qScroller = new JScrollPane(question);
        qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        answer = new JTextArea(6, 20);
        answer.setLineWrap(true);
        answer.setWrapStyleWord(true);
        answer.setFont(bigFont);

        JScrollPane aScroller = new JScrollPane(answer);
        aScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        aScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        JButton nextBtn = new JButton(&quot;下一卡片&quot;);
        nextBtn.addActionListener(new NextCardListener());

        cardList = new ArrayList&lt;QuizCard&gt; ();

        JLabel qLabel = new JLabel(&quot;问题：&quot;);
        JLabel aLabel = new JLabel(&quot;答案：&quot;);

        mainPanel.add(qLabel);
        mainPanel.add(qScroller);
        mainPanel.add(aLabel);
        mainPanel.add(aScroller);
        mainPanel.add(nextBtn);

        // 这里构造了一个菜单栏，一个文件菜单，随后把
        // &quot;新建&quot; 与 “保存” 菜单项放入到文件菜单。然后
        // 把这个菜单添加到菜单栏，并告诉视窗框使用这个
        // 菜单栏。菜单项可以发起 ActionEvent 事件。
        JMenuBar menuBar = new JMenuBar();
        JMenu fileMenu = new JMenu(&quot;文件（F）&quot;);

        JMenuItem newMenuItem = new JMenuItem(&quot;新建（N）&quot;);
        newMenuItem.addActionListener(new NewMenuItemListener());

        JMenuItem saveMenuItem = new JMenuItem(&quot;保存（S）&quot;);
        saveMenuItem.addActionListener(new SaveMenuItemListener());

        fileMenu.add(newMenuItem);
        fileMenu.add(saveMenuItem);

        menuBar.add(fileMenu);

        frame.setJMenuBar(menuBar);
        frame.getContentPane().add(BorderLayout.CENTER, mainPanel);
        frame.setSize(480, 640);
        frame.setVisible(true);
    }

    private class NextCardListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            if(question.getText().length() &gt; 0 &amp;&amp; answer.getText().length() &gt; 0) {
                QuizCard card = new QuizCard(question.getText(), answer.getText());
                cardList.add(card);
                clearCard();
            }

            question.requestFocus();
        }
    }

    private class NewMenuItemListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            cardList.clear();
            clearCard();
        }
    }

    private class SaveMenuItemListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            QuizCard card = new QuizCard(question.getText(), answer.getText());
            cardList.add(card);

            // 这里拉起（bring up） 一个文件对话框并等待用户选择对话框
            // 中的 “保存”按钮。文件对话框的全部导航及文件选择工作等，都是
            // 由 JFileChooser 替咱们完成的！就这么容易。
            JFileChooser fileSave = new JFileChooser();
            fileSave.showSaveDialog(frame);
            saveFile(fileSave.getSelectedFile());
        }
    }

    private void clearCard () {
        question.setText(&quot;&quot;);
        answer.setText(&quot;&quot;);
        question.requestFocus();
    }

    // 正是这个方法，完成文件写入（由 SaveMenuListener 的事件处理器调用）。
    // 这里的参数就是那个用户要保存的 'File' 对象。在后面就会讨论到类 File。
    private void saveFile (File f) {
        try {
            // 这里把一个 BufferedWriter 对象，链接到一个新创建的 FileWriter
            // 对象上，以令到写入更加高效（稍后不久就会讨论到这个问题）。
            BufferedWriter writer = new BufferedWriter(new FileWriter(f));

            // 对这个 QuizCard 的 ArrayList 进行遍历，并将这些卡片写出来，每行
            // 一张卡片，其中的问题与答案之间用 “/” 分隔开，之后每行在加上
            // 一个另起一行字符（“\n”）
            for (QuizCard c:cardList) {
                if(c.getQuestion().length() &gt; 0 &amp;&amp; c.getAnswer().length() &gt; 0)
                    writer.write(String.format(&quot;%s/%s\n&quot;, c.getQuestion(), c.getAnswer()));
            }

            writer.close();
        } catch (IOException ex) {
            System.out.println(&quot;无法将卡片清单 cardList 写出&quot;);
            ex.printStackTrace();
        }
    }
}

class QuizCard {
    private String question;
    private String answer;

    public QuizCard(String q, String a) {
        question = q;
        answer = a;
    }

    public String getQuestion () {return question;}
    public String getAnswer() {return answer;}
}
</code></pre>
<p><img src="images/Ch14_17.png" alt="QuizCardBuilder运行效果" /></p>
<p><em>图 17 - <code>QuizCardBuilder</code>运行效果</em></p>
<h2 id="类-javaiofile"><a class="header" href="#类-javaiofile">类 <code>java.io.File</code></a></h2>
<p>类 <code>java.io.File</code> <em>代表（represents）</em> 磁盘上的某个文件，但并不具体表示那个文件的 <em>内容（contents）</em>。不明白？把 <code>File</code> 对象当作某个文件的 <em>路径名称（pathname）</em> （或者甚至某个 <em>目录（directory）</em>），而非那个真实文件本身就好。类 <code>File</code> 本身就不具有比如读取和写入这样的方法。使用 <code>File</code> 对象来表示磁盘文件，与仅使用一个字符串来表示相比，一个非常有用的地方，就在于这样做是更加安全的方式。那些构造器接收字符串文件名的大多数类（诸如 <code>FileWriter</code> 或 <code>FileInputStream</code>），同时也能接收 <code>File</code> 对象。可构建出一个 <code>File</code> 对象，而通过这个对象，完成诸如路径有效性验证等检查，并于随后把这个文件对象，提供给 <code>FileWriter</code> 或  <code>FileInputStream</code>。</p>
<blockquote>
<p><strong><code>File</code> 对象表示的，是磁盘上文件或目录的名字及路径，比如</strong>：</p>
<p><code>/User/Kathy/Data/GameFile.txt</code></p>
<p><strong>但 <code>File</code> 对象并不代表文件 <em>中的</em> 数据，也并未给到对文件中数据的访问</strong>！</p>
</blockquote>
<p><img src="images/Ch14_18.png" alt="File对象与磁盘文件及文件内部数据" /></p>
<p><em>图 18 - <code>File</code>对象与磁盘文件及文件内部数据</em></p>
<h3 id="使用-file-对象可以完成的一些事情"><a class="header" href="#使用-file-对象可以完成的一些事情">使用 <code>File</code> 对象可以完成的一些事情</a></h3>
<ol>
<li>
<p><strong>构造一个表示既有文件的 <code>File</code> 对象</strong></p>
<pre><code class="language-java">File f = new File(&quot;MyCode.txt&quot;);
</code></pre>
</li>
<li>
<p><strong>新建一个目录</strong></p>
<pre><code class="language-java">File dir = new File(&quot;Chapter7&quot;);
dir.mkdir();
</code></pre>
</li>
<li>
<p><strong>列出某个目录的内容</strong></p>
<pre><code class="language-java">if (dir.isDirectory()) {
    String[] dirContents = dir.list();
    for (int i = 0; i &lt; dirContents.length; i++) {
        System.out.println(dirContents[i]);
    }
}
</code></pre>
</li>
<li>
<p><strong>获取文件或目录的绝对路径</strong></p>
<pre><code class="language-java">System.out.println(dir.getAbsolutePath());
</code></pre>
</li>
<li>
<p><strong>删除某个文件或目录（删除成功时返回 <code>true</code>）</strong></p>
<pre><code class="language-java">boolean isDeleted = f.delete();
</code></pre>
</li>
</ol>
<h2 id="缓存之美"><a class="header" href="#缓存之美">缓存之美</a></h2>
<p><strong>The beauty of buffers</strong></p>
<p><strong>没有缓存器，就如同逛超市没有购物推车。就不得不把买的东西一件件地搬到车上，一次拿一个汤罐头或一卷厕纸</strong>。</p>
<p><img src="images/Ch14_19.png" alt="缓存器与购物推车" /></p>
<p><em>图 19 - 缓存器与购物推车</em></p>
<p><img src="images/Ch14_20.png" alt="缓存器在写入文件中的作用" /></p>
<p><em>图 20 - 缓存器在写入文件中的作用</em></p>
<pre><code class="language-java">// 请注意这里甚至不需要保留一个到FileWriter 对象的引用（注：即并没有
// 为这个对象设置一个变量）。这里只关心这个 BufferedWriter，因为正是
// 要调用这个对象上的方法，且在关闭这个 BufferedWriter 时，这个对象
// 同时会照顾到该数据写入链条上的其余部分。
BufferedWriter writer = new BufferedWriter(new FileWriter(aFile));
</code></pre>
<p>缓存酷的地方，在于比起不使用缓存，他们的效率高很多。可通过调用 <code>FileWriter</code>对象上的 <code>write(someString)</code>，单独使用 <code>FileWriter</code> 来写入某个文件，不过 <code>FileWriter</code> 是每次一个地写入传递给他的东西。而相比于操作内存中的数据，每次去访问磁盘就是件十分耗时的事情，由于这个原因，直接使用 <code>FileWriter</code> 每次一个地写入，就带来我们所不希望的开销。而通过在 <code>FileWriter</code> 上连接一个 <code>BufferedWriter</code>时，这个 <code>BufferedWriter</code>就会在缓存放满之前，把要写入的东西暂时留存起来。<em>只有在缓存充满时，才会告诉 <code>FileWriter</code> 往磁盘上的文件写入</em>。</p>
<p>若希望在缓存尚未充满前就要发送其中的数据，可是可以的。<em><strong>只需刷新缓存即可（Just flush it）</strong></em>。调用 <code>writer.flush()</code> 就是说，“发送缓存中的内容，立即！”</p>
<h2 id="从文本文件读取数据"><a class="header" href="#从文本文件读取数据">从文本文件读取数据</a></h2>
<p><strong>Reading from a Text File</strong></p>
<p>从文件读取文本是简单的，不过这里要使用一个 <code>File</code> 对象来表示那个文件，使用一个 <code>FileReader</code> 来完成实际读取，还要使用一个<code>BufferedReader</code>，来令到读取更具效率。</p>
<p>读取是通过在一个 <em><code>while</code></em> 的循环中，去读取那些行进行，在 <code>readLine()</code> 返回结果为 <code>null</code> 时，终止这个循环。这也正是数据读取（针对几乎所有非序列化对象的那些数据）最常见的方式：在 <code>while</code> 循环（实际上是<code>while</code> 循环的 <em>条件测试</em>）中，进行数据读取，在没有东西要读取时循环终止（因为不论使用何种读取方法，其结果都是 <code>null</code>，故直到已经读取完毕）。</p>
<p><img src="images/Ch14_21.png" alt="一个有着两行文本的文件" /></p>
<p><em>图 21 - 一个有着两行文本的文件</em></p>
<pre><code class="language-java">package com.xfoss.learningJava;

import java.io.*;
import java.util.Objects;
import com.xfoss.Utils.*;

public class ReadFile {
    public static void main (String[] args) {
        XPlatformThings xpt = new XPlatformThings();
        String wd = xpt.getWorkingDir(&quot;learningJava&quot;);

        try {
            File f = new File(String.format(&quot;%s/data/MyText.txt&quot;, wd));
            // 这里的FileReader，时用于字符的、连接到某个文本文件的连接流
            FileReader fReader = new FileReader(f);

            // 这里将这个 FileReader 连接到一个 BufferedReader，目的是
            // 更高效的读取数据。这样就只会在缓存为空时（因为这个程序要
            // 读取文件中的全部数据），才回到文件去读取。
            BufferedReader reader = new BufferedReader(fReader);

            // 构造一个字符串变量，用来在每次读取行时，留存住这个行
            String line = null;
            // 这里讲了 “读取一行文本，并将其赋值给这个字符串变量'line'.
            // 在那个变量不为 'null'时（由于在这之前还有东西可读）把刚
            // 读取到的那行打印出来。”
            //
            // 或者以另外一种讲法，“在仍有文本行可读取的情况下，对这些文本
            // 行加以读取并打印出来。”
            while(!Objects.isNull(line = reader.readLine())) {
                System.out.println(line);
            }
            reader.close();
        } catch (Exception ex) {}
    }
}
</code></pre>
<p><img src="images/Ch14_22.png" alt="一个有三行文本的文本文件" /></p>
<p><em>图 22 - 一个有三行文本的文本文件</em></p>
<p><img src="images/Ch14_23.png" alt="ReadFile的输出" /></p>
<p><em>图 23 - <code>ReadFile</code>的输出</em></p>
<h2 id="quizcardplayer-代码大纲"><a class="header" href="#quizcardplayer-代码大纲"><code>QuizCardPlayer</code> （代码大纲）</a></h2>
<p><strong><code>QuizCardPlayer</code> (code outline)</strong></p>
<pre><code class="language-java">public class QuizCardPlayer {
    public void go () {
        // 构建并显示 GUI
    }

    class NextCardListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            // 若这是个问题，那么就展示其答案，否则就显示下一问题
            // 对一个用于表示是在查看问题还是答案的标志标量进行设置
        }
    }

    class OpenMenuListener implements Action Listener {
        public void actionPerformed (ActionEvent ev) {
            // 拉起一个文件对话框（bring up a file dialog box）
            // 让用户导航到某个卡片集，并选中要打开的卡片集
        }
    }

    private void loadFile(File file) {
        // 这里必须通过从文本文件读取一些卡片，然后构建出
        // 一个卡片的 ArrayList
        //
        // 此方法是从 OpenMenuListener 事件处理器中进行调用的，以一次
        // 读取一行的方式来读取文件，并让 makeCard() 方法来从读取到的行
        // 构造出新的卡片
        //
        // （文件中的一行，同时保存了问题与答案，问题与答案通过一个 '/'
        // 分隔开）
    }

    private void makeCard(String lineToParse) {
        // 由 loadFile() 方法调用，从文本文件拿到一行并
        // 将改行解析为两个片段 -- 问题与答案 -- 还要创建出一个
        // 新的 QuizCard 对象出来，然后把这个新的 QuizCard 对象添加
        // 到名为 CardList 的 ArrayList
    }
}
</code></pre>
<h2 id="quizcardplayer-代码"><a class="header" href="#quizcardplayer-代码"><code>QuizCardPlayer</code> 代码</a></h2>
<pre><code class="language-java">package com.xfoss.QuizCard;

import java.util.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.*;
import java.io.*;

public class QuizCardPlayer extends JFrame {

    private JTextArea display;
    private ArrayList&lt;QuizCard&gt; cardList;
    private QuizCard currentCard;
    private int currentCardIndex;
    private JButton nextBtn;
    private boolean isShowAnswer;

    public static void main (String[] args) {
        QuizCardPlayer player = new QuizCardPlayer();
    }

    // 这个构造函数，就相当于之前的方法 go(), 用来构建 GUI
    // 并省略了 main() 方法中的一个对 go() 的调用
    public QuizCardPlayer () {
        // 构建 GUI
        super(&quot;测试卡播放器&quot;);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JPanel mainPanel = new JPanel();
        Font bigFont = new Font(&quot;sanserif&quot;, Font.BOLD, 24);

        display = new JTextArea(10, 20);
        display.setFont(bigFont);
        display.setLineWrap(true);
        display.setEditable(false);

        JScrollPane qScroller = new JScrollPane(display);
        qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        nextBtn = new JButton(&quot;给出问题&quot;);
        nextBtn.addActionListener(new NextCardListener());
        nextBtn.setEnabled(false);

        mainPanel.add(qScroller);
        mainPanel.add(nextBtn);

        JMenuBar menuBar = new JMenuBar ();

        JMenu fileMenu = new JMenu(&quot;文件（F）&quot;);
        fileMenu.setMnemonic(KeyEvent.VK_F);

        JMenuItem loadMenuItem = new JMenuItem(&quot;加载卡片集（L）&quot;);
        loadMenuItem.setMnemonic(KeyEvent.VK_L);
        loadMenuItem.addActionListener(new OpenMenuListener());

        JMenuItem quitMenuItem = new JMenuItem(&quot;退出（Q）&quot;);
        quitMenuItem.addActionListener(new QuitMenuItemListener());
        quitMenuItem.setMnemonic(KeyEvent.VK_Q);

        fileMenu.add(loadMenuItem);
        fileMenu.add(quitMenuItem);
        menuBar.add(fileMenu);

        setJMenuBar(menuBar);
        getContentPane().add(BorderLayout.CENTER, mainPanel);
        setSize(640, 500);
        setVisible(true);
    }

    private class QuitMenuItemListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            dispose();
            System.exit(0);
        }
    }

    private class NextCardListener implements ActionListener {
        // 这里对 isShowAnswer 这个布尔值标志进行检查，从而获悉
        // 用户当前所查看的，究竟是问题还是答案，并根据具体情况
        // 来进行适当的操作。
        public void actionPerformed (ActionEvent ev) {
            if (isShowAnswer) {
                display.setText(currentCard.getAnswer());
                nextBtn.setText(&quot;下一卡片&quot;);
                isShowAnswer = false;
            } else {
                if (currentCardIndex &lt; cardList.size()) showNextCard();
                else {
                    display.setText(&quot;这已是最后一张卡片。&quot;);
                    nextBtn.setEnabled(false);
                }
            }
        }
    }

    private class OpenMenuListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            // 拉起文件对话框并让用户进行导航，从而选择要打开的文件。
            JFileChooser fileOpen = new JFileChooser();
            fileOpen.showOpenDialog(QuizCardPlayer.this);
            loadFile(fileOpen.getSelectedFile());
        }
    }

    private void loadFile(File file) {
        cardList = new ArrayList&lt;QuizCard&gt; ();

        try {
            // 构造一个链接到新的 FileReader 对象的 BufferedReader 对象
            // 把用户从“打开文件”对话框中选择的文件对象，交给这里的
            // FileReader 对象。
            //
            // 这里一次读取一行，然后把读到的行传递给对其进行解析
            // 并将其转换到真正 QuizCard 对象、然后把这个对象添加到
            // ArrayList 的 makeCard() 方法。
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String line = null;
            while ((line = reader.readLine()) != null) {
                makeCard(line);
            }
            nextBtn.setEnabled(true);
            reader.close();
        } catch (Exception ex) {
            System.out.println(&quot;无法读取卡片集文件&quot;);
            ex.printStackTrace();
        }
    }

    private void makeCard (String lineToParse) {
        // 每行文本对应单个的卡片，不过这里必须把问题与答案
        // 分别作为单独部分解析出来。这里使用了字符串 String 
        // 的 split() 方法来把文本行拆分成两个分词（tokens, 
        // 以恶用作问题，一个用作答案）。后面就会介绍到这个 split()
        // 方法。
        String [] result = lineToParse.split(&quot;/&quot;);
        QuizCard card = new QuizCard(result[0], result[1]);
        cardList.add(card);
        System.out.println(&quot;构造好了一个卡片&quot;);
    }

    private void showNextCard () {
        currentCard = cardList.get(currentCardIndex);
        currentCardIndex++;
        display.setText(currentCard.getQuestion());
        nextBtn.setText(&quot;揭开答案&quot;);
        isShowAnswer = true;
    }
}
</code></pre>
<h3 id="使用-string-的-split-方法来解析"><a class="header" href="#使用-string-的-split-方法来解析">使用 <code>String</code> 的 <code>split()</code> 方法来解析</a></h3>
<p><strong>Parsing wih <code>String</code> <code>split()</code></strong></p>
<p><img src="images/Ch14_24.png" alt="以文本文件方式保存对象数据" /></p>
<p><em>图 24 - 以文本文件方式保存对象数据</em></p>
<p><strong>怎样区分出问题和答案</strong>？</p>
<p><strong>How do you separate he question and answer</strong>?</p>
<p>在读取这个文件时，问题与答案是挤在一行里头的，以一个正斜杠（<code>/</code>）分隔开（由于这正是在 <code>QuizCodeBuilder</code> 代码中写到文件的方式）。</p>
<p><strong><code>String</code> 的静态方法 <code>split()</code> 实现了将字符串拆开为多个片段</strong>。</p>
<p><strong><code>String</code> <code>split()</code> lets you break a String into pieces</strong>.</p>
<p>方法 <code>split()</code> 是指，“给我一个分隔符，我就会为你拆分出这个字符串的所有片段，并把他们放到一个字符串数组中。”</p>
<p><img src="images/Ch14_25.png" alt="String类的静态方法 split()" /></p>
<p><em>图 25 - <code>String</code>类的静态方法 <code>split()</code></em></p>
<pre><code class="language-java">// 在 QuizCardPlayer 应用中，这就是从文件中读取到单行
// 文本时看起来的样子
String toTest = &quot;What i blue + yellow?/green&quot;;

// split() 方法取得这个正斜杠 '/' ，并使用这个正斜杠
// 来将这个字符串拆分成两个片段（在此示例中）。（请
// 注意：split() 要远比这里的用法强大。在与
// 过滤器、通配符等工具结合使用时，可以完成极为复杂的解析。）
String[] result = toTest.split(&quot;/&quot;);

// 对这个字符串字符进行遍历，并把各个分词（token，片段）打印
// 出来。在此示例中，就只有两个分词：“What is blue + yellow?”
// 以及 “green”。
for (String token:result) {
    System.out.println(token);
}
</code></pre>
<h2 id="答疑-2"><a class="header" href="#答疑-2">答疑</a></h2>
<ul>
<li><strong>好吧，我看了看你 API 文档，发现在 <code>java.io</code> 包中差不多有 5 百万个类。到底该怎样知道要用哪些类呢</strong>？</li>
</ul>
<blockquote>
<p><code>I/O</code> API 用到了模块化的 ‘链接’ 概念，因此就可以对这些连接性流与链式流（也叫做“过滤器”流），以相当宽泛的组合方式进行调用，从而获取到想要的几乎全部东西（The <code>I/O</code> API uses the modular 'chaining' concept so that you can hook together connection streams and chain streams(also called 'filter' streams) in a wide range of combinations to get just about anything you could want）。</p>
<p>这些处理链，不必仅止于两层；可在一个链式流上调用多个链式流，来获取到所需的恰当数量流程（The chains don't have to stop at two levels; you can hook multiple chain streams to one another to get just the right amount of processing you need）。</p>
<p>不过多数时候，都仅会用到上面这样的小而好用的类。比如在写入文本文件时，<code>BufferedReader</code>与<code>BufferedWriter</code>（分别链接到 <code>FileReader</code>与 <code>FileWriter</code>）差不多就是所需的全部了。而在写入序列化对象时，就可以使用<code>ObjectOutputStream</code>与<code>ObjectInputStream</code>（分别链接到 <code>FileInputStream</code> 与 <code>FileOutputStream</code>）。</p>
<p>也就是说，今后要使用 Java <code>I/O</code> 来完成的操作，90% 都只会涉及到上面讲的两种情况。</p>
</blockquote>
<ul>
<li><strong>请讲讲Java 1.4 中引入的新 <code>I/O</code> 包 <code>nio</code> 中那些类的情况吧</strong>（<strong>What about the new <code>I/O</code> <code>nio</code> class added in <code>1.4</code></strong>）</li>
</ul>
<blockquote>
<p><code>java.nio</code> 包中的类，带来了大大的性能提升，并更好地利用了程序运行所在机器的原生优势（The <code>java.nio</code> classes bring a big performance improvement and take greater advantage of native capatibilities of the maching your program is running on）。<code>nio</code> 包的关键特性之一，就是让Java程序员可以对缓存进行直接控制。值得一提另一项新特性，则是非阻塞 <code>I/O</code> （non-blocking <code>I/O</code>），指的是所编写的 <code>I/O</code> 代码，在没有要读取或写入的数据时，不会只是在那里发呆等候。<code>nio</code> 中的一些既有类（包括 <code>FileInputStream</code> 与 <code>FileOutputStream</code>），也都受益于一些新特性，等着我们去运用。不过这些 <code>nio</code> 类使用起来要复杂一些，所以除非 <em>真的</em> 需要这些新特性，那么就一直使用这里用到的简单版本就好。另外，在不小心的情况下，<code>nio</code> 还会导致性能上的 <em>损失</em>。对于日常需要完成的 <code>I/O</code> 操作，这里用到的非 <code>nio</code> 的 <code>I/O</code>，大约已经可以满足 90% 了，尤其是刚开始使用 Java 编程语言的时候。</p>
<p>然而可以通过使用 <code>FileInputStream</code> ，并经由其 <code>getChannel()</code> 方法（是在Java 1.4 版本中添加到 <code>FileInputStream</code> 类的），去访问他的 <em>通道（channel）</em> ，以此来让切换到 <code>nio</code> 的那些类更容易。</p>
</blockquote>
<hr />
<blockquote>
<p><em>Roses are first, violets are next</em>.</p>
</blockquote>
<blockquote>
<p><em><em><code>Readers</code></em> and <em><code>Writers</code> are only for <em>text</em></em></em>.</p>
</blockquote>
<h2 id="重点"><a class="header" href="#重点">重点</a></h2>
<ul>
<li>对于写文本文件，要以 <code>FileWriter</code> 连接性流开头；</li>
<li>为效率着想，要将 <code>FileWriter</code> 链接到 <code>BufferedWriter</code>；</li>
<li><code>File</code>对象表示在特定路径的文件，而不表示文件的具体内容；</li>
<li>有了<code>File</code>对象，就可以对目录进行创建、遍历及删除操作；</li>
<li>可使用字符串的文件名的那些流，大多数也可以使用<code>File</code>对象，同时<code>File</code>对象用起来更加安全；</li>
<li>要读取文本文件，就要以一个 <code>FileReader</code> 连接性流开头；</li>
<li>为效率着想，要将<code>FileReader</code>链接到 <code>BufferedReader</code>；</li>
<li>要解析文本文件，就要确保该文件是以某种识别出不同元素的方式写下来的（To parse a text file, you need to be sure the file is written with some way to recognize the different elements）。而常见的方法，则是使用某种字符来将那些单独片段分隔开来；</li>
<li>使用<code>String</code>类的<code>split()</code>方法，将字符串切分为多个单独分词。带有一个分隔符的字符串将有两个分词，分隔符的两侧各有一个。<em>分隔符本身不被算作是分词</em>。</li>
</ul>
<h2 id="版本id序列化的大问题"><a class="header" href="#版本id序列化的大问题">版本ID：序列化的大问题</a></h2>
<p><strong>Version ID: A Big Serialization Gotcha</strong></p>
<p>现在已经看到，Java中的 <code>I/O</code>实际上是相当简单的了，在一直使用最常见的连接/链式流时尤其如此。然而这里有个 <em>或许</em> 真的应该关注的问题。</p>
<h2 id="版本控制至关重要"><a class="header" href="#版本控制至关重要">版本控制至关重要！</a></h2>
<p><strong>Version Control is crucial</strong>!</p>
<p>在序列化某个对象时，为了随后的解序列化以及使用到这个对象，那么就必须要有对应的类。好吧，这是显然的。然而不那么显然的是，如果期间 <strong>修改了对象</strong>，会怎样呢？呀。设想在尝试恢复某个序列化的 <code>Dog</code> 对象时，有一个实例变量（非瞬态的）从双精度浮点数变成了字符串。这就极大地破坏了 Java 的类型安全这一痛点了（That violates Java's type-safe sensibilities in a Big Way）。然而这还不是唯一的可能会危害兼容性的做法。请思考下面这些：</p>
<p><img src="images/Ch14_26.png" alt="可序列化对象的版本控制" /></p>
<p><em>图 26 - 可序列化对象的版本控制</em></p>
<h3 id="会危及解序列化操作的类修改"><a class="header" href="#会危及解序列化操作的类修改">会危及解序列化操作的类修改：</a></h3>
<ul>
<li>删除某个实例变量；</li>
<li>修改实例变量的声明类型；</li>
<li>将非瞬态实例变量，修改为瞬态；</li>
<li>改变某个类在继承树上的位置（Moving a class up or down in the inheritance hierarchy）；</li>
<li>将某个类（只要是在对象图面上的）从可序列化修改为不可序列化（通过从类声明移除 <code>implements Serializable</code>）；</li>
<li>把某个实例变量修改为静态变量。</li>
</ul>
<h3 id="通过不会造成问题的对类的修改"><a class="header" href="#通过不会造成问题的对类的修改">通过不会造成问题的对类的修改：</a></h3>
<ul>
<li>往类加入新的实例变量（原有的那些对象，将以默认值来解序列化那些他们被序列化时所没有的那些实例变量）；</li>
<li>往继承树加入一些类；</li>
<li>从继承树移除一些类；</li>
<li>修改实例变量呃访问级别，对解序列化操作对该变量的赋值没有影响（Changing the access level of an instance variable has no effect on the ability of deserialization to assign a value to the variable）；</li>
<li>将某个瞬态实例变量，修改为非瞬态（先前被序列化的那些对象，将直接给先前瞬态的那些实例变量一个默认值）。</li>
</ul>
<h2 id="使用-serialversionuid"><a class="header" href="#使用-serialversionuid">使用 <code>serialVersionUID</code></a></h2>
<p>在每次对象被序列化时，对象（包括其对象图面中的所有对象），就会被“印上（stamped）”一个其所属类的版本ID编号（a version ID number for the object's class）。这个ID就叫做 <code>serialVersionUID</code>，是依据类的结构信息计算得到的。在对象被解序列化时，若在对象被序列化后类被修改了，那么类就会有一个与被序列化对象所印上的不同 <code>serialVersionUID</code>，那么解序列化就会失败！然而对此可以自己掌控。</p>
<p><strong>在认为类会有可能在今后 <em>演化</em>的情况下，就要在类中放入一个序列版本ID（If you think there is ANY possibility that your class might <em>evolve</em>, put a serial version ID in your class）</strong></p>
<p>在Java尝试对某个对象解序列化时，他会对这个被序列化对象的 <code>serialVersionUID</code> 与 JVM 用来对这个对象进行解序列化的类<code>serialVersionUID</code>加以比较。比如，在某个 <code>Dog</code> 实例被以 <code>ID</code> <code>23</code>（现实中 <code>serialVersionUID</code> 要长得多） 进行序列化时，那么在 JVM 对这个 <code>Dog</code> 对象解序列化时，就会首先拿这个 <code>Dog</code> 对象的 <code>serialVesionID</code> 与 <code>Dog</code> 类的 <code>serialVersionUID</code> 进行比较。在两个数字不匹配时，JVM 就会假定用于解序列化呃类，与先前被序列化的对象不兼容，同时在解序列化过程中会抛出一个异常。</p>
<p>那么解决办法就是在类中放入一个 <code>serialVersionUID</code>，然会随着类的演化，<code>serialVersionUID</code>将保持一致，这个时候就算类发生了改变， JVM 也会认为，“好吧，很好，这个类与这个被序列化对象是兼容的。”</p>
<p>这样处理也 <em>只会</em> 在对类修改小心谨慎时才凑效！也就是说，若在将旧有的对象以新的类复活时，有任何问题出现，都要由 <em>代码编写者</em> 来负责（In other words, <em>you</em> are taking responsibility for any issues that come up when an older object is brought back to life with a newer class）。</p>
<p>使用与 Java 开发包（Java development kit, jdk）一起发布的 <code>serialver</code> 工具，来获取类的 <code>serialVersionUID</code>:</p>
<pre><code class="language-console">$ serialver -classpath build/libs/com.xfoss.learningJava-0.0.1.jar com.xfoss.learningJava.Dog
com.xfoss.learningJava.Dog:    private static final long serialVersionUID = 1720600418317157466L;
</code></pre>
<p><img src="images/Ch14_27.png" alt="serialver 命令工具的使用和输出" /></p>
<p><em>图 27 - <code>serialver</code> 命令工具的使用和输出</em></p>
<blockquote>
<p>注：若类声明中没有 <code>implements Serializable</code>，那么 <code>serialver</code> 命令工具将给出如下输出：</p>
</blockquote>
<pre><code class="language-console">$ serialver -classpath build/libs/com.xfoss.learningJava-0.0.1.jar com.xfoss.learningJava.Dog
Class com.xfoss.learningJava.Dog is not Serializable.
</code></pre>
<p><img src="images/Ch14_28.png" alt="不可序列化对象的 serialver 输出" /></p>
<p><em>图 28 - 不可序列化对象的 <code>serialver</code> 输出</em></p>
<h3 id="在有人已经序列化了某个类的对象后而意识到这个类会进行演化时"><a class="header" href="#在有人已经序列化了某个类的对象后而意识到这个类会进行演化时">在有人已经序列化了某个类的对象后，而意识到这个类会进行演化时......</a></h3>
<p><strong>When you think your class might evolve after someone has serialized objects from it</strong>...</p>
<ol>
<li>
<p>使用命令行工具 <code>serialver</code> 获取这个类的版本 ID（<code>serialVersionUID</code>）</p>
<p><img src="images/Ch14_29.png" alt="使用命令行工具serialver，获取类的 serialVersionUID" /></p>
<p><em>图 29 - 使用命令行工具<code>serialver</code>，获取类的 <code>serialVersionUID</code></em></p>
</li>
<li>
<p>将上面的输出，粘贴到类中</p>
<pre><code class="language-java">public class Dog {
    private static final long serialVersionUID = 1720600418317157466L;

    private String name;
    private int size;

    // 以下是方法的代码
}
</code></pre>
</li>
<li>
<p>确保在对这个类做出修改时，自己要对这个类做出修改所带来的后果负责！比如就要确保新的 <code>Dog</code> 类能够以默认值，来处理在 <code>Dog</code> 被序列化后，所添加的那些实例变量的解序列化（For example, be sure that your new <code>Dog</code> class can deal with an old <code>Dog</code> be deserialized with default values for instance variables added to the class after the <code>Dog</code> was serialized）。</p>
</li>
</ol>
<h2 id="代码厨房"><a class="header" href="#代码厨房">代码厨房</a></h2>
<p><img src="images/Ch14_30.png" alt="第14章代码厨房：BeatBox app 曲目数据的保存与恢复" /></p>
<p><em>图 30 - 第14章代码厨房：<code>BeatBox</code> app 曲目数据的保存与恢复</em></p>
<p><strong>这里要让 <code>BeatBox</code> 把那些喜欢的曲目，加以保存并恢复</strong>。</p>
<h3 id="保存-beatbox-编曲"><a class="header" href="#保存-beatbox-编曲">保存 <code>BeatBox</code> 编曲</a></h3>
<p><strong>Saving a <code>BeatBox</code> pattern</strong></p>
<p>请记住，在 <code>BeatBox</code> 中，鼓编排无非就是一堆勾选框。在要演奏序列时，代码就会遍历这些勾选框，找出哪些鼓乐器的声音在总的16个节拍中的每个节拍会演奏（When it's time to play the sequence, the code walks through the checkboxes to figure out which drums sounds are playing at each of the 16 beats）。那么要保存编曲，只需把这些勾选框的状态保存下来即可。</p>
<p>这里可以构造一个简单的布尔值数组，来保存总共256个勾选框中各个勾选框的状态。由于数组 <em>中的</em> 那些东西可被序列化，因此数组亦是可序列化的，因此在保存布尔值的数组时没有问题。</p>
<p>而要将编曲加载回来，就要读取这个单个的布尔值数组对象（对其进行解序列化），并对这些勾选框加以恢复。在之前构建 <code>BeatBox</code> GUI的代码厨房中，已经见到了绝大部分的代码，那么在这一章中，就只会看到保存与恢复的代码了。</p>
<p>本次的代码厨房，将为下一章做好准备，在下一章中不再是把编曲写入 <em>文件（file）</em>，而是要将编曲透过 <em>网络（network）</em> 发送到服务器。同时与从文件加载 <em>进</em> 编曲不同，下一章会从 <em>服务器</em> 获取到编曲，用户一次会发送一个编曲到服务器。</p>
<p><strong>对编曲进行序列化（Serializing a pattern）</strong></p>
<pre><code class="language-java">// 这是一个`BeatBox`代码里面的内部类。
class SendPatternListener implements ActionListener {
    // 编曲保存操作，全部发生在用户点击了那个按钮，而发出了
    // 这个 ActionEvent 的时候。
    public void actionPerformed(ActionEvent ev) {
        // 构造一个保存各个勾选框状态的布尔值数组。
        boolean[] checkboxesState = new boolean[256];

        // 对 checkBoxList（即那些勾选框的 ArrayList）进行遍历
        // 并获得各个勾选框的状态，再将状态添加到这个布尔值
        // 的数组中。
        for (int i = 0; i &lt; 256; i++){
            JCheckBox check = (JCheckBox) checkBoxList.get(i);

            if (check.isSelected()) checkboxesState[i] = true;
        }

        try {
            // 这里就是小菜一碟了。只是将这个布尔值数组进行写入/序列化！
            String serFile = String.format(&quot;%s/pattern.ser&quot;, XPlatformThings.getWorkingDir(&quot;BeatBox&quot;));
            FileOutputStream fileStream = new FileOutputStream(new File(serFile));
            ObjectOutputStream os = new ObjectOutputStream(fileStream);
            os.writeObject(checkboxesState);
            os.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="beatbox编曲的恢复"><a class="header" href="#beatbox编曲的恢复"><code>BeatBox</code>编曲的恢复</a></h3>
<p><strong>Restoring a <code>BeatBox</code> pattern</strong></p>
<p>这就刚好与保存操作是反过来的了......读取那个序列化的布尔值数组对象，然后利用这个复活过来的数组对象，恢复GUI的那些勾选框状态。曲目恢复操作，全部发生自用户点击了“恢复”按钮的一瞬间。</p>
<p><strong>编曲的恢复（Restoring a pattern）</strong></p>
<pre><code class="language-java">// 这是另一个 BeatBox 代码里头的内部类。
class ReadInPatternListener implements ActionListener {
    public void actionPerformed(ActionEvent ev) {
        boolean[] checkboxesState = null;

        try {
            FileInputStream fileIn = new FileInputStream(new File(String.format(&quot;%s/pattern.ser&quot;, 
                            XPlatformThings.getWorkingDir(&quot;BeatBox&quot;))));
            ObjectInputStream is = new ObjectInputStream(fileIn);
            // 读取文件中那单独对象（即那个布尔值数组），并将其强制转换回到
            // 布尔值数组（请记住，readObject() 方法返回的是一个类型为 Object
            // 的引用变量。）
            checkboxesState = (boolean[]) is.readObject();
            is.close();
        } catch (Exception ex) {ex.printStackTrace();}

        // 现在对那些真正 JCheckBox 对象的 ArrayList 中各个勾选框状态
        // 进行恢复。
        for (int i = 0; i &lt; 256; i++) {
            JCheckBox check = (JCheckBox) checkboxList.get(i);
            if(checkboxesState[i]) check.setSelected(true);
            else check.setSelected(false);
        }

        // 此时要停止当前所演奏的任何曲目，并使用这个 JCheckBox ArrayList
        // 中的那些勾选框状态，重建出 MIDI 序列。
        s.stop();
        buildTrackAndStart();
    }
}
</code></pre>
<h3 id="动手练习"><a class="header" href="#动手练习">动手练习</a></h3>
<p><strong>Sharpen your pencil</strong></p>
<p>此版本有着巨大局限！在点击了 &quot;对其序列化&quot; 按钮时，程序将自动进行序列化操作，到一个名为“pattern.ser”的文件（若该文件不存在，就会被创建出来）。不过在每次保存时，都将覆写先前保存的文件。</p>
<p>请通过结合 <code>JFileChooser</code>，对这里的保存与恢复特性加以改进，从而可以随意命名，并保存出许多不同的曲目，同时还能够从先前所保存的文件，加载/恢复出 <em>任意</em> 的曲目。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Ch13_Using_Swing_Work_on_Your_Swing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="Ch15_Networking_and_Threads_Make_a_Connection.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Ch13_Using_Swing_Work_on_Your_Swing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="Ch15_Networking_and_Threads_Make_a_Connection.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
