<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">轻松学Java（Head First Java）</a></li><li class="chapter-item expanded "><a href="Ch01_Dive_in_A_Quick_Dip_Breaking_the_Surface.html"><strong aria-hidden="true">1.</strong> 快速投身于 Java：破冰</a></li><li class="chapter-item expanded "><a href="Ch02_Class_and_Objects_A_Trip_to_Objectville.html"><strong aria-hidden="true">2.</strong> 类与对象：对象村之旅</a></li><li class="chapter-item expanded "><a href="Ch03_Primitives_and_References_Know_Your_Variables.html"><strong aria-hidden="true">3.</strong> 原生与引用变量：了解你的那些变量</a></li><li class="chapter-item expanded "><a href="Ch04_Methods_Use_Instance_Variables_How_Objects_Behave.html"><strong aria-hidden="true">4.</strong> 用到实例变量的那些方法：对象行为机制</a></li><li class="chapter-item expanded "><a href="Ch05_Writing_a_Program_Extra-Strength_Methods.html"><strong aria-hidden="true">5.</strong> 编写一个程序：方法之附加力量</a></li><li class="chapter-item expanded "><a href="Ch06_Get_to_Know_The_Java_API_Using_the_Java_Library.html"><strong aria-hidden="true">6.</strong> 了解 Java API：运用 Java 的库</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">继承和多态机制</li><li class="chapter-item expanded "><a href="Ch07_Inheritance_and_Polymorphism_Better_Living_in_Objectville.html"><strong aria-hidden="true">7.</strong> 继承与多态：在对象村更好的过活</a></li><li class="chapter-item expanded "><a href="Ch08_Interfaces_and_Abstract_Classes.html"><strong aria-hidden="true">8.</strong> 接口及抽象类</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">编译器、堆与栈</li><li class="chapter-item expanded "><a href="Ch09_Constructors_and_Garbage_Collection_Life_and_Death_of_an_Object.html"><strong aria-hidden="true">9.</strong> 构造器与垃圾回收：对象的生与死</a></li><li class="chapter-item expanded "><a href="Ch10_Numbers_and_Statics_Numbers_Matter.html"><strong aria-hidden="true">10.</strong> 数字与静态元素：数字为要</a></li><li class="chapter-item expanded "><a href="Ch11_Exception_Handling_Risky_Behavior.html"><strong aria-hidden="true">11.</strong> 异常处理：冒险行为</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">GUI</li><li class="chapter-item expanded "><a href="Ch12_Getting_GUI_A_Very_Graphic_Story.html"><strong aria-hidden="true">12.</strong> 得到图形用户界面：一个甚为形象的故事</a></li><li class="chapter-item expanded "><a href="Ch13_Using_Swing_Work_on_Your_Swing.html"><strong aria-hidden="true">13.</strong> 运用 Swing：工作于 Swing 之上</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">对象序列化与数据结构</li><li class="chapter-item expanded "><a href="Ch14_Serialization_and_File_I_O_Saving_Objects.html"><strong aria-hidden="true">14.</strong> 序列化为文件 I/O：保存对象</a></li><li class="chapter-item expanded "><a href="Ch15_Networking_and_Threads_Make_a_Connection.html"><strong aria-hidden="true">15.</strong> 网络通信与线程：构造连接</a></li><li class="chapter-item expanded "><a href="Ch16_Collections_and_Generics_Data_Structure.html"><strong aria-hidden="true">16.</strong> 集合与泛型：数据结构</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">完结部分</li><li class="chapter-item expanded "><a href="Ch17_Package_JARs_and_Deployment_Release_Your_Code.html"><strong aria-hidden="true">17.</strong> 打包、JARs 与部署：发布代码</a></li><li class="chapter-item expanded "><a href="Ch18_Remote_Deployment_with_RMI_Distributed_Computing.html"><strong aria-hidden="true">18.</strong> 远端部署与 RMI：分布式计算</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">附录</li><li class="chapter-item expanded "><a href="Ch19_Appendix_A.html"><strong aria-hidden="true">19.</strong> 附录 A：十个几乎会进到本书的题目</a></li><li class="chapter-item expanded "><a href="Ch20_Appendix_B.html"><strong aria-hidden="true">20.</strong> 附录 B：其他要点</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="java-编程学习项目-"><a class="header" href="#java-编程学习项目-">Java 编程学习项目 ☕️</a></h1>
<p>在线阅读 <a href="https://java-lang.xfoss.com">java-lang.xfoss.com</a>。</p>
<p>这是一个学习 Java 的项目。使用 Eclipse IDE/VIM、Gradle/NPM 构建工具。后期会涉及到 NPM 的使用。主要学习 Java 的基础知识，Java 本地应用程序的编写。 <strong>项目使用 JDK <code>11.0.12</code></strong> 语言环境。</p>
<h2 id="0-环境搭建"><a class="header" href="#0-环境搭建">0. 环境搭建</a></h2>
<p>本项目是在 Ubuntu Linux 20.04 LTS 上进行的。</p>
<ul>
<li>
<p>安装JDK</p>
<p>JDK的当前LTS版是 <code>JDK 17.0.1</code>（Oracle, 2021-11），你可以直接从 <a href="https://jdk.java.net/java-se-ri/11">Java Downloads | jdk.java.net</a> 下载。openjdk-11+28_linux-x64_bin.tar.gz` 压缩包有 178.9M 大小。</p>
<p>运行下面的命令，就安装好 OpenJDK 了。</p>
</li>
</ul>
<pre><code class="language-bash">$sudo tar xf /path/to/openjdk-11+28_linux-x64_bin.tar.gz -C /opt/
$sudo ln -s /opt/openjdk-11+28 /opt/jdk
$sudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/opt/jdk/bin/java&quot; 1
$sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/opt/jdk/bin/javac&quot; 1
</code></pre>
<p>运行 <code>$java -version</code> 与 <code>$javac -version</code> 测试 JDK 是否安装妥当。</p>
<ul>
<li>
<p>安装 <a href="https://gradle.org/">Gradle</a></p>
<p>参考 Gradle 官网上使用 <a href="http://sdkman.io/">SDKMAN!</a> 直接安装即可。</p>
</li>
<li>
<p>安装Maven</p>
<p><a href="http://maven.apache.org/">Apache Maven</a> 可以直接下载，下载到的 <code>apache-maven-3.8.4-bin.tar.gz</code>压缩包，大小约 9M，安装步骤与JDK的略有不同：</p>
</li>
</ul>
<pre><code class="language-bash">$sudo tar xf /path/to/apache-maven-3.8.4-bin.tar.gz -C /opt/
$sudo ln -s /opt/apache-maven-3.8.4 /opt/mvn
$sudo vim.gtk /etc/profile.d/mvn.sh
$sudo chmod +x /etc/profile.d/mvn.sh
</code></pre>
<p>其中建立了一个 <code>/etc/profile.d/mvn.sh</code> 文件，并修改为了可执行文件。该文件的内容为：</p>
<pre><code class="language-sh">export JAVA_HOME=/opt/jdk
export M2_HOME=/opt/mvn
export MAVEN_HOME=/opt/mvn
export PATH=${M2_HOME}/bin:${PATH}
</code></pre>
<p>随后可将国内的华为 MAVEN 代码仓库，设置为MAVEN的默认代码仓库。运行如下命令：</p>
<pre><code class="language-bash">$if [ -d $HOME&quot;/.m2&quot; ]; then :; else echo &quot;~/.abc not exist. Now create&quot;; mkdir $HOME&quot;/.m2&quot;; fi
$wget -qO ~/.m2/settings.xml https://mirrors.huaweicloud.com/api/v1/configurations/maven?
</code></pre>
<ul>
<li>安装NVM</li>
<li>配置 <code>~/.vimrc</code></li>
</ul>
<h2 id="1-关于文件目录结构"><a class="header" href="#1-关于文件目录结构">1. 关于文件/目录结构</a></h2>
<p>在编写 Java 程序时，使用 Maven 构建，必须以这样的 <code>src/main/java/com/xfoss/learningJava/*.java</code> 的文件/目录结构，否则会报错：</p>
<pre><code class="language-bash">peng@uDesktop:~/eclipse-workspace/learningJava$ java -jar target/com.xfoss.learningJava-0.0.1.jar
Error: Could not find or load main class com.xfoss.learningJava.PhraseOMatic
Caused by: java.lang.ClassNotFoundException: com.xfoss.learningJava.PhraseOMatic
</code></pre>
<blockquote>
<p>同时，<code>packege com.xfoss.com.learningJava;</code> 对应的包 <code>com.xfoss.learningJava</code> 必须以这个名字命名，这也是上面目录中 <code>/com/xfoss/learningJava</code> 的来源。</p>
</blockquote>
<h2 id="2-使用-exec-maven-plugin"><a class="header" href="#2-使用-exec-maven-plugin">2. 使用 <code>exec-maven-plugin</code></a></h2>
<p>使用这个插件，可以开启 <code>mvn exec:java</code> 命令，实时运行（正在）编写的 Java 程序。该插件支持两种运行模式，一种是在 Maven 所在线程里运行（需要修改 MAVEN 运行参数 <code>export MAVEN_OPTS=-Xmx1024m</code>，以增加JVM虚拟机的运行内存）；另一种以独立线程运行（尚需测试）。</p>
<h2 id="3-buildgradlekts-文件中的-kotlin-dsl-语法"><a class="header" href="#3-buildgradlekts-文件中的-kotlin-dsl-语法">3. <code>build.gradle.kts</code> 文件中的 kotlin dsl 语法</a></h2>
<p>Kotlin DSL, 领域特定语言，Domain Specific Language</p>
<blockquote>
<p>参考： <a href="https://juejin.cn/post/6844903569372479501">Kotlin 之美 -- DSL 篇</a></p>
</blockquote>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<h3 id="基础"><a class="header" href="#基础">基础</a></h3>
<ul>
<li><a href="docs/Ch02_Class_and_Object_A_Trip_to_Objectville.html">类与对象：对象村之旅</a></li>
<li><a href="docs/Ch03_Primitives_and_References_Know_Your_Variables.html">原生与引用：熟知你的变量</a></li>
<li><a href="docs/Ch04_Methods_Use_Instance_Variables_How_Objects_Behave.html">方法对实例变量的使用：对象的行为方式</a></li>
<li><a href="docs/Ch05_Writing_a_Program_Extra-Strength_Methods.html">实战编程：给方法赋能</a></li>
<li><a href="docs/Ch06_Get_to_Know_The_Java_API_Using_the_Java_Library.html">了解Java API：使用Java的库</a></li>
</ul>
<h3 id="继承和多态机制"><a class="header" href="#继承和多态机制">继承和多态机制</a></h3>
<ul>
<li><a href="docs/Ch07_Inheritance_and_Polymorphism_Better_Living_in_Objectville.html">继承与多态：追求对象村的更好生活</a></li>
<li><a href="docs/Ch08_Interfaces_and_Abstract_Classes.html">接口与抽象类</a></li>
</ul>
<h3 id="编译器堆与栈"><a class="header" href="#编译器堆与栈">编译器、堆与栈</a></h3>
<ul>
<li><a href="docs/Ch09_Constructors_and_Garbage_Collection_Life_and_Death_of_an_Object.html">构造器与垃圾回收: 对象的生与死</a></li>
<li><a href="docs/Ch10_Numbers_and_Statics_Numbers_Matter.html">数字与静态值：数字为要</a></li>
<li><a href="docs/Ch11_Exception_Handling_Risky_Behavior.html">例外处理：危险行为</a></li>
</ul>
<h3 id="gui"><a class="header" href="#gui">GUI</a></h3>
<ul>
<li><a href="docs/Ch12_Getting_GUI_A_Very_Graphic_Story.html">获得GUI：一个甚为形象的故事</a></li>
<li><a href="docs/Ch13_Using_Swing_Work_on_Your_Swing.html">运用 <code>Swing</code>: 在 <code>Swing</code> 上干活</a></li>
</ul>
<h3 id="对象序列化与数据结构"><a class="header" href="#对象序列化与数据结构">对象序列化与数据结构</a></h3>
<ul>
<li><a href="docs/Ch14_Serialization_and_File_I_O_Saving_Objects.html">对象序列化与文件的输入/输出：对象保存</a></li>
<li><a href="docs/Ch15_Networking_and_Threads_Make_a_Connection.html">联网与线程：构造连接</a></li>
<li><a href="docs/Ch16_Collections_and_Generics_Data_Structure.html">集合与泛型：数据结构</a></li>
</ul>
<h3 id="完结"><a class="header" href="#完结">完结</a></h3>
<ul>
<li><a href="docs/Ch17_Package_JARs_And_Deployment_Release_Your_Code.html">打包、JARS与部署：发布代码</a></li>
<li><a href="docs/Ch18_Remote_Deployment_with_RMI_Distributed_Computing.html">使用 RMI 特性进行远端部署：分布式计算</a></li>
</ul>
<h3 id="附录"><a class="header" href="#附录">附录</a></h3>
<ul>
<li><a href="docs/Ch19_Appendix.html">附录 A：十个本书未列入正式章节的方面</a></li>
<li><a href="docs/Ch20_Appendix_B.html">附录 B: 其他要点</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Ch01_Dive_in_A_Quick_Dip_Breaking_the_Surface.md</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类与对象对象村之旅"><a class="header" href="#类与对象对象村之旅">类与对象：对象村之旅</a></h1>
<h2 id="java对垃圾的清扫"><a class="header" href="#java对垃圾的清扫">Java对垃圾的清扫</a></h2>
<p>在Java中，每次创建出的对象，都会被放入到内存堆（The Heap）里。不管对象是在何时、何处、以何种方式创建，他们都是存活在内存堆里。但这里的内存堆，与以往所有的老式内存堆，都是不同的。Java的堆，实际上叫做 <strong>垃圾可回收堆</strong> （<strong>Garbage-Collectible Heap</strong>）。在创建某个对象时，Java就根据那个特定对象所需大小，在堆上为其分配内存。比如对于一个有着15个实例变量的对象，可能就比仅有两个实例变量的对象，需要更多的空间。</p>
<p>那么在需要回收那块空间时会发生什么呢？在用完某个对象后，该怎么将其从堆里拿开呢？这些工作是Java来完成的！在JVM发现某个对象再也不会用到后，那个对象就成为了 <em>可被垃圾回收</em>。在内存吃紧时，<strong>垃圾回收器</strong> （Garbage Collector） 将会运行起来，将那些无法到达的对象踢出去，从而清理出空间。后续章节将深入垃圾回收机制。</p>
<h2 id="main-方法的两个作用"><a class="header" href="#main-方法的两个作用"><code>main</code> 方法的两个作用</a></h2>
<ul>
<li>用来对类进行 <strong>测试</strong>（用在 <code>TestDrive</code> 中, to <strong>test</strong> your real class）</li>
<li>用来 <strong>启动</strong> Java <strong>应用</strong> （to <strong>launch/start</strong> your Java <strong>application</strong>）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="原生与参考熟知你的变量"><a class="header" href="#原生与参考熟知你的变量">原生与参考：熟知你的变量</a></h1>
<p>变量有两种：<strong>原生变量</strong> （<strong>primitive</strong>）和 <strong>参考变量</strong> （<strong>reference</strong>）。到现在为止，我们在两个地方用到了变量：作为对象状态（实例变量），以及作为本地变量（在方法中声明的变量）。后面会把变量用作 <strong>参数</strong>（<strong>arguments</strong>, 由调用代码发送给方法的值），同时作为返回类型(<strong>return types</strong>，返回到方法调用者的值)。在前面已经见到了声明为简单的 <strong>原生</strong> 整数值（比如 <code>int</code> 类型）。也见到过声明为更为复杂的诸如字符串（<code>String</code>）或数组（<code>array</code>）变量。但在现实生活中，有着远比整数、字符串以及数组复杂的东西，比如一个有着 <code>Dog</code> 实例变量的 <code>PetOwner</code> 对象，或者有着 <code>Engine</code> 的 <code>Car</code> 对象，本章将揭开 Java 类型谜题，看看可以 <strong>声明</strong> （<strong>declare</strong>）出什么样的变量，在变量中可以 <strong>放入</strong> （<strong>put in</strong>）些什么东西，以及对变量可以进行什么操作。还会揭示 <strong>垃圾回收堆</strong>（<strong>garbage-collectible heap</strong>）上，所发生的事情。</p>
<h2 id="声明一个变量"><a class="header" href="#声明一个变量">声明一个变量</a></h2>
<p><strong>Java 是类型敏感的</strong> （<strong>Java cares about type</strong>）。他不会让你去干那些诡异又危险的事情，比如把一头长颈鹿当成兔子来加以引用，就如同某人要让长颈鹿去像兔子那样蹦跳时会怎样呢？Java也不会让你把一个浮点数放到整数变量里，除非你 <strong>告知了编译器</strong>，你知道那样做可能会失去精度（也就是小数点后面的所有数字）。</p>
<p>编译器（<code>javac</code>）会发现大部分问题：</p>
<pre><code class="language-java">Rabbit hopper = new Giraffe();
</code></pre>
<p>别指望这代码会被编译出来。拜托!</p>
<p>为了能让 <strong>类型安全</strong> （<strong>type-safty</strong>）发挥作用，就要声明变量的类型。变量是个整数？还是 <code>Dog</code>? 还是是单个的字符。变量类型有两种：<strong>原生</strong> （<strong>primitive</strong>）与 <strong>对象引用</strong>（<strong>object reference</strong>）。原生变量保存的是一些基础类型的值（可以理解为简单的位模式，simple bit patterns），包括整数、逻辑值以及浮点数。对象参考变量，则是保存了对对象的参考（<em>references to objects</em>）。</p>
<p><strong>所有变量，都必须有一个类型</strong>。</p>
<p>除了类型，变量还必须有个名称，如此就可以在代码中，使用他的名称了。</p>
<p><strong>变量必须有个名称</strong>。</p>
<pre><code class="language-java">int count;
</code></pre>
<p><code>int</code>是类型（<code>type</code>），<code>count</code>是名称（<code>name</code>）。</p>
<blockquote>
<p>注意：如果你遇到这样一个语句时：<code>an object of type X</code>，就把 <code>type</code>和<code>class</code>当成同义词吧。</p>
</blockquote>
<p><strong>变量是一个容器，用于 <em>保存</em> 某个事物。（A variable is just a cup. A container. It <em>holds</em> something）</strong></p>
<p><strong>原生类型</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">类型</th><th style="text-align: center">位深度（Bit Depth）</th><th style="text-align: center">取值范围</th></tr></thead><tbody>
<tr><td style="text-align: center">逻辑值与字符</td><td style="text-align: center">---</td><td style="text-align: center">---</td></tr>
<tr><td style="text-align: center">逻辑值（<code>boolean</code>）</td><td style="text-align: center">特定于 JVM</td><td style="text-align: center"><code>true</code>或<code>false</code></td></tr>
<tr><td style="text-align: center">字符（<code>char</code>）</td><td style="text-align: center">16位</td><td style="text-align: center"><code>0</code> 到 <code>65535</code></td></tr>
<tr><td style="text-align: center">数值（都是有符号的）</td><td style="text-align: center">---</td><td style="text-align: center">---</td></tr>
<tr><td style="text-align: center">字节（<code>byte</code>）</td><td style="text-align: center">8位</td><td style="text-align: center"><code>-128</code> 到 <code>127</code></td></tr>
<tr><td style="text-align: center">短整数（<code>short</code>）</td><td style="text-align: center">16位</td><td style="text-align: center"><code>-32,768</code> 到 <code>32,767</code></td></tr>
<tr><td style="text-align: center">整数（<code>int</code>）</td><td style="text-align: center">32位</td><td style="text-align: center"><code>-2,147,483,648</code> 到 <code>2,147,483,647</code></td></tr>
<tr><td style="text-align: center">长整数 （<code>long</code>）</td><td style="text-align: center">64位</td><td style="text-align: center"><code>-9,223,372,036,854,775,808</code> (<code>-2^63</code>) 到 <code>9,223,372,036,854,775,807</code> (<code>2^63 – 1</code>)</td></tr>
<tr><td style="text-align: center">浮点数</td><td style="text-align: center">---</td><td style="text-align: center">---</td></tr>
<tr><td style="text-align: center">单精度浮点数（<code>float</code>）</td><td style="text-align: center">32位</td><td style="text-align: center">根据JVM的不同而不同</td></tr>
<tr><td style="text-align: center">双精度浮点数（<code>double</code>）</td><td style="text-align: center">64位</td><td style="text-align: center">根据JVM的不同而不同</td></tr>
</tbody></table>
</div>
<p><strong>带赋值的原生变量声明</strong>：</p>
<pre><code class="language-java">int x;
x = 234;
byte b = 89;
boolean isFun = true;
double d = 3456.98;
char c = 'f';
int z = x;
boolean isPunkRock;
isPunkRock = false;
boolean powerOn;
powerOn = isFun;
long big = 3456789;
float f = 32.5f;
</code></pre>
<blockquote>
<p>注意最后一个中的 <code>f</code>，因为Java会将所有带着小数点的没有 <code>f</code> 的数，看着是双精度浮点数，因此要在后面加上 <code>f</code> 来表示单精度浮点数。</p>
</blockquote>
<p><strong>将值赋给变量的方式有以下三种</strong>：</p>
<ul>
<li>在等号之后键入一个 <em>字面值</em> （比如： <code>x = 12</code>, <code>isGood = true</code>）</li>
<li>将一个变量的值赋给另一个变量 （比如 <code>x = y</code>）</li>
<li>使用结合了变量与字面值的表达式 （比如 <code>x = y + 43</code>）</li>
</ul>
<blockquote>
<p>Java中声明了原生变量后需要初始化，若未初始化，将报出以下错误：</p>
</blockquote>
<pre><code class="language-java">int y;
System.out.println(y);
</code></pre>
<pre><code class="language-bash">java.lang.Error: Unresolved compilation problem:
        The local variable y may not have been initialized
</code></pre>
<p><strong>而对象中的变量，则不存在这样的问题，其在对象初始化时，会被自动赋值。</strong></p>
<p><strong>变量命名规则</strong></p>
<ul>
<li>必须以字母、下划线（<code>_</code>）或美元符号（<code>$</code>）开头。那么就不能以数字开头。</li>
<li>后面就可以使用数字了。只是不能以数字开头。</li>
<li>可以是你所喜爱的任何字符串，除开上面两条规则外，还要不能是 Java 的保留字。</li>
</ul>
<p><strong>Java的保留字</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>boolean</code></th><th style="text-align: center"><code>byte</code></th><th style="text-align: center"><code>char</code></th><th style="text-align: center"><code>double</code></th><th style="text-align: center"><code>float</code></th><th style="text-align: center"><code>int</code></th><th style="text-align: center"><code>long</code></th><th style="text-align: center"><code>short</code></th><th style="text-align: center"><code>public</code></th><th style="text-align: center"><code>private</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>protected</code></td><td style="text-align: center"><code>abstract</code></td><td style="text-align: center"><code>final</code></td><td style="text-align: center"><code>native</code></td><td style="text-align: center"><code>static</code></td><td style="text-align: center"><code>strictfp</code></td><td style="text-align: center"><code>syschronized</code></td><td style="text-align: center"><code>transient</code></td><td style="text-align: center"><code>volatile</code></td><td style="text-align: center"><code>if</code></td></tr>
<tr><td style="text-align: center"><code>else</code></td><td style="text-align: center"><code>do</code></td><td style="text-align: center"><code>while</code></td><td style="text-align: center"><code>switch</code></td><td style="text-align: center"><code>case</code></td><td style="text-align: center"><code>default</code></td><td style="text-align: center"><code>for</code></td><td style="text-align: center"><code>break</code></td><td style="text-align: center"><code>continue</code></td><td style="text-align: center"><code>assert</code></td></tr>
<tr><td style="text-align: center"><code>class</code></td><td style="text-align: center"><code>extends</code></td><td style="text-align: center"><code>implements</code></td><td style="text-align: center"><code>import</code></td><td style="text-align: center"><code>instanceof</code></td><td style="text-align: center"><code>interface</code></td><td style="text-align: center"><code>new</code></td><td style="text-align: center"><code>package</code></td><td style="text-align: center"><code>super</code></td><td style="text-align: center"><code>this</code></td></tr>
<tr><td style="text-align: center"><code>catch</code></td><td style="text-align: center"><code>finally</code></td><td style="text-align: center"><code>try</code></td><td style="text-align: center"><code>throw</code></td><td style="text-align: center"><code>throws</code></td><td style="text-align: center"><code>return</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center"><code>const</code></td><td style="text-align: center"><code>goto</code></td><td style="text-align: center"><code>enum</code></td></tr>
</tbody></table>
</div>
<p><strong>关于参考变量</strong></p>
<ul>
<li>实际上是不存在 <strong>对象</strong> 变量的（There is actually no such thing as an <strong>object</strong> variable）</li>
<li>有的只是对象 <strong>参考</strong> 变量（There's only an object <strong>reference</strong> variable）</li>
<li>对象参考变量所存储的，是表示一种访问对象的方式的数据位（An object reference variable holds bits that represent a way to access an object）</li>
<li>对象参考变量，并非保存的是对象本身，而是类似于指针的东西，或者说是一个内存地址。就算在不知道某个参考变量里头具体是什么，我们也明白他到底是个什么，参考变量代表着唯一的对象。同时JVM也知道如何使用这个引用，来获取到某个对象。</li>
</ul>
<p><strong>对象引用</strong> 只是另一个变量值（An object reference is just another variable value）。</p>
<p><strong>对象声明、创建与赋值三步骤</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>Dog myDog</code></th><th style="text-align: center"><code>=</code></th><th style="text-align: center"><code>new Dog();</code></th></tr></thead><tbody>
<tr><td style="text-align: center">1</td><td style="text-align: center">3</td><td style="text-align: center">2</td></tr>
</tbody></table>
</div>
<ol>
<li>声明一个引用变量（Declare a reference variable）</li>
</ol>
<p>告诉JVM为某个引用变量分配空间，同时给变量命名。引用变量的类型，就固定下来了（<code>Dog</code>）。</p>
<ol start="2">
<li>创建一个对象</li>
</ol>
<p>告诉虚拟机给新的对象，在内存堆上分配空间。</p>
<ol start="3">
<li>将对象和对象引用连接起来（Link the object and the reference）</li>
</ol>
<p>将新的对象赋值给引用变量（实际上是把新对象在内存堆上的地址，赋值给对象的引用）。</p>
<p><strong>引用变量的大小</strong></p>
<p>跟JVM相关，是内存堆的编址/寻址方式决定的。对象引用本质上是一些指针，但不能访问到他们。也不需要访问他们。可以把这些对象引用看着是一个64位的地址。</p>
<p>不管对象有多大，各种对象的引用，都是一样大的（64位）。对于给定的JVM，所有对象引用变量的大小都是一样的。各个JVM在表示对象引用变量上可能有所不同。</p>
<p>不能对引用变量做C语言中，指针那样的前后移动的算术运算，<strong>Java 不是 C</strong>。</p>
<ul>
<li>对象引用是一个到对象的指针（存储对象在内存堆中的地址），可以是同一类型下不同对象的引用</li>
<li>被 <code>final</code> 关键字修饰的对象引用，就只能是一个对象的引用了，不能再被赋值其他对象</li>
<li><code>null</code> 是一个值，表示空指针，在某个对象被赋值了空指针后，就失去了对原来对象的引用，原来那个对象，就再也访问不到了，将被垃圾回收</li>
<li>两个对象引用变量，可以指向同一个对象</li>
<li>失去了对象引用变量的对象，将被垃圾回收</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法对实例变量的使用对象行为方式"><a class="header" href="#方法对实例变量的使用对象行为方式">方法对实例变量的使用：对象行为方式</a></h1>
<p><strong>对象行为与状态之间的互动（状态影响行为，行为亦影响状态）</strong>。我们已然知道对象有着 <strong>状态</strong> 与 <strong>行为</strong>，分别由 <strong>实例变量</strong> 和 <strong>方法</strong> 所表示。但直到现在，我们仍对二者之间是如何关联起来的一无所知。我们已经知道某个类的各个实例（也就是某个特定类型的各个对象），对于其实例变量，都可以有独特的值。<code>Dog</code> A 的名字可以是 <code>Fido</code>，重量是 <code>70</code> 磅，<code>Dog</code> B 的名字是 <code>Killer</code>，重量是 <code>9</code> 磅。如果 <code>Dog</code> 类有一个 <code>makeNoise()</code> 方法，那么 70 磅的狗子发出的声音肯定要比 9 磅的狗子低沉一些。幸运的是，这就是对象的应有之义 -- 其行为取决于其状态。换句话说，就是 <strong>方法使用到实例变量的值</strong>。比如”如果狗子重量大于14磅，那么就会发出嚎叫声，相反则会发出呜呜声“，或者“重量每增加5磅，发出的声音就低一些”。</p>
<p><strong>类描述了对象知道什么，和做些什么（A class describes what an object knows and what it does）</strong></p>
<p><strong>类是对象的蓝图（A class is the blueprint for an object）。</strong> 在编写某个类的时候，实际上实在告诉JVM，怎样去构造那个类型的对象。我们已经知道某个类型的各个对象，可以有着不同的实例变量值，那么在方法上呢？</p>
<p><strong>某个类型的各个对象，可以有着不同的方法行为吗？</strong></p>
<p>答案是：...<strong>当然可以</strong>。</p>
<p>特定类的各个实例，有着同样的方法，但根据各自实例变量的值，这些方法可以行事各异。</p>
<ul>
<li>
<p><strong>可以向方法传递值</strong>。<strong>方法使用参数，调用者传递参数（A method use parameters. A caller passes arguments）</strong>。</p>
</li>
<li>
<p><strong>又可以从某个方法，得到返回值</strong>。</p>
</li>
<li>
<p><strong>Java 是值传递的，也就是说传递的是拷贝（Java is pass-by-value. That means pass-by-copy）</strong>。</p>
</li>
<li>
<p>在往方法传递对象引用变量（某个类的类型变量），而不是原生类型变量时，情况就比较复杂了。但是仍然是值传递。<strong>Java中的参数传递，全都是值传递</strong>，传递的是对象地址（指针）的一个拷贝。</p>
</li>
<li>
<p>方法只能声明一个返回值。对于同一类型的几个值，可以返回一个数组。对于要返回不同类型的几个值，情况则稍微复杂。后续章节中讲到 <code>ArrayList</code> 时，会讲到这个问题。</p>
</li>
<li>
<p>可以返回任何的可 <em>隐式</em> 提升到所声明的返回值类型的值（Anything could be <em>implicitly</em> prometed to the type declared, can be returned as the return value）。因此就可以把一个 <code>byte</code> 类型的值，作为 <code>int</code> 类型，返回给调用者。函数调用者不会 care 这个，因为 <code>byte</code> 类型恰好与 <code>int</code> 是兼容的，调用者就会把其作为返回赋值。在所声明的类型比返回值的空间要大的时候，就要 <strong>显式</strong> 的进行截取了。</p>
</li>
<li>
<p>可以不理会被调用方法的返回值。不必接收返回值。</p>
</li>
<li>
<p><strong>Getters</strong> 和 <strong>Setters</strong>，访问器与修改器，从对象中获取或设置实例变量（对象属性，attributes）。访问器的唯一目的，就是取得某个实例变量的值。</p>
</li>
<li>
<p>封装（encapsulation），特指类的封装。定义/编写类/类型（class/type）的时候，将实例变量标记为 <code>private</code>，将访问器和修改器标记为 <code>public</code>。避免外部直接接触到对象的实例变量（instance variables, 属性，attributes）。</p>
</li>
<li>
<p>封装给对象的实例变量装上了金钟罩，从此就没有人能把 <strong>不恰当（inappropriate）</strong> 的值设置给他们了。</p>
</li>
<li>
<p>大多数实例变量，都硬编码了其值的范围确定的具体条件。比如说，如果允许负数出现，那么所有事情都将崩溃。淋浴房的数量、飞机的航速、生日、杠铃重量、手机号码、微波炉功率等等....</p>
</li>
<li>
<p>通过强制其他代码通过修改器（<code>setter</code>）检查，来为实例变量设置边界。修改器可以对参数进行检查，从而确定是否可行。也许修改器会拒绝而什么也不干，或者将抛出一个例外（<code>Exception</code>，比如对于某个信用卡应用来说无效的社保编号），或者修改器会把传递进来的参数，按照最接近的可接受值进行保留取值。关键是，可以在修改器方法中，做任何想要的操作。相反如果实例变量是 <code>public</code> 的话，就什么也做不了了。</p>
</li>
<li>
<p>修改器的要点（同时访问器也是），就是 <em>可以在不破坏外部代码的情况下，于后期改变主意</em>！封装的价值就在于，你可以改变主意，没有人会受伤害。直接去使用实例变量所能得到的性能优势，相对使用封装所带来的好处，简直不值一提。</p>
</li>
</ul>
<p><strong>实例变量总是会获得一个默认值，在没有显示地给某个实例变量赋值，也没有调用修改器的时候，实例变量仍然有着一个值！</strong> </p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">类型</th><th style="text-align: right">默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">整数</td><td style="text-align: right"><code>0</code></td></tr>
<tr><td style="text-align: left">浮点数</td><td style="text-align: right"><code>0.0</code></td></tr>
<tr><td style="text-align: left">逻辑值</td><td style="text-align: right"><code>false</code></td></tr>
<tr><td style="text-align: left">引用（references）</td><td style="text-align: right"><code>null</code></td></tr>
</tbody></table>
</div>
<h2 id="实例变量与本地变量的不同之处"><a class="header" href="#实例变量与本地变量的不同之处">实例变量与本地变量的不同之处</a></h2>
<ul>
<li>实例变量是在类中、方法之外声明的。</li>
<li>本地变量是在方法中所声明的。</li>
<li>本地变量在使用前必须被初始化！</li>
</ul>
<p><strong>本地变量不会获取到一个默认值！在变量尚未初始化之前就使用加以使用，编译器就会报出错误。</strong></p>
<h2 id="变量的比较包括原生变量与引用变量"><a class="header" href="#变量的比较包括原生变量与引用变量">变量的比较（包括原生变量与引用变量）</a></h2>
<p><strong>使用 <code>==</code> 来比较两个原生变量</strong></p>
<p><code>==</code> 可用于比较任何类型的原生变量，只是简单的对数据位（bits）进行比较。<code>if (a==b){...}</code>就是去查看<code>a</code>和<code>b</code>中的数据位，如果二者的位模式一致，就返回 <code>true</code>（他不会关心变量的尺寸，因此变量左侧的那些额外的<code>0</code>就没有关系）。</p>
<pre><code class="language-java">int a = 3;
byte b = 3;
if (a==b) {// true}
</code></pre>
<p><strong>要检查两个引用变量是否同样（就是说他们是否是内存堆上同一对象的引用），也是使用 <code>==</code></strong>。</p>
<p>对于原生变量和引用变量来说，<code>==</code>运算符都是只关心变量中的数据位模式。因此在两个引用变量都是指向同一个对象时，将返回 <code>true</code>！就算我们不知道引用变量的位模式（bit pattern）具体是怎样的（因为这取决于 JVM，对我们是隐藏的），但我们是知道他看起来是怎样的，<em>两个指向同一对象的引用，将是相同的</em>。</p>
<pre><code class="language-java">Foo a = new Foo ();
Foo b = new Foo ();
Foo c = a;

if (a == b) { // false }
if (a == c) { // true } 
if (b == c) { // false }
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">问题</th><th style="text-align: left">答案</th></tr></thead><tbody>
<tr><td style="text-align: left">类可以有着任意数量的。</td><td style="text-align: left">实例变量，访问器，修改器，方法</td></tr>
<tr><td style="text-align: left">方法只能有一个的。</td><td style="text-align: left"><code>return</code></td></tr>
<tr><td style="text-align: left">可以隐式提升的（This can be implicitly promoted）。</td><td style="text-align: left"><code>return</code>, <code>argument</code></td></tr>
<tr><td style="text-align: left">优先使用私有的实例变量（Prefer instance variables private）。</td><td style="text-align: left">封装</td></tr>
<tr><td style="text-align: left">就是要“生成一份拷贝”（It really means 'make a copy'）。</td><td style="text-align: left">值传递</td></tr>
<tr><td style="text-align: left">只能由修改器来更新。</td><td style="text-align: left">实例变量</td></tr>
<tr><td style="text-align: left">方法可以后多个的。</td><td style="text-align: left">参数</td></tr>
<tr><td style="text-align: left">根据定义返回一些东西。</td><td style="text-align: left">访问器（getter）</td></tr>
<tr><td style="text-align: left">不应和实例便利一起使用的。</td><td style="text-align: left"><code>public</code></td></tr>
<tr><td style="text-align: left">可以有多个参数</td><td style="text-align: left">方法</td></tr>
<tr><td style="text-align: left">有助于建立良好封装的。</td><td style="text-align: left">访问器，修改器，<code>public</code>, <code>private</code></td></tr>
<tr><td style="text-align: left">总是独行的（I always fly solo）。</td><td style="text-align: left"><code>return</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="实战编程给方法赋能"><a class="header" href="#实战编程给方法赋能">实战编程：给方法赋能</a></h1>
<p>本章就要给方法以力量。前面已经详细讨论了变量，也玩了玩几个对象，还写了一点代码。这个时候还不够强大，我们需要一些新的工具。比如 <strong>运算符（operators）</strong>。需要更多的运算符来完成一些比 <code>bark</code> 更有趣的事情。我们还需要 <strong>循环（loops）</strong>，是需要循环，但那个羸弱的 <code>while</code> 循环能干些什么呢？干正事的时候我们需要 <code>for</code> 循环。<strong>生成一个随机数</strong>也会是有用的，同时 <strong>将一个字符串转换成整数</strong>也是这样。从本章开始将从头开始构建一个真实的应用，那将会是一个游戏。这是一个繁重的任务，因此将占据两个章节。</p>
<h2 id="第一步高级别设计a-high-level-design"><a class="header" href="#第一步高级别设计a-high-level-design">第一步，高级别设计（a high-level design）</a></h2>
<p>Java程序设计当然要用到类与方法，但他们到底是怎样的呢？要回答这个问题，就需要更多有关应用的信息。</p>
<p>首先就要搞清楚应用的一般流程。</p>
<ol>
<li>
<p>用户启动游戏</p>
<p>A) 游戏创建出三个网站名字
B) 游戏将这三个网站名字，放置在一个虚拟网格上</p>
</li>
<li>
<p>开始玩游戏</p>
<p>重复下面的步骤，知道翻出所有网站名字：</p>
<ul>
<li>A. 提醒玩家给出某个网格上的格子（比如 <code>A2</code>、<code>C0</code>）</li>
<li>B. 将玩家猜的格子，与所有网站名字所在的格子进行检查，看看有没有猜中。根据结果，进行适当的操作</li>
</ul>
</li>
<li>
<p>游戏结束</p>
<p>基于猜中的次数，给玩家打分。</p>
</li>
</ol>
<p><img src="images/Ch05_01.png" alt="“击沉战舰游戏”流程图" /></p>
<p><em>图 1 - “击沉战舰游戏”流程图</em></p>
<p>下面就要搞清楚，为了完成这个游戏作品，需要怎样的一些对象。需要以面向对象思维，而不是面向过程思维，着眼于程序中的 <strong>事物（things）</strong>，而不是程序中的 <strong>过程（procedures）</strong>。</p>
<h2 id="类的编写developing-a-class"><a class="header" href="#类的编写developing-a-class">类的编写（Developing a Class）</a></h2>
<p>每名程序员，都要有编写代码的方法论/流程/途径（As a programmer, you probably hava a methodology/process/approach）。当然Java程序员也是这样，下面的这个排序，就是在编写Java类的时候，所考虑到的事情。在现实工作中并非都要按照这样的顺序来执行。实际工作中，会按照自己偏好、项目的不同，甚至雇主的意愿来操作。基本上是可以想怎么来就怎么来的。不过这里以教学为目的，通常会按照下面的顺序进行类的编写：</p>
<ul>
<li>搞清楚所编写的类计划用来做什么</li>
<li>列出其实例变量与方法</li>
<li>编写方法的 <strong>预代码（prepcode）</strong></li>
<li>编写方法的 <strong>测试代码（test code）</strong></li>
<li>将类进行 <strong>部署</strong>（<strong>Implement</strong> the class）</li>
<li>对方法进行 <strong>测试</strong>（<strong>Test</strong> the methods）</li>
<li>进行必要的 <strong>调试</strong> 和 <strong>再部署</strong> （<strong>Debug</strong> and <strong>reimplement</strong> as needed）</li>
<li>邀请真实用户，对应用进行测试</li>
</ul>
<p><strong>每个类都要编写的三种代码</strong></p>
<ul>
<li>
<p>预编码，prep code
是一致伪代码（pseudocode）, 用于理清逻辑，而不用面对语法上的压力</p>
</li>
<li>
<p>测试代码
对真实代码进行测试，以验证真实代码是在正确工作</p>
</li>
<li>
<p>真实代码
类的具体实现。这里才是编写Java代码的地方</p>
</li>
</ul>
<h2 id="什么是预代码伪代码prepcode"><a class="header" href="#什么是预代码伪代码prepcode">什么是预代码/伪代码（prepcode）</a></h2>
<p>是类的真实Java代码与其自然语言描述之间的中介。大多数预代码包含三个部分：实例变量的声明、方法的声明和方法的逻辑。预代码最重要的部分，就是方法的逻辑，因为方法的逻辑，对要发生什么进行了定义。</p>
<h2 id="编写方法的实现writing-the-method-implementations"><a class="header" href="#编写方法的实现writing-the-method-implementations">编写方法的实现（Writing the method implementations）</a></h2>
<p>在编写方法之前，先要编写方法的测试代码。注意，这里是先于方法本身，编写方法的测试代码的。</p>
<p>首先编写测试代码的做法，是极限编程（Extreme Programming, XP）的一种实践。采取这种方法，可以令到写代码更为容易和快速。当然并不是说非得要采用极限编程的方法，但真的喜欢首先编写测试代码的部分，同时极限编程听起来也很酷。</p>
<h2 id="关于极限编程"><a class="header" href="#关于极限编程">关于极限编程</a></h2>
<p>极限编程，作为软件开发方法论领域的新兴成员，被许多程序员认为是“程序员正确的工作方式”，极限编程出现在1990年代，已经被许多公司所采行。XP的核心在于，软件用户在提出新的需求时，可以很快实现。</p>
<p>XP基于一套验证过的实践方法，这些方法应该组合运用。不过业者通常只选取其中一些方法，同时仅采行XP规则中的一部分。这些实践方法包含下面这些：</p>
<ul>
<li>高频发布小版本（Make small, but frequent, releases）</li>
<li>以迭代周期方式开发（Develop in interation cycles）</li>
<li>绝不把不包含在软件规格中的功能/特性，加入到项目中去（不管有多想要以“为将来考虑”的原因，加入某项功能，Don't put in anything that's not in the spec(no matter how tempted you are to put int functionality &quot;for the future&quot;)）</li>
<li>首先编写测试代码</li>
<li>不设苛刻时间表；不加班（No killer schedules; work regular hours）</li>
<li>一有机会就搞重构（提升代码质量，Refactor(improve the code) whenever and wherever you notice the opportunity）</li>
<li>根据小版本，设置合理可行的时间表（Set realistic schedules, based around small releases)</li>
<li>保持代码简单（Keep it simple）</li>
<li>结对编程，并定期调换人员岗位，从而令到每个人都对代码的各个部分有所了解（Program in pairs, and move ppl around so that everybody knows pretty much everything about the code）</li>
</ul>
<h2 id="n-和-n-的不同"><a class="header" href="#n-和-n-的不同"><code>++n</code> 和 <code>n++</code> 的不同</a></h2>
<p><code>++n</code> increments the value and returns the new one. <code>n++</code> increments the value and returns the old one. Thus, <code>n++</code> requires extra storage, as it has to keep track of the old value so it can return it after doing the increment.</p>
<h2 id="增强版的for-循环"><a class="header" href="#增强版的for-循环">增强版的<code>for</code> 循环</a></h2>
<pre><code class="language-java">for (String name: nameArray) {...}
</code></pre>
<p>上面的语句，用人话讲就是：将<code>nameArray</code> 里的每个元素，赋值给 <code>name</code> 变量，并运行循环体。</p>
<p>编译器是这样理解上面的语句的：</p>
<ul>
<li>创建一个名为 <code>name</code> 的字符串变量，并将其置为 <code>null</code>（<code>null</code>也是一个值）</li>
<li>将 <code>nameArray</code> 的第一个值赋给 <code>name</code></li>
<li>运行循环体（由花括弧(<code>{}</code>)包围起来的代码块）</li>
<li>将 <code>nameArray</code>中的下一个值赋给 <code>name</code></li>
<li>重复这个过程，直到数组中最后一个元素为止</li>
</ul>
<p><strong>循环条件的第一部分：循环变量的声明（Part One: iteration variable declaration）</strong></p>
<p>用此部分来声明和初始化一个在循环体中用到的变量。对于循环的每次迭代，该变量都将保存一个数组中的不同元素。此变量的类型，必须与数组中的各个元素的类型兼容！举例来说，就是不能声明一个 <code>int</code> 的迭代变量，与 <code>String[]</code> 的数组来一起使用。</p>
<p><strong>循环条件的第二部分：目标数据集（Part Two: the actual collection）</strong></p>
<p>这必须是到某个数组（<code>array</code>）或其他集合（<code>collection</code>）的引用。注意，这里对于其他非数组类别的数据集，也是使用的。这在后续章节会看到。</p>
<h2 id="把一个-string-转换成-int"><a class="header" href="#把一个-string-转换成-int">把一个 <code>String</code> 转换成 <code>int</code></a></h2>
<pre><code class="language-java">String num = &quot;2&quot;;
int x = 2;
if (x == num) //horrible explosion!
</code></pre>
<p>这样写代码，编译器就会觉得你是个傻子！</p>
<pre><code class="language-bash">[ERROR] xxx.java[x,y] bad operand types for binary operator '=='
[ERROR]   first type:  int
[ERROR]   second type: java.lang.String
</code></pre>
<p>对于语句：</p>
<pre><code class="language-java">int guess = Integer.parseInt(stringGuess);
</code></pre>
<p>其中，<code>Integer</code>是Java语言自带的一个类；<code>parseInt</code>则是类<code>Integer</code>的一个方法，他知道怎样将某个字符串或其他类型的变量，解析为该变量所表示的 <code>int</code>数值。</p>
<pre><code class="language-java">int n = 0;

try {
    n = Integer.parseInt(&quot;a&quot;);
    System.out.format(&quot;\&quot;a\&quot; = %s\n&quot;, n);
} catch (Exception e) {
    System.out.println(e);
}
</code></pre>
<p>这段代码，会报错错误：</p>
<pre><code class="language-bash">java.lang.NumberFormatException: For input string: &quot;a&quot;
</code></pre>
<p>说明 <code>Integer.parseInt</code> 方法，是不能将除 <code>0</code> 到 <code>9</code> 字符的其他变量，解析为整数的。</p>
<pre><code class="language-java">int n = 0;

try {
    n = Integer.parseInt(&quot;1024&quot;);
    System.out.format(&quot;\&quot;1024\&quot; = %s\n&quot;, n);
} catch (Exception e) {
    System.out.println(e);
}
</code></pre>
<p>这段代码的输出是：</p>
<pre><code class="language-bash">&quot;1024&quot; = 1024
</code></pre>
<h2 id="对原生变量的修剪casting-primitives"><a class="header" href="#对原生变量的修剪casting-primitives">对原生变量的修剪（Casting primitives）</a></h2>
<p>在第三章中，讨论了不同原生类型的大小，以及为何不能把大的变量硬塞进小的变量里。</p>
<pre><code class="language-java">long y = 42;
int x = y; // 不会被编译
</code></pre>
<p>会报错：</p>
<pre><code class="language-bash">java.lang.Error: Unresolved compilation problem:
        Type mismatch: cannot convert from long to int
</code></pre>
<p><code>long</code> 是要比 <code>int</code> 大的（占用的数据位要多），同时编译器也不确定那个 <code>long</code> 的变量在哪里。为了强制编译器将一个较大的原生类型变量，塞进另一个较小的原生变量中，就要使用 <code>cast</code> 运算符。</p>
<pre><code class="language-java">long y = 42;
int x = (int) y;
</code></pre>
<p>放入了这个 <code>cast</code> 运算符后，就告诉了编译器，拿到 <code>y</code> 的值，将其修剪到 <code>int</code> 的大小，然后将 <code>x</code> 设置为剩下的部分。若 <code>y</code> 的值要比 <code>x</code> 的最大值更大，那么剩下的就会是一个奇怪的值（但可以计算出来）。比如：</p>
<pre><code class="language-java">long y = 40002;
// 40002 以及超出了短整型的最大值
short x = (int) y; // x 现在等于 -25534!
</code></pre>
<blockquote>
<p>这是因为，十进制的 <code>40002</code> 的有符号二进制形式为 <code>00000000000000001001110001000010</code>, 保留后 16 位就是 <code>1001110001000010</code>, 按照有符号短整数来看就是 <code>-25534</code>。</p>
</blockquote>
<p>对于浮点数来说，比如只想要某个浮点数的整数部分时：</p>
<pre><code class="language-java">float f = 3.14f;
int x = (int) f; // x 将等于 3
</code></pre>
<blockquote>
<p>这里还比较一下 <code>cast</code> 运算符与 <code>Math.round</code>方法。</p>
</blockquote>
<pre><code class="language-bash">float f = 3.14f;        (int) f = 3     Math.round(f) = 3
float p = 3.8f;         (int) p = 3     Math.round(p) = 4
</code></pre>
<blockquote>
<p>说明 <code>cast</code> 运算符只是截取整数部分，而 <code>Math.round</code> 方法则会做四舍五入。</p>
</blockquote>
<h2 id="一个有趣的类"><a class="header" href="#一个有趣的类">一个“有趣的类”</a></h2>
<pre><code class="language-java">public class Output {
    public static void main (String[] args) {
        Output o = new Output ();
        o.go ();
    }

    void go () {
        int y = 7;
        for (int x = 1; x &lt; 8; x++) {
            y++;
            if (x &gt; 4) {
                System.out.format(&quot;%s &quot;, ++y);
            }
            if (y &gt; 14) {
                System.out.format(&quot; x = %s&quot;, x);
                break;
            }
        }
    }
}
</code></pre>
<blockquote>
<p>参考：</p>
</blockquote>
<blockquote>
<ul>
<li><a href="https://blog.csdn.net/qq_38374633/article/details/103977097">在类中创建自己的对象</a></li>
<li><a href="https://stackoverflow.com/questions/18241281/can-a-class-instantiate-itself">Can a Class instantiate itself?</a></li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="了解java-api使用java的库"><a class="header" href="#了解java-api使用java的库">了解Java API：使用Java的库</a></h1>
<p>Java语言本身，就带有多达数百个的预构建类。若掌握了如何从 Java 库，也就是常说的 <strong>Java API</strong>中找到你所需要的功能，那么就不必去重新发明轮子了（You don't have to reinvent the wheel if you know how to find what you need in the Java library, known as the <strong>Java API</strong>）。<em>还有更好的事情等着你去做</em>。若要编写代码，也只是要去编写对于你的应用来说，真正特有的代码。你知道那些下午5点就下班，早上10点都还没到公司的程序员吗？<strong>他们就是善于使用 Java API</strong>。Java的核心库，有着大量的类，就等着你去使用，可以像使用砖块一样，从大量预构建的代码，组装出你自己的程序。本书中用到的写好Java程序示例，就是无需从头再编写的代码，但还是必须输入到你的程序中去。而Java API则是些甚至不用输入的代码。你只需要学会怎样去使用他们就可以了。</p>
<p>Java标准版带有数百个预构建类（除非使用的是针对小型设备的微型版本，那么Java标准版就是你手头的版本，The Java Standard Edition，which is what you have unless you're working on the Micro Edition for small devices and believe me, you'd know）。他们就和本书中这些编写好的代码一样，只是这些内建的类，时已经编译好的。</p>
<p><strong>这就是说这些内建类无需再次输入了</strong> 。直接使用他们就好。</p>
<p><code>ArrayList</code> 是Java库中无数内建类之一。你可以在自己的代码中，如同是你自己编写的<code>ArrayList</code>一样使用他。</p>
<p><em>我该怎么来知道，Java API里有些什么呢？</em></p>
<p>这正是如何成为一名正式的Java程序员的关键所在。这并不是说在构建软件时尽可能的懒，而是说在有人已经完成了这门语言中大多数最重要的部分后，你可以节省那么多的时间，而你只需要花点时间去了解这些API，去完成你的软件中有趣的部分即可。</p>
<p>有点离题了，这个问题的答案，往短了说，就是你得花点时间来学习，在Java核心API中有些什么。往大了说，就是在完成本章学习后，就知道该怎么去获知Java API中有些什么了。</p>
<p><em>怎么才知道我要用到Java API的某个类，该如何从“要完成某个功能”过渡到“找到实现某个功能的方法”？</em></p>
<p>你已经发现了问题的本质了。在学完本书后，你将会对Java这门语言有很好的掌握。之后你的学习曲线，就是了解如何从找到问题，到通过编写尽可能少的代码，来得到问题的解决方案了。随后将讨论这个问题。</p>
<h2 id="arraylist-与-array-的不同"><a class="header" href="#arraylist-与-array-的不同"><code>ArrayList</code> 与 <code>array</code> 的不同</a></h2>
<p><code>ArrayList</code> 是一个对象。<code>array</code>也是对象，与其他对象一样，也是存活在内存堆（heap）上的。但 <code>array</code>仍然只是<code>array</code>，不会是<code>ArrayList</code>，只是个冒牌货的。对象是同时有 <strong>状态</strong> 和 <strong>行为</strong> 的（state and behavior）。<code>array</code>就没有可调用的方法。Java 中的 <code>array</code> 一旦初始化，就再也不能追加或移除其中的元素了。<code>ArrayList</code>作为头等对象，就有着移除其中元素的能力，可以动态地改变大小。<code>ArrayList</code>有着极大的灵活性。<strong>不可以直接将原生类型变量放入到 <code>ArrayList</code>中</strong> 。但将原生类型变量，封装到一个原生类型封装器类中之后，就可以将原生变量放入到 <code>ArrayList</code>中了（You can put a primitives in an <code>ArrayList</code>, as long as it's wrapped in a primitive wrapper class）。自 Java 5.0 开始，原生类型变量的封装（以及在取出原生类型变量时的解封装），就已经是自动的了。可以确定的说，在运用由原生变量构成的 <code>ArrayList</code>时，可能比使用<code>array</code>还要快，因为所有的原生变量封装与解封装，都是........话又说回来，如今谁还会用到原生类型变量呢？</p>
<p>对于 <code>ArrayList</code>，只是在操作一个普通的 <code>ArrayList</code> 类型的对象，只是调用普通对象上的方法，使用普通对象上的 <code>.</code> 运算符。而对于一个 <code>array</code>，就要使用 <em>特殊的数组语法</em> （比如 <code>myList[0] = foo</code>），这些语法只能在数组上使用，其他地方都用不到。就算数组也是对象，但数组是存在于他自己的世界中，你无法调用他上面的任何方法。可以访问到的，也只是他唯一的实例变量 <code>length</code>。</p>
<ol>
<li>
<p>普通的老式 <code>array</code>，在创建出来时就必须知道大小。</p>
<p>但对于 <code>ArrayList</code> 来说，就只需要生成一个类型为 <code>ArrayList</code>的对象就行。因为随着有对象加入或移除，<code>ArrayList</code>对象的大小会增加或收缩。</p>
<pre><code class="language-java">String[] a = new String[2];
ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt; ();
</code></pre>
</li>
<li>
<p>要将某个对象放入到常规数组中，就必须为其指定一个特定位置。</p>
<p>（而且这个位置，必须要是从 <code>0</code> 到小于该数组长度的一个值。）</p>
<pre><code class="language-java">myList[1] = b;
</code></pre>
<p>在指定的索引位置超出了该数组的边界时（比如对于一个声明了大小为2的数组，在尝试将某个值赋给索引3时），运行时就会报错（<code>java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</code>）。但对于 <code>ArrayList</code>，就可以使用 <code>add(anInt, anObject)</code> 方法，或是只写 <code>add(anObject)</code>，就可以为新加入的对象，分配到空间。</p>
<pre><code class="language-java">myList.add(b);
</code></pre>
</li>
<li>
<p>数组所使用的语法，在Java中的其他任何地方都不会用到。</p>
<p>但 <code>ArrayList</code> 就是普通的 Java 对象，因此没有特殊的语法。</p>
<pre><code class="language-java">myList[1];
</code></pre>
</li>
<li>
<p>自 Java 5.0 开始，<code>ArrayList</code> 就已经是参数化的了（parameterized）。</p>
<pre><code class="language-java">ArrayList&lt;String&gt;
</code></pre>
<p>这里的在尖括号中的 <code>String</code> 是一个 “类型参数”（<code>type parameter</code>）。 <code>ArrayList&lt;String&gt;</code> 的意思是，“一个字符串清单”，以示与 <code>ArrayList&lt;Dog&gt;</code> 表示“一个 Dog 的清单”的不同。</p>
<p>如今使用 <code>&lt;type&gt;</code> 这样的语法，就可以声明并创建 <code>ArrayList</code> 变量所能保存的对象类型。在“集合”章节将会仔细审视 <code>ArrayList</code> 中的参数化类型语法。现在只需要知道，这种语法是一种强制编译器，只允许特定类型的对象，放入到 <code>ArrayList</code> 中的办法。</p>
</li>
</ol>
<h2 id="构造器函数the-constructor-function"><a class="header" href="#构造器函数the-constructor-function">构造器函数（The <code>constructor</code> function）</a></h2>
<p>构造器函数是一个与类名称同名的特殊函数，在某个对象创建时运行，返回的是其所创建的对象（非 <code>void</code>），故构造器函数如下面这样：</p>
<pre><code class="language-java">public class DotCom {
...

public DotCom (...) {
    ...
}

...
}
</code></pre>
<h2 id="超级强大的布尔表达式supper-powerful-boolean-expressions"><a class="header" href="#超级强大的布尔表达式supper-powerful-boolean-expressions">超级强大的布尔表达式（Supper Powerful Boolean Expressions）</a></h2>
<p>在 <code>DotComBust</code> 类中的循环或 <code>if</code> 条件测试里，就已经用到了布尔表达式，这些布尔表达式是很简单的。在后续代码中，将用到更加强大的布尔表达式。</p>
<h3 id="与及或运算符"><a class="header" href="#与及或运算符">“与”及“或”运算符（<code>&amp;&amp;</code>、<code>||</code>）</a></h3>
<p>假设我写一个 <code>chooseCamera()</code> 方法，有很多如何去选择一台相机的规则。也许要选择价钱在 $50 到 $1000 的相机，在某种情形下，要更精细地去限定价格范围。可能会这样：</p>
<ul>
<li>“加入价钱在 $300 到 $400, 那么就选择 X”:</li>
</ul>
<pre><code class="language-java">if (price &gt;= 300 &amp;&amp; price &lt; 400) {
    camera = &quot;X&quot;;
}
</code></pre>
<ul>
<li>在有10个相机品牌可供选择时，有一些适用于品牌清单中少数几个的规则：</li>
</ul>
<pre><code class="language-java">if (brand.equals(&quot;A&quot;) || brand.equals(&quot;B&quot;)) {
    // 仅针对品牌 A 和 B 进行某些操作
}
</code></pre>
<p>布尔表达式可以时相当大且复杂的：</p>
<pre><code class="language-java">if ((zoomType.equals(&quot;optical&quot;) &amp;&amp;
    (zoomDegree &gt;= 3 &amp;&amp; zoomDegree &lt;= 8)) ||
    (zoomType.equals(&quot;digital&quot;) &amp;&amp; 
    (zoomDegree &gt;= 5 &amp;&amp; zoomDegree &lt;= 12))) {
        // 对这种变焦，执行相应操作
}
</code></pre>
<p>若要真的熟知布尔表达式，就要了解这些运算符的优先级（the precedence of these operators）。除了深入了解他们的优先级，还可以使用括号，来令到代码中的复杂布尔表达式更加清晰明了。</p>
<h3 id="不等于-和-"><a class="header" href="#不等于-和-">不等于（<code>!=</code> 和 <code>!</code>）</a></h3>
<p>假设有这样的一个逻辑：“10个相机型号中，除开其中的一个型号”：</p>
<pre><code class="language-java">if (model != 2000) {
    // 针对型号不是 2000 的相机，执行一些操作
}
</code></pre>
<p>或者对字符串等一些对象进行比较：</p>
<pre><code class="language-java">if (!brand.equals(&quot;X&quot;)) {
    // 对品牌不是 X 的相机进行一些操作
}
</code></pre>
<h3 id="短路运算符short-circuit-operators-"><a class="header" href="#短路运算符short-circuit-operators-">短路运算符（Short circuit operators, <code>&amp;&amp;</code>、<code>||</code>）</a></h3>
<p>对于 <code>&amp;&amp;</code> 运算符，是要其两边都是 <code>true</code> 时，表达式才是 <code>true</code> 的。所以只要虚拟机看到其左边的值为 <code>false</code>，就不会在计算运算符右边的表达式了。所以他叫做短路运算符。</p>
<p>同样对于 <code>||</code> 也是这样的，只要 JVM 看到他的左边是 <code>true</code>，会得出整个表达式就是 <code>true</code>，就不会再计算右边的值了。</p>
<p>说这个有什么用呢？比如不确定某个引用变量是否已经被赋值了某个对象，就去调用某个使用了这个空引用变量（null reference variable, 也就是，尚未将对象赋值给该引用变量）的方法时，就会得到一个 <code>NullPointerException</code>的错误代码。那么就可以这样写：</p>
<pre><code class="language-java">if (refVar != null &amp;&amp; refVar.isValidType()) {
    // 执行“已有某种类型”下的操作
}
</code></pre>
<h3 id="非短路运算符non-short-circuit-operators-"><a class="header" href="#非短路运算符non-short-circuit-operators-">非短路运算符（Non Short Circuit Operators, <code>&amp;</code>、<code>|</code>）</a></h3>
<p>在布尔表达式中使用 <code>&amp;</code> 与 <code>|</code> 运算符时，他们的表现，就跟他们的同伴 <code>&amp;&amp;</code> 与 <code>||</code> 相似，不同之处在于，这两个运算符，是要强制JVM对运算符的两边，都要进行检查。通常情况下，<code>&amp;</code> 与 <code>|</code> 是用在不同的情形下的，比如对二进制位的操作。</p>
<h2 id="使用库java-api"><a class="header" href="#使用库java-api">使用库（Java API）</a></h2>
<p>由于使用了 <code>ArrayList</code>，前面完成了 <code>DotComBust</code> 游戏。现在就是学习怎么用好 Java 库的时间了。</p>
<p><strong>在 Java API 中，类是以包的形式分组的（In the Java API, classes are grouped into packages）</strong>。</p>
<p><img src="images/Ch06_01.png" alt="在 Java API 中，类被分组为各种包" /></p>
<p><em>图 1 - 在 Java API 中，类被分组为各种包</em></p>
<p><strong>要使用API中的某个类，就要知道他在哪个包里头</strong>。</p>
<p>Java 库中的每一个类，都是属于某个包的。那个包有个名字，比如 <code>javax.swing</code> （一个有着一些 Swing GUI 类的包）。<code>ArrayList</code>则是在名为 <code>java.util</code>的包中，这个包有一堆的 <em>工具（utility）</em> 类。在第17章，将会学到更多的有关包的知识，包括如何将自己编写的类，放入自己组织的包中。</p>
<p>在代码中使用API的类，是很简单的。只需将那个类当成自己编写的，自己编译的，就在那里等着使用就可以了。有一个不同点在于，在代码中的一些地方，需要用库类的 <em>完整</em> 名字来表示，完整名字就是，包的名字 + 类的名字。</p>
<p>就算对这个不了解，<em>实际上很早就用到了来自某个包的类</em>。<code>System</code>（<code>System.out.println</code>），<code>String</code>，以及 <code>Math</code> （<code>Math.random()</code>），这些类，都是属于 <code>java.lang</code> 包的。</p>
<p><strong>对于在代码中要用到的类，就必须知道他的完整名字</strong>。</p>
<p><code>ArrayList</code> 并不是 <code>ArrayList</code> 的完整名字，就如同 <code>Kathy</code> 不是一个全名一样（除非像是 Madonna 或 Cher 这样的人）。<code>ArrayList</code>的全名实际上是：</p>
<pre><code class="language-java">java.util.ArrayList
</code></pre>
<p>其中 <code>java.util</code>是包的名字，<code>ArrayList</code>是类的名字。</p>
<p><strong>必须告诉 Java，你要使用哪个 <code>ArrayList</code></strong>，有两种做法：</p>
<ul>
<li>
<p>导入（<code>IMPORT</code>）</p>
<p>在源代码文件的顶部，放上一个导入语句：</p>
</li>
</ul>
<pre><code class="language-java">import java.util.ArrayList;
public class MyClass {...}
</code></pre>
<ul>
<li>
<p>手动输入（TYPE）</p>
<p>在代码中使用到 <code>ArrayList</code> 的各处，输入完整的名字。</p>
<p>在声明或初始化某个 <code>ArrayList</code> 变量时：</p>
</li>
</ul>
<pre><code class="language-java">java.util.ArrayList&lt;Dog&gt; list = new java.util.ArrayList&lt;Dog&gt; ();
</code></pre>
<p>在使用 <code>ArrayList</code> 变量作为参数类型时：</p>
<pre><code class="language-java">public void go (java.util.ArrayList&lt;Dog&gt; list) {...}
</code></pre>
<p>在将 <code>ArrayList</code> 作为返回值的类型时：</p>
<pre><code class="language-java">public java.util.ArrayList&lt;Dog&gt; foo () {...}
</code></pre>
<p><em>为什么这些库类，都必须有一个全名呢？难道这就是Java包的目的吗？</em></p>
<p>包的重要性，有三个方面。首先，包有助于某个项目或库的良好组织。相比于有着可怕的一大堆类文件，使用包就可以将众多的类文件，以不同目的（比如GUI的、数据结构的，或者数据库方面的等等），组织成包。</p>
<p>其次，包的使用，可以带来名称上的范围限制，从而有助于防止冲突的发生。比如你和公司的其他12名程序员，都以同样的名字编写类文件时。再比如你自己编写了一个名为 <code>Set</code> 的类文件，其他人（包括 Java 的 API）也有同名的类文件，那么就要需要一种告诉 JVM，到底要使用那个 <code>Set</code> 类的机制。</p>
<p>第三，包在一定程度上提供了安全性。因为可以对所编写的代码做限制，从而只有同一包里的其他类，才能访问到这个包。这一点在第17章将会讲到。</p>
<p>Java语言有一个命名约定，通常可以阻止冲突的发生。</p>
<p><strong>包名字中 <code>x</code> 表示什么意思</strong></p>
<p>在第一版和第二版的 Java 中（<code>1.02</code> 和 <code>1.1</code>），与 Java 语言一起发布的类（也就是标准库），都是以 <code>java</code> 打头的。这些都是 <code>java.lang</code> 的，也就是不必加以导入的。同时还有 <code>java.net</code>、<code>java.io</code>、<code>java.util</code>（尽管那个时候还没有 <code>ArrayList</code>），以及一些其他的类库，包括保存GUI相关类的 <code>java.awt</code>包。</p>
<p>逐渐的，标准库中未包含的其他包逐一出现。这些类也就是我们所说的 <strong>扩展（extensions）</strong>，这些扩展又有两种： <em>标准（standard）</em> 与 <em>非标准（not standard）</em> 扩展。标准扩展是那些 Sun 公司认为的官方扩展，他们与实验性扩展、早期版本或者说 beta 版等，或许永远也不会投入使用的包，有所不同。</p>
<p>按照惯例，标准扩展都是在原本作为开头的 <code>java</code> 之后，追加了 <code>x</code> 打头的。而所有标准扩展的开创者，就是 Swing 库。这个库包含了若干个包，这些包都是以 <code>javax.swing</code> 开头的。</p>
<p>而某些标准扩展，就有机会得到提升，从而成为头等的、Java自带的、标准的即开即用的库文件包。从 Java 1.2 开始，Swing就享受到了这样的待遇。</p>
<p>“真不赖” ，所有人都这样想，“往后所有装了Java的人就都有了 Swing 类文件了，就再也不需要给我们的终端用户去安装这个类了”。</p>
<p>但麻烦随之而来，在这些包得到提升之后，理所当然他们就不得不以 <code>java</code> 打头，而再也不是 <code>javax</code>打头了。所有人都知道标准库都不带有 <code>x</code>，而只有扩展才有。那么，就在 <code>1.2</code> 版本终结的时候，Sun公司就修改了这些包的名字，把其中的 <code>x</code> 删除掉了（以及其他的一些改变）。这个时候很多即将印刷以及在书店售卖的Java书，将 Swing 代码以新名字加以介绍。命名约定得到遵守。在Java世界里万事大吉。</p>
<p>但对于超过 20k 的开发者来说，他们意识到这样简单的名字改变，却带来了灾难！他们的所有用到 Swing 的代码，都不得不进行修改！多么可怕！想想那些以 <code>javax</code> 开头的代码...</p>
<p>在最后时刻，伴随着希望变得渺茫，他们绝望了，这些开发者说服了 Sun 公司，去“打破惯例，拯救他们的代码”。剩下的事情就成了历史。因此当你看到在库中以 <code>javax</code> 打头的某个包，就应该知道这个包是以某个扩展诞生，随后获得了提升（进入到标准库中）。</p>
<h2 id="知识点"><a class="header" href="#知识点">知识点</a></h2>
<ul>
<li><code>ArrayList</code> 是 Java API 中的一个类</li>
<li>使用 <code>add()</code> 方法，往 <code>ArrayList</code> 中放入某些东西</li>
<li>要从<code>ArrayList</code>中移除某物，使用 <code>remove()</code> 方法</li>
<li>使用 <code>indexOf()</code>方法，来确定某对象是否在 <code>ArrayList</code> 中</li>
<li>要确定某个 <code>ArrayList</code> 是否为空，使用 <code>isEmpty()</code> 方法</li>
<li>使用 <code>size()</code> 方法，来获取某个 <code>ArrayList</code> 的大小（元素个数）</li>
<li>对于常规的老式数组，要获取其长度（length, 元素个数），使用的是其变量<code>length</code></li>
<li><code>ArrayList</code> 引用变量的大小，可以根据需要动态的改变。在添加了对象后，就会变大；在移除对象后，相应地会变小</li>
<li>在声明<code>ArrayList</code>引用变量的数组类型时，使用的是 <strong>类型参数（type parameter）</strong>，也就是在尖括号中的一个类型名称。比如，<code>ArrayList&lt;Button&gt;</code> 意思是这个 <code>ArrayList</code> 将只能保存类型为 <code>Button</code> 的对象（或者 <code>Button</code> 的子类，后续章节会学习相关的内容）。</li>
<li>尽管 <code>ArrayList</code> 保存的是对象而非原生变量，但编译器会自动地对原生变量进行封装（ <strong>wrap</strong>, 并在从 <code>ArrayList</code> 中取出原生变量时，进行解封装， <strong>unwrap</strong>），使其成为一个对象，从而放入到 <code>ArrayList</code> 中的，就是封装后的对象，而不在时原来的原生变量了。</li>
<li>类是以包的形式进行组织的。</li>
<li>类有着由其所属包的名字，和类本身名字，组合而成的全名。类 <code>ArrayList</code> 实际上是 <code>java.util.ArrayList</code></li>
<li>要使用除 <code>java.lang</code> 之外的其他包中的某个类，就必须告诉 Java 那个类的全名</li>
<li>要么在源代码文件的顶部使用一条导入语句，要么就在代码中所有要用到类的地方，输入这个类的全名</li>
</ul>
<h2 id="关于-import-语句"><a class="header" href="#关于-import-语句">关于 <code>import</code> 语句</a></h2>
<p><code>import</code> 与 C 语言中的 <code>include</code> 不同。因此 <code>import</code> 的使用不会令到类变得更大，同时也不会将所导入的类或包，编译到自己的代码中去。<code>import</code> 的使用，是从大量的敲代码中拯救你的。无需担心过多地使用 <code>import</code> 会导致代码臃肿或变慢。<code>import</code>就只是一种你让Java知道某个类的全名的方式而已。</p>
<p><strong>为什么不需要导入 <code>String</code> 或 <code>System</code> 类呢？</strong></p>
<p>那是因为 <code>java.lang</code> 是特殊的 <strong>预导入（pre-imported）</strong> 包。因为在 <code>java.lang</code>中的那些类是相当基础的类，因此就不必使用他们的全名。这样的也就只有两个： <code>java.lang.String</code> 和 <code>java.lang.System</code>，Java 很清楚可以在哪里找到他们。</p>
<p><strong>必须把自己编写的类也放入Java包里吗？怎样才能放入包里，可以这样做吗？</strong></p>
<p>在生产中，是应该把自己编写的类文件，放入到包中的。在第17章会讲到这个问题。</p>
<h2 id="牢牢记住"><a class="header" href="#牢牢记住">牢牢记住</a></h2>
<pre><code class="language-console">Roses are red,
apples are ripe,
if you don't import
you'll just have to type
</code></pre>
<p>在没有使用导入语句时，除了那些 <code>java.lang</code>包中的类之外，就 <strong>必须告诉Java所用到的每个类的全名</strong>。在源代码文件顶部，使用一个类或包的<code>import</code>导入语句，是一种简便方法。否则，就必须在使用到那个类或包的所有地方，都敲入他的全名！</p>
<h2 id="使用-api-的方法"><a class="header" href="#使用-api-的方法">使用 API 的方法</a></h2>
<p>两个问题：</p>
<ol>
<li>在库中有哪些类文件？</li>
<li>在找到某个类之后，怎样才能知道他是用来做什么的？</li>
</ol>
<p>有两个途径：</p>
<ol>
<li>
<p>翻书</p>
<p>一本 Java 参考书，就是去发现Java库里有些什么的最好办法。</p>
</li>
<li>
<p>查看线上的 HTML API 文档</p>
<p>Java 本身就有着一套良好的线上文档，名字就叫 Java API。这套文档又是另外一套更大的名为 Java 5 标准版文档的一部分，这些线上文档还必须得去单独下载；这些文档不是和 Java 程序一起提供的。</p>
<p>这些API文档，在要进一步了解某个类及其方法时，最好的参考资料。比如在查阅参考书时，在 <code>java.util</code>包中发现一个名为 <code>Calendar</code> 的类时，参考书只能告诉你这个类的有限的、仅能让你明白这个类正是你要用到的一点点内容，在你需要了解更多的有关这个类的信息时，就可以在线上文档里找到。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="继承与多态在对象村里过得更好"><a class="header" href="#继承与多态在对象村里过得更好">继承与多态：在对象村里过得更好</a></h1>
<p><strong>打心底里就要给你的程式谋划未来</strong>。如果有某种可以休假更多的写Java代码的方法，那这种方法价值几何呢？如果其他人可以轻易地对你写的代码进行扩展，同时还可以编写出，能够应对那些令人厌烦的最后一分钟规格变更的灵活的代码来，对于这样的方法论，你会感兴趣吗？今天就是你的幸运日，只需要花3个小时，就可以学到这有用的方法。在多态课程，将学到“改良类设计的5步法”、“多态3窍门”，以及“8招让你编写灵活代码”。还有一节额外的“运用继承的4个诀窍”课程送给你。不要犹豫，不要迟疑，掌握继承与多态，将带给你程序设计的自由，让你获得灵活编程的好处。从今天开始，就要着重于抽象（abstraction）这个话题了。</p>
<p><img src="images/Ch07_01.png" alt="OO 继承的运作方式" /></p>
<p><em>图 1 - 继承的原理</em></p>
<p>可以读作：“ <strong>正方形继承自形状</strong> ”，“ <strong>圆形继承自形状</strong> ” 等等。这里将 <code>rotate()</code> 与 <code>playSound()</code> 从其他形状中移除了，那么现在需要维护的，就只有一个拷贝了。</p>
<p>这里的 <code>Shape</code> 类，叫做其他四个类的 <strong>超类（superclass）</strong>。其他四个类就是 <code>Shape</code> 的子类。子类继承着超类的方法。换句话说， <em>如果<code>Shape</code>类有着某项功能，那么他的子类将自动获得同样的功能</em>。</p>
<h2 id="那么对于-amoeba-的-rotate-又该怎么办呢"><a class="header" href="#那么对于-amoeba-的-rotate-又该怎么办呢">那么对于 <code>Amoeba</code> 的 <code>rotate()</code> 又该怎么办呢？</a></h2>
<blockquote>
<p>（Amoeba, [əˈmibə]，阿米巴虫）</p>
</blockquote>
<p>对于有着完全不同的 <code>rotate</code> 与 <code>playSound</code> 行为的 <code>Amoeba</code> 形状来说，在从 <code>Shape</code> 类继承的情况下，该怎样才能有不同的行为呢？</p>
<p>这就是面向对象的最后一步，<code>Amoeba</code> 类对 <code>Shape</code> 类的方法，进行 <strong>重写（override）</strong>。如此以来，在运行时，JVM就准确地知道，在其他代码调用到 <code>Amoeba</code> 去旋转时，该执行哪一个 <code>rotate()</code> 方法了。</p>
<p><img src="images/Ch07_02.png" alt="重写方法" /></p>
<p><em>图 2 - 重写方法</em></p>
<h2 id="brain-power"><a class="header" href="#brain-power">BRAIN POWER</a></h2>
<p>对于家猫与老虎，以继承架构，该怎么来表示？该把家猫看成是老虎的特殊版本吗？他们中到底哪一个应该是子类，哪个应该是超类呢？又或者说他们都是另一个类的子类呢？</p>
<p>怎样来设计一个继承架构？哪些方法需要重写？</p>
<p>在翻开下一页之前，请思考一下。</p>
<h2 id="掌握继承"><a class="header" href="#掌握继承">掌握继承</a></h2>
<p><strong>Understanding Inheritance</strong></p>
<p>在设计继承时，是将共同的代码，放在一个类中，同时告诉其他更为特定的类，这个通用的（更为抽象的）类，是他们的超类。在某个类从其他类进行继承时，那么就是 <strong>子类从超类进行继承</strong>。</p>
<p>在 Java语言中，有着 <strong>子类对超类进行扩展</strong>。继承关系（An inheritance relationship）的意思是，子类对超类成员的继承。在提及 “类成员” 时，意思就是实例变量与方法。</p>
<p>比如，<code>PantherMan</code> 是 <code>SuperHero</code>的一个子类，<code>PantherMan</code> 类就自动继承了对于所有超级英雄来说，共同的实例变量，包括 <code>suit</code>、<code>tights</code>、<code>specialPower</code>、<code>useSpecialPower()</code>等等。同时 <code>PantherMan</code>  <strong>子类还可以加入自己新的方法和实例变量</strong>。同时他还 <strong>可以对其继承自超类</strong> <code>SuperHero</code> <strong>的方法进行重写</strong>。</p>
<p>相比 <code>PantherMan</code>, <code>FriedEggMan</code>就不需要任何独特的行为，因此他就没有重写任何的方法。此时<code>SuperHero</code>中的方法与实例变量，都还是有效的。</p>
<p>但 <code>PantherMan</code> 则对他的外套有着特殊要求，同时还有两种特殊的威力，因此在 <code>PantherMan</code>类中，<code>useSpecialPower()</code>和<code>putOnSuit()</code>两个方法都被重写了。</p>
<p><strong>实例变量不被重写</strong>，因为没有必要。他们并没有定义什么特别的行为，因此子类可以赋给实例变量任何子类所需的值。<code>PantherMan</code>可以将他所继承的 <code>tights</code> 设置为紫色，同时 <code>FriedEggMan</code> 则可以设置为白色。</p>
<h1 id="一个继承的实例"><a class="header" href="#一个继承的实例">一个继承的实例</a></h1>
<pre><code class="language-java">public class Doctor {

    boolean worksAtHospital;

    void treatPatient () {
        // perform a checkup
    }
}
</code></pre>
<pre><code class="language-java">public class FamilyDoctor extends Doctor {

    boolean makesHouseCalls;

    void giveAdvice () {
        // give homespun advice
    }
}
</code></pre>
<pre><code class="language-java">public class Surgeon extends Doctor {
    
    void treatPatient () {
        // perform surgery
    }

    void makeIncision () {
        // make incision (yikes!)
    }
}
</code></pre>
<p><img src="images/Ch07_03.png" alt="继承实例" /></p>
<p><em>图 3 - 继承实例</em></p>
<h2 id="给某个动物模拟程序设计继承树the-inheritance-tree"><a class="header" href="#给某个动物模拟程序设计继承树the-inheritance-tree">给某个动物模拟程序设计继承树（the inheritance tree）</a></h2>
<p>设想有人邀请你，设计一个让用户将一堆动物丢到某个环境中，看看到底会发生什么，这样的模拟程序。现在无需编写这个程序，而是关注与其设计。</p>
<p>此时已经得知了程序中会有的部分动物的清单，但这不是全部。显然每个动物都将由一个对象来表示，这些表示各种动物的对象，将在所给的环境中走动，并干一些根据各自种类而预先为其编写的行为。</p>
<p><em>同时要让其他程序员在任何时候都能往程序里加入新种类的动物</em>。</p>
<p>首先要找出所有动物都有的那些共同的、抽象的特征，并将这些特征构建到一个所有动物类都可以对其进行扩展的类里去。</p>
<p><img src="images/Ch07_04.png" alt="查找出有着共同属性与行为的那些对象" /></p>
<p><em>图 4 - 找出有着共同属性与行为的那些对象</em></p>
<h2 id="使用继承来避免子类中的重复代码"><a class="header" href="#使用继承来避免子类中的重复代码">使用继承来避免子类中的重复代码</a></h2>
<p>这个模拟程序中有五个 <em><strong>实例变量（instance variables）</strong></em>：</p>
<ul>
<li><code>picture</code> -- 表示该动物的 JPEG 的文件名</li>
<li><code>food</code> -- 该动物所食用的事物的种类。现在只能有两个值：<code>meat</code> 或 <code>grass</code></li>
<li><code>hunger</code> -- 一个表示该动物饥饿程度的整数值。这个实例变量会依据动物进食的时间（以及进食量）而变化</li>
<li><code>boundaries</code> -- 表示该动物活动范围空间的长度与宽度（比如，<code>640x480</code>）的值</li>
<li><code>location</code> -- 该动物在其空间中所在位置坐标 <code>X</code> 与 <code>Y</code> 的表示</li>
</ul>
<p>有着四个 <em><strong>方法（methods）</strong></em>:</p>
<ul>
<li>
<p><code>makeNoise()</code> -- 在该动物嘶叫时的行为</p>
</li>
<li>
<p><code>eat()</code> -- 在该动物碰到其偏好的食物，也就是 <code>meat</code> 或 <code>grass</code> 时的行为</p>
</li>
<li>
<p><code>sleep()</code> -- 在该动物需要睡眠时的行为</p>
</li>
<li>
<p><code>roam()</code> -- 在动物没有进食或睡觉时的行为（或许是四处游荡去寻获事物，或者探索他的边界）</p>
<p><img src="images/Ch07_05.png" alt="超类的设计" /></p>
<p><em>图 5 - 设计超类</em></p>
</li>
</ul>
<h2 id="所有动物都是以同样方式进食吗"><a class="header" href="#所有动物都是以同样方式进食吗">所有动物都是以同样方式进食吗？</a></h2>
<p>这里假定对这个事都表示同意：超类中的实例变量对 <strong>所有</strong> 动物都是适用的。一头狮子将有着他自己的 <code>picture</code>、<code>food</code>（也就是 <code>meat</code>）、<code>hunger</code>、<code>boundaries</code>以及<code>location</code> 的取值。一头河马则会有着其各个实例变量的不同取值，但河马仍然有着其他 <code>Animal</code> 类别的同样的那些变量。与 <code>Dog</code>、<code>Tiger</code>等相同的实例变量。但对于这些动物的 <strong>行为（behavior）</strong> 呢？</p>
<h3 id="到底需要重写哪些方法"><a class="header" href="#到底需要重写哪些方法">到底需要重写哪些方法？</a></h3>
<p>狮子会发出与狗子一样的嘶吼吗？猫咪会像河马那样进食吗？或许在你的版本中会这样，但在我们的版本中，进食与嘶叫，是特定于动物种类的（<code>Animal</code>-type-specific）。似乎无法找到一种对所有动物都适用的，编写这些方法的途径。好吧，这样说是不对的。可以这样编写 <code>makeNoise()</code> 方法，譬如说这个方法就是简单地播放一个，定义在特定动物类别中的实例变量中的声音文件，但这样处理还不够专业。一些动物在不同情形下会有不同的嘶吼（比如在进食的时候一种，在碰到天敌的时候又是一种等等）。</p>
<p>因此，就如同为了获得更多特定于 <code>Amoeba</code> （也就是 <strong>独特（unique）</strong>）的行为，<code>Amoeba</code> 对 <code>Shape</code> 类的 <code>rotate()</code> 进行重写的做法一样，这里将对 <code>Animal</code> 的子类进行同样的操作。</p>
<p><img src="images/Ch07_06.png" alt="重写方法" /></p>
<p><em>图6 - 重写方法</em></p>
<h2 id="查找剩余的继承机会"><a class="header" href="#查找剩余的继承机会">查找剩余的继承机会</a></h2>
<p><strong>Looking for more inheritance opportunities</strong></p>
<p>现在，类的层次就逐渐形成了。前面已经让各个子类对 <code>eat()</code> 和 <code>makeNoise()</code> 方法进行了重写，因此就不会让狗子像猫咪那样叫唤（那样会让狗子和猫咪都相当气愤）。同时河马也不会像狮子那样进食了。</p>
<p>不过或许可以更进一步。这时就要对<code>Animal</code>的子类进行充分检视，并看看有没有两种或者更多的动物，可以某种方式组织在一起，并只为这个新的组别写特定的代码。<code>Wolf</code>与 <code>Dog</code>有着相似点；同时 <code>Lion</code>、<code>Tiger</code> 和 <code>Cat</code> 也有。</p>
<p><img src="images/Ch07_07.png" alt="查找剩余的抽象机会" /></p>
<p><em>图7 - 穷尽抽象机会</em></p>
<h2 id="完成类层次设计"><a class="header" href="#完成类层次设计">完成类层次设计</a></h2>
<p><strong>Finish the class hierarchy</strong></p>
<p>因为动物们本身就有着一个有组织的层次（整个的动物王国，种，门之类的，动物学相关），所以就可以直接套用这种分级，而令到我们的类的设计更有意义。这里就将使用生物学上的“族”（the biological &quot;families&quot;）概念，通过构造一个 <code>Feline</code> 类和一个 <code>Canine</code> 类，而将这些动物组织起来。</p>
<p><img src="images/Ch07_08.png" alt="完成类的设计" /></p>
<p><em>图8 - 类设计的完成</em></p>
<h2 id="所调用的究竟是哪个方法"><a class="header" href="#所调用的究竟是哪个方法">所调用的究竟是哪个方法</a></h2>
<p><code>Wolf</code> 类有四个方法。一个是从 <code>Animal</code> 类继承得来，一个是从 <code>Canine</code> （这实际上是重写了 <code>Animal</code> 的其中一个方法后的版本）继承来的，<code>Wolf</code>类本身有两个重写后的方法。在创建一个 <code>Wolf</code> 对象并将该对象赋值给某个变量后，就可以使用那个引用变量上的 <code>.</code> 运算符，去调用这四个方法了。但调用的到底是那个 <em>版本</em> 的方法呢？</p>
<p><img src="images/Ch07_09.png" alt="继承类中方法的版本" /></p>
<p><em>图 9 - 继承类中方法的版本</em></p>
<p>在调用对象引用上的某个方法时，调用的是对象类型（类）上最具体的方法版本。换个说法就是，<em><strong>最低者获胜（the lowest one wins）</strong></em>!</p>
<p>“最低”指的是在继承树（the inheritance tree）中位置最低。<code>Canine</code> 要比 <code>Animal</code> 低，而<code>Wolf</code>又要比 <code>Canine</code> 更低，因此在对某个 <code>Wolf</code> 对象上的方法进行调用时，就意味着 JVM 开始首先在 <code>Wolf</code> 类中进行查找。若JVM未能在 <code>Wolf</code> 类中找到该方法的一个版本时，他就开始沿着继承树向后移动，到发现一个匹配的方法为止。</p>
<p><strong>既然JVM是自继承树中调用方法所在的类类型（the class type），往上去查找。那么如果 JVM 始终没有找到那个方法，会怎样呢？</strong></p>
<p>无需担心这个问题。对于某个特定引用类型（类），编译器会确保其方法始终是可调用的。对于所调用的方法，在运行时究竟来自继承树上的哪个类，这个问题并不重要。以 <code>Wolf</code>这个类为例，编译器会对 <code>sleep()</code> 方法进行检查，但编译器并不会关心 <code>sleep()</code> 是在 <code>Animal</code> 类中进行定义（并从那里继承到）的。如类 <strong>继承</strong> 了某个方法，那他就 <strong>拥有</strong> 了这个方法。</p>
<p>对于编译器来说，方法在何处定义（也就是定义这个方法是哪个超类）并不重要。但在运行时， <strong>JVM 始终会选出正确的那个</strong>。而所谓的正确的那个，是指 <strong>对于特定对象最为具体的版本</strong>。</p>
<h2 id="运用-is-a-与-has-a-法则"><a class="header" href="#运用-is-a-与-has-a-法则">运用 <code>IS-A</code> 与 <code>HAS-A</code> 法则</a></h2>
<blockquote>
<p>“浴缸是一个浴室”，或者“浴室是一个浴缸”，这样讲行的通吗？浴室和浴缸的关系，应该是归属的关系。是浴室具有浴缸。也就是说，浴室有着一个浴缸的实例变量。</p>
</blockquote>
<p>前面讲到，在某个类从另一个进行了继承时，就说这个子类对超类进行了 <em>扩展</em>。在要确定某物是否要对其他东西进行扩展时，使用 <code>IS-A</code> 法则就行。</p>
<p><code>Triangle</code> IS-A <code>Shape</code>，看吧，这是行得通的; <code>Cat</code> IS-A <code>Feline</code>，同样可行；<code>Surgeon</code> IS-A <code>Doctor</code>，还是没问题；而要用浴缸去拓展浴室，听起来似乎没问题，但要用一个 <code>IS-A</code> 去测试，就不行了。</p>
<p>要搞清楚有没有正确地设计类型，就问一下“类型A IS-A 类型B 说得通吗”？如果讲不通，那么在设计中肯定就有问题了，因此如果运用 <code>IS-A</code> 法则，那么 <code>Tub</code> IS-A <code>Bathroom</code> 明显就是错的。</p>
<p>那如果反过来，用 <code>Bathroom</code> 去扩展 <code>Tub</code> 又会怎样呢？仍然行不通，<code>Bathroom</code> IS-A <code>Tub</code> 并不行。</p>
<p><code>Tub</code> 与 <code>Bathroom</code> <strong>确实</strong> 有联系，但不是通过继承联系起来的。<code>Tub</code> 与 <code>Bathroom</code> 是由一种叫做 <code>HAS-A</code> 的关系，连接起来的。看看“<code>Bathroom</code> HAS-A <code>Tub</code>” 说得通吗？如果行，那么就是说 <code>Bathroom</code> 有着一个 <code>Tub</code> 的实例变量。也就是说，<code>Bathroom</code> 有着一个到 <code>Tub</code> 对象的引用变量，而并非 <code>Bathroom</code> 扩展了 <code>Tub</code>，或者 <code>Tub</code> 扩展了 <code>Bathroom</code>。</p>
<p><code>IS-A</code>法则在继承树中 <strong>所有地方</strong> 都是有效的。在继承树设计良好时，那么不论在任何时候，提出某个子类 IS-A 其任何一个超类型问题时，都是说得通的。</p>
<p><em><strong>在类 B 对类 A 进行了扩展时，那么类 B IS-A 类 A。这在继承树的任何地方，都是成立的。而在类 C 又对类 B 进行了继承后，那么类 C 就能同时通过对类 B 和类 A 的 IS-A 测试</strong></em>。</p>
<p><img src="images/Ch07_10.png" alt="IS-A 法则" /></p>
<p><em>图 10 - IS-A 法则</em></p>
<p>对于上图中的继承树，就可以说 “<code>Wolf</code> 扩展了 <code>Animal</code>” 或 “<code>Wolf</code> IS-A <code>Animal</code>”。就算<code>Animal</code>是<code>Wolf</code>超类的超类，也是没有影响的。事实上， <em><strong>只要<code>Animal</code> 位于<code>Wolf</code>所在的继承树上部的某处，那么 <code>Wolf</code> IS-A <code>Animal</code> 这个判断，就始终是正确的。</strong></em></p>
<p>这个 <code>Animal</code> 继承树的结构，向外界通告：</p>
<p>“<code>Wolf</code> IS-A <code>Canine</code>，因此 <code>Wolf</code> 可以干 <code>Canine</code> 能干的那些事。同时 <code>Wolf</code> IS-A <code>Animal</code>, 因此 <code>Wolf</code> 也可以干 <code>Animal</code> 能干的事。”</p>
<p>就算 <code>Wolf</code> 重写了 <code>Animal</code> 或 <code>Canine</code> 的一些方法，对此也没有影响。外界（其他代码）所知的，就是 <code>Wolf</code> 可以执行这四种方法。至于<code>Wolf</code>怎样去执行，或者说 <em><strong>这些方法在哪个类中被重写的</strong></em>，无关紧要。某个 <code>Wolf</code> 可以 <code>makeNoise()</code>、<code>eat()</code>、<code>sleep()</code>及<code>roam()</code>，因为<code>Wolf</code>是扩展<code>Animal</code>得来的。</p>
<h2 id="怎么判断继承设计是正确的"><a class="header" href="#怎么判断继承设计是正确的">怎么判断继承设计是正确的</a></h2>
<p>显然目前所探讨的还有欠缺，好在后续会深入了解面向对象的问题。此时我们知道，运用 <code>IS-A</code>测试是一条不错的准则。如果 “X IS-A Y”讲得通，那么这两个类就应该位处同一个继承层次上。这种可能性，就在于他们有着同样的或重叠的行为表现。</p>
<p><em><strong>划重点，IS-A 关系仅在一个方向上有效</strong></em>！</p>
<p><code>Triangle</code> IS-A <code>Shape</code> 讲得通，因此可以用 <code>Triangle</code> 去扩展 <code>Shape</code>。</p>
<p>但反过来，<code>Shape</code> IS-A <code>Triangle</code>，就说不通了，因此 <code>Shape</code>就不能对 <code>Triangle</code> 进行拓展。<code>IS-A</code>关系，表示在 <code>X IS-A Y</code>时，<code>X</code>就能完成<code>Y</code>能干的事（甚至更多）。</p>
<p><strong>既然子类可以继承超类的某个方法，那么超类想要使用子类版本的这个方法时，会怎样呢</strong>？</p>
<p>超类是没有必要了解其子类的任何一点的。在你编写完某个类后，就会有人沿用这个类，并对其进行扩展，此时你所编写的那个类，就成了超类。尽管作为这个超类的作者的你，想要了解（或使用）这个类中某个方法的子类版本，也是做不到的，并不存在 <strong>逆向（reverse）</strong> 或者说 <strong>向后（backwards）</strong> 的继承。试想一下，孩子从父母那里继承，而不是反过来吧。</p>
<p><strong>可以在子类中同时使用某个方法的超类版本与子类的这个方法的重写版本吗？也就是说，在不想完全替换该方法的超类版本，而只想对其进行补充时，该怎么办呢？</strong></p>
<p>这是可以做到的！<strong>同时这也是一个重要的设计特性（an important design feature）</strong>。这正是 “扩展” 一词的本义所在，是“要对超类功能进行扩展”的体现。</p>
<pre><code class="language-java">public void roam () {
    super.roam ();
    // 它自己的 游荡 行为
}
</code></pre>
<p>上面的代码首先调用了继承到的 <code>roam()</code> 版本，随后再回到特定于子类的代码。</p>
<p>在设计超类方法时，虽然超类的各个子类会往这些方法“追加”代码，同样可以在超类的这些方法中，包含所有子类都适用的方法实现。在子类重写某个方法时，就可以使用关键字 <code>super</code>，来调用超类版本的这个方法。这样写就像是说，“先运行超类版本，然后回来继续完成子类自己的代码..._”。</p>
<h2 id="怎样知道子类可以从超类继承到哪些东西"><a class="header" href="#怎样知道子类可以从超类继承到哪些东西">怎样知道子类可以从超类继承到哪些东西</a></h2>
<p>子类对超类的成员加以继承。到目前为止，这些成员包括了实例变量与方法，后续会涉及其他被继承的成员。通过为成员设定不同的访问级别，超类是可以对其子类所要继承的成员加以选择的（A subclass inherits members of the superclass. Members include instance variables and methods, although later in this book we'll look at other inherited members. A superclass can choose whether or not it wants a subclass to inherit a particular member by the level of access the particular member is given）。</p>
<p>本书中将涉及以下四个访问级别。从严到宽，这四个级别分别是：</p>
<p><code>private</code>、<code>default</code>、<code>protected</code>、 <code>public</code></p>
<p><strong>这些访问级别，控制了 <em>哪些对谁可见</em></strong>，这对具备良好设计、健壮的 Java 代码来说至关重要。现阶段只关注 <code>public</code> 与 <code>private</code>。他们两的规则较为简单：</p>
<ul>
<li><code>public</code> 成员是继承得来的</li>
<li><code>private</code> 成员不是继承得来的</li>
</ul>
<p>在子类继承到某个成员时，那么这个成员 <strong>就好像是子类自己定义的一样</strong>。在 <code>Shape</code> 的示例中，<code>Square</code>继承了 <code>rotate()</code> 与 <code>playSound()</code> 两个方法，而对于外界（其他代码）而言，就是 <code>Square</code> 有着这两个方法而已。</p>
<p>某个类的成员，包括在这个类中所定义的变量与方法，加上这个类从他的超类所继承到的全部成员。</p>
<blockquote>
<p>注意：有关 <code>default</code> 与 <code>protected</code> 的细节，将在第 17 章及附录 B中涉及。</p>
</blockquote>
<h2 id="正确运用继承杜绝滥用"><a class="header" href="#正确运用继承杜绝滥用">正确运用继承，杜绝滥用</a></h2>
<p>下面的这些规则背后的缘由，要在后续章节才会揭示，现在只需了解，几条简单的规则，就可以助力构建良好的继承设计。</p>
<ul>
<li>
<p>在某个类确实是某个超类的更具体类型时，才使用继承。比如 <code>Willow</code> 是 <code>Tree</code> 的一个更具体的类型，因此 <code>Willow</code>对 <code>Tree</code> 进行扩展是讲得通的。</p>
</li>
<li>
<p>存在确实可以在同一通用类型的多个类之间共用的行为表现（方法的实现代码）时，要考虑使用继承。比如，<code>Square</code>、<code>Circle</code>、<code>Triangle</code> 都需要 <code>rotate()</code> 与 <code>playSound()</code>，因此将这两个功能放入到 <code>Shape</code> 中就讲得通。不过要留意，尽管 <strong>继承作为面向对象编程的关键特性之一</strong>，但对于代码重用这个目的，继承却不是必要的。继承带你进入面向对象编程的世界，而且通常也是正确的设计选择，然而真正能让你见识到更多巧妙与灵活设计的，则是那些设计模式（Be aware, however, that while inheritance is one of the key features of object-oriented programming, it's not neccessarily the best way to achieve behavior reuse. It'll get you started, and often it's the right design choice, but design patterns will help you see other more subtle and flexible options）。若你对设计模式没有了解，那么可以看看另一本书 “<em>Head First Design Patterns</em>”。</p>
</li>
<li>
<p>超类与子类之间的关系，违背了上面两条规则时，不要仅为了重用另一个类的代码，而使用继承。比如设想在已经编写好 <code>Alarm</code> 类中的打印代码后，又要编写 <code>Piano</code> 类的打印代码，于是就让 <code>Piano</code> 去继承 <code>Alarm</code>，目的是让<code>Piano</code>继承到这些打印代码。这样做毫无意义！因为某个<code>Piano</code>并不是<code>Alarm</code>的更为具体的类型（正确的做法，应该把打印代码放在一个 <code>Printer</code>的类中，如此所有可打印对象，都可以通过一种 <code>HAS-A</code> 关系而得到打印功能）。</p>
</li>
<li>
<p>在子类与超类无法通过 <code>IS-A</code> 测试时，不使用继承。要一直询问，子类究竟是不是超类的更具体类型。比如，<code>Tea</code> IS-A <code>Beverage</code> 讲得通。<code>Beverage</code> IS-A <code>Tea</code> 就不行。</p>
</li>
</ul>
<h2 id="本章重点"><a class="header" href="#本章重点">本章重点</a></h2>
<ul>
<li>子类对超类进行扩展</li>
<li>子类继承到超类的所有 <code>public</code> 实例变量与方法，对超类的<code>private</code>实例变量和方法，不予继承</li>
<li>继承到的方法可被重写；而实例变量则不能被重写（尽管实例变量可在子类中被重新定义，但与重写相比不是一回事，同时机会也完全没有这样做的必要）</li>
<li>使用 <code>IS-A</code>测试来对继承层次进行有效性验证。若 <code>X</code> 对 <code>Y</code> 进行了扩展，那么 <code>X</code> IS-A <code>Y</code> 必须能说得通</li>
<li><code>IS-A</code>关系只在一个方向上有效。某个 <code>Hippo</code> 是一个 <code>Animal</code>，但并非所有 <code>Animal</code> 都是 <code>Hippo</code>s</li>
<li>在子类中重写了某个方法，且这个方法于此子类的某个对象中被调用到时，所调用的是重写后的版本（<strong>最低者入选法则</strong>）</li>
<li>在类 <code>B</code> 扩展了类 <code>A</code>，同时类 <code>C</code>扩展了类<code>B</code>的情况下，那么类 <code>B</code> IS-A 类<code>A</code>，同时类 <code>C</code> IS-A 类<code>B</code>，此外类<code>C</code> IS-A 类<code>A</code></li>
</ul>
<h2 id="继承带来的好处"><a class="header" href="#继承带来的好处">继承带来的好处</a></h2>
<p>掌握了具备继承的设计之后，离面向对象的目标就不远了（You get a lot of OO mileage by designing with inheritance）。通过将一组类中共用的行为抽象出来，放入到超类中，就可以解决重复代码的问题。这样做还有另一个好处，就是在需要修改这些共用代码时，只需要在一个地方去更新这些共用代码，并且 <em>代码的改变，会神奇地在所有继承了这些代码的类中反应出来</em>。当然，这里并没有什么魔法，而是相当简单：做出修改，然后重新编译那个超类。这就完了。<strong>完全不需要去动那些子类</strong>！</p>
<p><strong>只需投放新修改的超类，所有对超类进行了扩展的那些子类，就会自动使用新的版本了</strong>。</p>
<p>因为一个Java程序，只是一堆的类而已，因此无需对子类进行编译，就能使用上新版本的超类。同时超类并不会破坏子类的任何东西，所以一切都相安无事（后续章节会讨论到在这种语境下，“破坏”的意义。目前来讲，可以设想一下，比如对超类中子类所依赖的某个特定方法的参数或返回值，或者方法的名称的修改）。</p>
<ul>
<li>
<p>避免了重复代码</p>
<p>将共用代码放在了一起，并让子类从超类继承这些代码。在要修改某个行为时，只需在一个地方进行修改，这时所有子类都能看到修改。</p>
</li>
<li>
<p>给一组类定义了共用的协议</p>
</li>
</ul>
<h2 id="继承可以确保组织在某个特定超类型之下的所有类拥有那个超类型所拥有的全部方法"><a class="header" href="#继承可以确保组织在某个特定超类型之下的所有类拥有那个超类型所拥有的全部方法">继承可以确保组织在某个特定超类型之下的所有类，拥有那个超类型所拥有的全部方法</a></h2>
<p><strong>Inheritance lets you guarantee that all classes grouped under a certain supertype hava all the methods that the supertype has</strong></p>
<blockquote>
<p>在提及 “全部方法” 时，指的是 “全部可继承的方法”，目前实际上是指，“所有<code>public</code>方法”，不过后面会对这个定义做进一步修订</p>
</blockquote>
<p>也就是说，通过继承，给一组相关的类定义了一个共用的协议（In other words, you define a common protocol for a set of class related through inheritance）。</p>
<p>在定义超类中可被子类们继承的那些方法时，就是在向其他代码通告某种协议，像是在说 “我的所有子类型（也就是子类）可以下面这些方法，完成这些事情...”。</p>
<p>换句话说，就是建立了一个 <em>合约（contract）</em>。</p>
<p>类 <code>Animal</code> 为所有 <code>Animal</code> 的子类型，建立了这样一个共用协议：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Animal</th></tr></thead><tbody>
<tr><td style="text-align: left">makeNoise()<br>eat()<br>sleep()<br>roam()<br></td></tr>
</tbody></table>
</div>
<p>需要注意的时，当提及 <em>所有 <code>Animal</code></em> 时，指的是 <code>Animal</code> <em>以及所有扩展了 <code>Animal</code> 的类</em>。还指的是 <em>所有的在继承层次中，可往上追溯到 <code>Animal</code> 的类</em>。</p>
<p>对于 OO 中真正精彩的部分，还远未涉及，因为我们把其中最好的东西 -- <em>多态（polymorphism）</em> 留在了最后。</p>
<p>在为一组类定义超类型的时候，<em>在用到超类型的所有地方，那个超类型的所有子类，都可以被取代（any subclass of that supertype can be substituted where the supertype is expected）</em>。</p>
<p>然而这句话到底是什么意思呢？</p>
<p>不要着急，现在还不能把这句话解释清楚。</p>
<ul>
<li>
<p><strong>为何要了解多态</strong></p>
<p>因为可以利用上多态的优势</p>
</li>
<li>
<p><strong>多态为什么重要</strong></p>
<p>因为可以使用一个声明为超类型的引用变量，去引用某个子类的对象（refer to a subclass object using a reference declared as the supertype）</p>
</li>
<li>
<p><strong>这又到底意味着什么呢</strong></p>
<p>意味着可以编写出真正灵活的代码来。代码更加干净（更高效、简单）。不仅开发起来更容易，同时扩展起来也要容易得多，以先前写代码得经验来看，运用多态这种方式，是你所无法想象的。</p>
<p>这样就意味着，当你的同事忙着更新程序时，你还可以加勒比海享受假期，而你的同事们甚至不需要你的源码。</p>
<p>在下一页就能了解到多态的原理。</p>
</li>
</ul>
<p><em><strong>要了解多态的原理，就要回顾一下声明引用变量和创建对象的寻常方式</strong></em>。</p>
<p><img src="images/Ch07_11.png" alt="常规的引用变量与对象创建方式" /></p>
<p><em>图 11 - 常规的引用变量与对象创建方式</em></p>
<p><strong>要点时引用变量的类型 <em>与</em> 对象的类型，是一致的</strong>。</p>
<p>在这个示例中，他们都是 <code>Dog</code>。</p>
<p><strong>有了多态，引用变量与对象，就可以不同</strong>。</p>
<pre><code class="language-java">Animal myDog = new Dog();
</code></pre>
<p><img src="images/Ch07_12.png" alt="多态 - 引用变量与其对象具有不同的类型" /></p>
<p><em>图 12 - 多态 - 引用变量与其对象具有不同的类型</em></p>
<p><strong>运用多态特性，引用变量的类型，可以是实际对象的类型的超类</strong>。</p>
<p>在声明某个引用变量时，可以通过引用变量的类型的 <code>IS-A</code> 测试的所有对象，都可以赋值给那个引用变量。换个说法，就是所有扩展了所声明的引用变量类型的类的对象，都可以赋值给该引用变量。 <strong>这可以让我们能够完成建立多态的数组等操作（This lets you do things like make polymorphism arrays）</strong>。</p>
<p><strong>一个实例可以更好的帮你理解这句话</strong>。</p>
<p><img src="images/Ch07_13.png" alt="多态下的数组" /></p>
<p><em>图 13 - 多态下的数组</em></p>
<p><strong>除了上面两个特性，多态还有更多用法</strong>！</p>
<p><strong>可以在方法中，使用多态的参数和返回值类型</strong>。</p>
<p>声明比如 <code>Animal</code> 这样的超类型（supertype）引用变量，并将某个子类，比如<code>Dog</code>的对象赋值给他，是可以的。设想把这个引用变量作为方法的参数时，会怎样......</p>
<p><img src="images/Ch07_14.png" alt="多态的方法参数" /></p>
<p><strong>运用多态特性，可以编写出无需修改，就可以引入新的子类类型的代码</strong>。</p>
<p>就像上面示例中的 <code>Vet</code> 类一样，在将 <code>Vet</code> 类编写为使用声明为 <code>Animal</code> 类型的参数之后，这段代码就可以处理所有 <code>Animal</code> 的子类了。这就意味着有人要用到这个 <code>Vet</code> 类时，只要确保他们的新 <code>Animal</code> 类型，是扩展类 <code>Animal</code> 得来的就可以了。就算类 <code>Vet</code> 对那些<code>Vet</code>要处理的、新的 <code>Animal</code> 子类型一无所知，<code>Vet</code> 的那些方法仍然会工作。</p>
<h2 id="思考题"><a class="header" href="#思考题">思考题</a></h2>
<p>为什么多态一定就可以这样运作？为什么就可以一直假定，所有子类类型都正好有这些在他们之上调用的方法（也就是在超类的引用变量上使用<code>.</code>运算符）？</p>
<h2 id="答疑"><a class="header" href="#答疑">答疑</a></h2>
<ul>
<li><strong>在设计子类时，存在层级的限制吗？最多有多少的层级呢？</strong></li>
</ul>
<blockquote>
<p>在深入研究 Java API之后，就会发现多数的继承层次，都是宽泛的，而不是很深的继承。大多数都只有一到两级的继承，不过也有例外（尤其是在 GUI 的那些类中）。后续你发现，让继承树保持浅薄而不是浓密，更有意义，不过在继承深度上时没有硬性限制的（起码一般情况下不会触及到这个限制）。</p>
</blockquote>
<ul>
<li><strong>刚想到一个问题，在拿不到某个类源码的情况下，仍打算修改那个类中某个方法，可以对那个类进行子类操作来实现这个目的吗？也就是对那个“差” 类进行扩展，并用自己改进的代码来重写某个方法</strong>。</li>
</ul>
<blockquote>
<p>当然可以，这正是 OO 的特色之一，还可以避免从头开始去重写某个类，或者去找那个隐藏代码的程序员。</p>
</blockquote>
<ul>
<li><strong>不论什么类都可以扩展吗？或者说像类的成员一样，在类为 <code>private</code> 时，就不能继承到他......</strong></li>
</ul>
<blockquote>
<p>除了在非常特殊的情况下，有一种现在还没有见过的，叫做 <em>内部</em> 类（an <em>inner</em> class）之外，是不存在 <code>private</code> 私有类的。有三种阻止某个类被子类化操作的办法：</p>
</blockquote>
<blockquote>
<ul>
<li>第一个叫做访问控制。虽然类不能用 <code>private</code> 标注，但某个类可以是非公开的（non-public，只要不将类声明为 <code>public</code>就能得到）。非公开类只能在该类所在包中进行子类化操作。在其他包中就无法对非公开类进行子类操作（甚至无法使用）。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>第二种，就是使用 <code>final</code> 关键字。<code>final</code> 修饰的类，表示这个类已经是继承线（the inheritance line）的末端了。没有人可以再对 <code>final</code> 类进行扩展。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>第三，若某个类仅有 <code>private</code> 的构造器，那么他就是不能被子类的（The third issue is that if a class has only <code>private</code> constructors, it can't be subclassed）。</li>
</ul>
</blockquote>
<ul>
<li><strong>设置 <code>final</code> 类的目的何在？阻止某个类被子类化能带来哪些好处呢？</strong></li>
</ul>
<blockquote>
<p>通常情况下，不需要将类设置为 <code>final</code>。但在需要考虑安全 -- 确保类中的那些方法一直按照编写的方式工作（由于某些原因不能被重写）时，使用 <code>final</code> 类就可以做到。Java API中的很多类，都是因为这个原因，而被设置为 <code>final</code>。比如 <code>String</code> 类就是 <code>final</code> 的，之所以这样做，你可以想象一些有人贸然去修改 <code>String</code> 的行为，将会带来多大的灾难。</p>
</blockquote>
<ul>
<li><strong>可以不将整个类设置为 <code>final</code>，而只将某个方法设置为 <code>final</code>吗</strong> ？</li>
</ul>
<blockquote>
<p>可以将某个特定方法使用 <code>final</code> 修饰符标记起来，从而把那个方法保护起来，防止被重写。将整个类都标记为 <code>final</code>的话，就可以保证那个类中所有方法都不能被重写。</p>
</blockquote>
<h2 id="遵守约定重写时要遵循的一些规则"><a class="header" href="#遵守约定重写时要遵循的一些规则">遵守约定：重写时要遵循的一些规则</a></h2>
<p>在对来自超类的某个方法进行重写时，前提就是要合乎约定（When you override a method from superclass, you're agreeing to fulfill the contract）。约定是什么呢，举例来说，“没有参数，且返回一个逻辑值”。换句话说，所重写方法中，外部世界所能看到的参数与返回值类型，必须要与超类中所重写的方法一致。</p>
<p><strong>方法即合约</strong>。</p>
<p>在应用了多态的情况下，来自 <code>Appliance</code> 的 <code>Toaster</code> 版的重写方法，在运行时就必须工作。要记住，编译器通过引用变量的类型，来判断是否能够调用那个引用变量上的某个特定方法。在某个 <code>Appliance</code> 对象，是对某个 <code>Toaster</code> 的引用时，那么编译器就只关心类 <code>Appliance</code> 有无在那个 <code>Appliance</code>对象引用上的被调用到的方法。但在运行时，JVM所查看的，则不是在引用变量的类型（<code>Appliance</code>）上，而是在内存堆中确切的 <code>Toaster</code> 对象上，有无那个方法。因此即使编译器已经证实该方法调用，决定方法能够工作的，仍然是所重写的方法，是否有着同样的参数与返回值类型。否则，就会出现某人在 <code>Appliance</code> 引用变量上调用不带参数地调用 <code>turnOn()</code> 方法，而<code>Toaster</code>中的<code>turnOn()</code>版本，却有着一个 <code>int</code> 的参数的情况。那么这个时候运行时会调用到哪个方法呢？<code>Appliance</code> 中的那个。也就是说，<strong>在 <code>Toaster</code> 中的那个 <code>turnOn()</code> 方法，是不算作重写的</strong>！</p>
<ol>
<li>
<p>方法的参数必须一致，而返回值类型则必须是兼容的。</p>
<p>超类的合约，对外部代码如何去使用某个方法，进行了定义。超类以什么做参数，重写方法的子类都要使用同样的参数。同时超类声明了一个什么样的返回值，重写的方法也必须要么同样类型，要么是 <strong>原类型的子类类型（type, the subclass type）</strong> 的返回值。要记住，子类对象是要保证能够完成其超类所声明的任何事情的，因此在期望返回超类的地方，返回子类是安全的。</p>
</li>
<li>
<p>方法可访问性，不能降低（The method can't be less accssible）。</p>
<p>这说的是，方法的访问级别必须一致，或者更为友好（That means the access level must be the same, or friendlier）。也就是说，在对某个 <code>public</code> 方法进行重写时，不能将其标注为 <code>private</code>。这样对调用该方法的代码来说，本来调用的是一个 <code>public</code> 的方法（在编译时），却在运行时因为重写版本是一个私有方法，而突然被 JVM 关上了访问之门时，会是多么的懵逼！</p>
<p>到现在为止，我们所知的有两个访问级别：<code>private</code> 与 <code>public</code>。在部署章节（发布代码）和附录 B 还有两个访问级别。同时还有一条与例外处理相关的方法重写规则，只能在有关例外的那章里来说了。</p>
<p><img src="images/Ch07_15.png" alt="方法重写时的两条规则" /></p>
<p><em>图 15 - 方法重写时的两条规则</em></p>
</li>
</ol>
<h2 id="方法的过载overloading-a-method"><a class="header" href="#方法的过载overloading-a-method">方法的过载（Overloading a method）</a></h2>
<p>方法的过载，名字一样，参数清单不同的两个方法。仅此而已。对于过载的方法，实际上不涉及到多态！</p>
<p>借助过载特性，可以实现方法的带有不同参数清单的多个版本，从而方便不同的调用者。比如有个只取用整数的方法时，调用代码在对其进行调用之前，就不得不将先将他的双精度数转换成整数。而在将该方法以另一个取用双精度数的版本对其进行过载后，对于这个调用者就容易多了。在对象生命周期那一章，将更多地了解过载。</p>
<p>因为方法过载特性打破了由超类所定义的多态约定，因此过载的方法有着更多的灵活性。</p>
<p><em><strong>本质上看，过载方法是有着相同方法名称的一个不同方法。与继承和多态没有半毛钱关系。过载方法与重写方法不一样</strong></em>。</p>
<ol>
<li>
<p>返回值类型可以不同。</p>
<p>既然参数清单不同了，那么也就可以随意改变过载方法中的返回值类型了。</p>
</li>
<li>
<p>不能只改变返回值类型。</p>
<p>在只改变返回值类型时，就不再是有效的过载了 -- 编译器会假定是在重写方法。除非返回值类型是超类方法中声明的返回值类型的子类型，这样做甚至不能算合法。要对某个方法进行过载，就必须修改参数清单，之后就可以随便修改返回值类型了。</p>
</li>
<li>
<p>可以随意改变过载方法的访问级别（提升或降低都是可以的）</p>
<p>可以限制更高的方法，去过载某个方法。因为新方法没有义务去满足被过载方法的约定，因此是无所谓的。</p>
</li>
</ol>
<p><strong>方法过载的合法示例</strong>：</p>
<pre><code class="language-java">public class Overloads {
    String uniqueID;

    public int addNums ( int a, int b ) {
        return a + b;
    }

    public double addNums (double a, double b) {
        return a + b;
    }

    public void setUniqueID (String theID) {
        // 一大堆验证代码，然后：
        uniqueID = theID;
    }

    public void setUniqueID (int ssNumber) {
        String numString = &quot;&quot; + ssNumber;
        setUniqueID(numString);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接口与抽象类"><a class="header" href="#接口与抽象类">接口与抽象类</a></h1>
<p><strong>继承只开了个头</strong>。为运用好多态，就需要使用接口（interfaces, 不是GUI中的界面）。需要超越简单继承，通过按照接口规范，来设计和编写代码，才能达到兼具灵活性与扩展性的水平。Java中最酷炫的部分，在不使用接口的情况下，是达不到的。所以就算你在设计Java程序时拒绝使用接口，但你仍避免不了接口的使用。<strong>你会明白没有接口，是无法生存的</strong>。那么接口到底是什么呢？他是一个 100% 的抽象类。而什么又是抽象类呢？是一个无法初始化的类。有什么好处呢？很快就能看到。回顾一下上一张的结尾，通过使用多态参数，就可以让 <code>Vet</code> 中仅仅一个方法，就能够处理所有类型的 <code>Animal</code> 子类，而那仅仅只是冰山一角而已。接口就是多态（polymorphism）中的 <strong>多（poly）</strong>。抽象（abstract）中的 <strong>象（ab）</strong>。是 Java 国的 <strong>咖啡因（caffine）</strong>。</p>
<p><strong>在设计 <code>Animal</code> 继承树时，是不是遗漏了什么</strong>？</p>
<p>这个类结构并没有什么毛病。通过设计，让重复代码降到了最低水平，同时也已经重写了那些应该有着特定子类实现的方法。从多态角度上看，因为可以使用 <code>Animal</code>参数（以及 <code>Animal</code> 的数组声明），来设计出使用到 <code>Animal</code> 类的程序，因此可以说已经很不错且灵活了，从而所有 <code>Animal</code> 的子类型 -- <em>包括在编写代码时想象不到的</em> -- 在运行时都可以传递进去并得到使用。还已经把所有 <code>Animal</code>s 的共用协议（就是那四个希望外部世界知道的所有 <code>Animal</code>s 都有的方法），放入到了 <code>Animal</code> 超类中，同时也已准备好生成新的狮子、老虎以及河马了。</p>
<p><img src="images/Ch08_01.png" alt="Animal 继承树" /></p>
<p><em>图 1 - Animal 继承树</em></p>
<p><strong>我们可以这样说</strong>：</p>
<pre><code class="language-java">Wolf aWolf = new Wolf ();
</code></pre>
<p><img src="images/Ch08_02.png" alt="对象与对象的引用变量类型相同时" /></p>
<p><em>图 2 - 对象与对象的引用变量类型相同时</em></p>
<p><strong>也可以这样说</strong>：</p>
<pre><code class="language-java">Animal aHippo = new Hippo ();
</code></pre>
<p><img src="images/Ch08_03.png" alt="对象与其引用变量的类型不同时" /></p>
<p><em>图 3 - 对象与其引用变量的类型不同时</em></p>
<p><strong>但如果像下面这样，就会显得令人费解</strong>：</p>
<pre><code class="language-java">Animal anim = new Animal ();
</code></pre>
<p><img src="images/Ch08_04.png" alt="创建出一个 Animal 对象时" /></p>
<p><em>图 4 - 创建出一个 Animal 对象时</em></p>
<p><strong>一个 <code>new Animal()</code> 对象会是怎样的</strong> ？</p>
<p><img src="images/Ch08_05.png" alt="一些可怕的对象" /></p>
<p><em>图 5 - 一些可怕的对象</em></p>
<p><strong>那些实例变量的值，都是些什么呀</strong>？</p>
<p><em><strong>有些类就不应该被实例化</strong></em>！</p>
<p>去创建一个 <code>Wolf</code> 对象、一个 <code>Hippo</code> 对象，或者一个 <code>Tiger</code> 对象，这些都说得通，但一个 <code>Animal</code> 对象到底是个什么东西？它的形状是怎样？是什么颜色的？有多大？有几条腿......</p>
<p>尝试去创建一个 <code>Animal</code> 类型的对象，就好像 <strong>星际迷航中噩梦般的传输机故障</strong>。</p>
<p>怎样才能解决这个问题呢？为了实现继承和多态，<code>Animal</code>类肯定是需要的。但又要其他程序员只能对那些，<code>Animal</code>的不那么抽象的子类，而不是<code>Animal</code>本身进行初始化。我们要的是 <code>Tiger</code> 对象与 <code>Lion</code> 对象，而 <em>不是 <code>Animal</code> 对象</em>。</p>
<p>好在有这么一种简单的方法，来防止某个类不被初始化。也就是通过将类标记为 <code>abstract</code>，从而阻止人们在他前面说 <code>new</code>，之后编译器就会在任何时候、任何地方，把那些试图创建那个类型实例的举动，拦截下来。</p>
<p>仍可以将抽象类型，作为引用变量的类型使用。实际上这正是抽象类存在的首要原因（将抽象类用作多态参数或返回值的类型，或者用于构造多态数组）。</p>
<p>在设计类继承层次结构时，就面临着确定哪些是抽象类、哪些是具体的问题（When you're designing your class inheritance stucture, you have to decide which classes are <em>abstract</em> and which are <em>concrete</em>）。具体类是那些足够具体、可被初始化的类。某个具体类，就应该是可以构造出其对象的类。</p>
<p>要构造一个抽象类是很简单的 -- 将关键字 <code>abstract</code> 放在类的声明前面：</p>
<pre><code class="language-java">abstract class Canine extends Animal {
    public void roam () {}
}
</code></pre>
<p><strong>编译器会阻止对某个抽象类的初始化</strong></p>
<p>抽象类意味着无人能构造出他的新实例。但仍然可以出于多态目的，将其用作某个引用变量声明中的类型，由于编译器会确保抽象类不会被初始化，因此就无需担心有人构建出抽象类类型的对象来。</p>
<pre><code class="language-java">abstract public class Canine extends Animal {
    public void roam () {}
}
</code></pre>
<pre><code class="language-java">public class MakeCanine {
    public void go () {
        Canine c;
        c = new Dog ();
        c = new Canine ();
        c.roam();
    }
}
</code></pre>
<p>这个时候编译器就会报错：</p>
<pre><code class="language-console">Canine is abstract; cannot be initiated
</code></pre>
<p>抽象类在未被扩展时，实质上毫无用处、不会有取值、没有目的。</p>
<blockquote>
<p>其中一个例外是，抽象类可以有静态成员，在 IO 那一章会涉及这个问题。</p>
</blockquote>
<p>使用到抽象类时，在运行时真正做事的，是那些抽象类的子类的实例。</p>
<h2 id="关于抽象与具体"><a class="header" href="#关于抽象与具体">关于“抽象”与“具体”</a></h2>
<p>不是抽象的类，就叫做 <em>具体（concrete）</em> 类。在 <code>Animal</code> 继承树中，是将 <code>Animal</code>、<code>Canine</code> 与 <code>Feline</code> 作为抽象类，将 <code>Hippo</code>、<code>Wolf</code>、<code>Dog</code>、<code>Tiger</code>、<code>Lion</code>及<code>Cat</code>作为具体类的。</p>
<p><img src="images/Ch08_06.png" alt="Animal 继承树上的抽象和具体类" /></p>
<p><em>图 6 - <code>Animal</code> 继承树上的抽象和具体类</em></p>
<p>通读 Java API 文档，就会发现很多的抽象类，尤其是在 GUI库中。那么某个GUI组件看起来是怎样的呢？所谓GUI组件类， 是指诸如按钮、文本框、滚动条、对话框等等这样的GUI相关的众多类的超类。比如在构建一个 <code>JButton</code>时，并没有构建这个通用组件的实例并把实例放在屏幕上的。而是对组件的一个具体子类进行实例化，绝不会对组件本身进行实例化。</p>
<h2 id="抽象与具体abstract-or-concrete"><a class="header" href="#抽象与具体abstract-or-concrete">抽象与具体（abstract or concrete）？</a></h2>
<p>什么时候类应该是抽象的？<strong>酒（Wine）</strong> 大概就是抽象的。但 <strong>红葡萄酒（Red）</strong> 和 <strong>白葡萄酒（White）</strong> 呢？大概率也是抽象的（至少对部分人是这样的）。那到底在继承体系中的什么地方，其中的事物才成为具体的呢？</p>
<p>是将 <code>PinotNoir</code> 设置为具体，还是同样作为抽象呢？看起来 “1997年份的骆驼庄园黑皮葡萄酒（the Camelot Vineyards 1997 Pinot Noir）” 好像是具体的，但又怎么确定呢？</p>
<p>再看看上面的 <code>Animal</code> 继承树。再给各个类安排具体和抽象时，到底恰当吗？是不是要对这个<code>Animal</code>继承树加以改进呢（而不是仅仅添加更多的动物）？</p>
<h2 id="抽象方法"><a class="header" href="#抽象方法">抽象方法</a></h2>
<p>除了可以将类标记为 <code>abstract</code>，也可以将方法标记为 <code>abstract</code>。抽象类意味着那个类必须被扩展；而抽象方法，则是那个方法必须被 <strong>重写（be <em>overridden</em>）</strong>；对于抽象类中的部分（或全部）行为/方法，可能断定他们不被抽象类的更具体子类实现时，会毫无用处（You might decide that some (or all) behaviors in an abstract class don't make any sense unless they're implemented by a more specific subclass）。简单地说，对于抽象类的各个子类，任何通用方法实现都没有价值。设想一下，一个通用的 <code>eat()</code> 方法，到底会是什么样子？</p>
<p><strong>抽象方法，是没有函数体的</strong>！</p>
<p>现在既然已经断定抽象方法中的代码不会有任何意义，那么就没有必要再加上函数体了。因此就没有了那一对花括弧了 -- 那么就只需用分号结束抽象函数的声明即可。</p>
<pre><code class="language-java">public abstract void eat();
</code></pre>
<p><img src="images/Ch08_07.png" alt="没有函数体的抽象方法" /></p>
<p><em>图 7 - 没有函数体的抽象方法</em></p>
<p><strong>在声明了一个抽象方法后，就必须把其所在的类也标记为 <code>abstract</code>。在非抽象类中，是不能有抽象方法的</strong>。</p>
<p>其中只要有一个抽象方法，那么那个类就必须是抽象类。但在抽象类中，是可以同时有抽象与非抽象方法的。</p>
<h2 id="答疑-1"><a class="header" href="#答疑-1">答疑</a></h2>
<ul>
<li><strong>抽象方法有什么意义？我所知的是抽象类的意义在于，可把那些由各个子类继承的共用代码放在抽象类中</strong>。</li>
</ul>
<blockquote>
<p>将那些可被继承的方法实现（也就是带有确切方法体的那些方法），放在超类中，确实是不错的做法。那只是在这些代码确实能被子类使用到的时候。但通常的情况是，这些方法实现，并不总是能用到，因为基本设想不到那些子类可以利用上的通用代码呀。抽象方法的意义就在于，就算不放入任何确切代码，任意可以为一组子类型（子类）定义出 <em>协议（protocol）</em>。</p>
</blockquote>
<ul>
<li><strong>为什么说这样做就好呢</strong>？</li>
</ul>
<blockquote>
<p>就是为了多态！别忘了，我们所需要的，是将超类作为方法参数与返回值类型，或者数组类型。这样就可以在不必重新编写新的方法的情况下，加入很多新的子类型。设想如果不将 <code>Animal</code> 超类型（supertype）作为 <code>Vet</code> 中各个方法的参数类型，那么后续对 <code>Vet</code> 的修改将会多么麻烦。那就不得不给所有 <code>Animal</code> 的每个子类一个单独方法！一个用于 <code>Lion</code>，一个用于<code>Wolf</code>，一个用于......，明白了吧。那么现在就可以使用抽象方法，就是说“这个类型的所有类型，都有这个方法”。多态的好处，就在这里啦。</p>
</blockquote>
<h2 id="所有抽象方法都必须被实现"><a class="header" href="#所有抽象方法都必须被实现">所有抽象方法，都必须被实现</a></h2>
<p><strong>对抽象方法的实现，就如同方法的重写一样</strong>。</p>
<p>抽象方法没有方法体；他们仅是为了多态而存在。这就意味着继承树中最开始的具体类，必须实现 <em>所有</em> 抽象方法。</p>
<p>同样可以通过将自己要编写的类设置为抽象类，来将编写实现代码的责任推给其他人。在示例中 <code>Animal</code> 与 <code>Canine</code> 两个都是抽象的，因此他们都有抽象方法，类 <code>Canine</code> 就没有实现那些来自 <code>Animal</code> 的方法。不过只要到了最开始的具体类的地方，比如 <code>Dog</code>，那么这个子类就必须实现 <em>所有</em> 的同时来自 <code>Animal</code> 与 <code>Canine</code> 的抽象方法了。</p>
<p>在提及 “必须实现抽象方法”时，说的就是 <em>必须提供一个方法体</em>。那就意味着必须在具体类中，使用同样的方法签名（method signature, 即方法的名字与参数），以及与抽象方法中所声明的返回值类型兼容的返回值类型，创建出一个非抽象的方法来。该方法其他剩余部分则没有要求。Java所关心的，只是在具体类中，要有这么一个方法。</p>
<h2 id="实战多态"><a class="header" href="#实战多态">实战多态</a></h2>
<p>这里假设尚不知道Java库中的 <code>ArrayList</code> 类，而需要要编写一个保存 <code>Dog</code> 对象的清单类。作为第一步，就只给这个清单类一个 <code>add()</code> 方法。这里将使用一个 <code>Dog</code> 数组 （<code>Dog []</code>） 来保存所加入的 <code>Dog</code> 对象，同时给定其长度为 <code>5</code>。若达到了 5 个 <code>Dog</code> 对象的限制，那么虽然仍旧可以调用 <code>add()</code> 方法，但不会有任何效果。在尚未达到限制时，<code>add()</code> 方法将把所给的<code>Dog</code>对象，放入到下一个可用的索引位置，之后对下一个可用索引（<code>nextIndex</code>）加一。</p>
<p><strong>构造自己的 <code>Dog</code> 专用清单</strong></p>
<p>（或许这是世上最糟糕的从头开始构建类似于<code>ArrayList</code>类的尝试）</p>
<p><img src="images/Ch08_08.png" alt="第一版的自制对象清单" /></p>
<p><em>图 8 - 第一版的自制对象清单</em></p>
<p><strong>哦吼，现在还需要保存 <code>Cat</code>s 了</strong></p>
<p>现在有这么几个选择：</p>
<ol>
<li>
<p>再单独构建一个类，<code>MyCatList</code>，来保存 <code>Cat</code> 的那些对象。这就相当笨拙。</p>
</li>
<li>
<p>仅构建一个类，<code>DogAndCatList</code>，其中有两个不同的数组，作为实例变量，同时还有不同的 <code>add()</code> 方法：<code>addCat(Cat c)</code> 与 <code>addDog(Dog d)</code>。这也是一个笨拙的方法。</p>
</li>
<li>
<p>构造一个可以接收所有 <code>Animal</code> 子类（就目前这种需求规格修改为要添加 <code>Cat</code>s来看，后面肯定还会有其他种类的动物要往里面添加）的、具异质性的 <code>AnimalList</code> 类。这当然是最好的方案了。那么就着手将这个类修改成更具通用性、可以接收所有 <code>Animal</code> 而不仅是 <code>Dog</code>s 的类吧。其中的关键修改，已被标记出来了（代码逻辑没有变，只是把代码中所有的 <code>Dog</code> 修改成了 <code>Animal</code>）。</p>
</li>
</ol>
<p><strong>构建自己的<code>Animal</code>专用清单</strong></p>
<p><img src="images/Ch08_09.png" alt="第二版的 Animal 清单" /></p>
<p><em>图 9 - 第二版的 Animal 清单</em></p>
<p>运行结果：</p>
<pre><code class="language-java">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
Animal added at 0.
Animal added at 1.
</code></pre>
<p><strong>对于不是 <code>Animal</code> 的对象呢? 为什么不构造一个可接收所有东西的通用类呢</strong> ？</p>
<p>你可能猜到了要做的是什么。这里就要将数组类型，与 <code>add()</code> 方法的参数类型，一并修改为<code>Animal</code> 类 <em>之上（above）</em> 的某个东西。某个比 <code>Animal</code> <em>更</em> 通用的、更为抽象的东西。然而怎么才能做到呢？毕竟示例中的 <code>Animal</code> 之上，已经没有超类了呀。</p>
<p>再一次，也许我们可以......</p>
<p>还记得<code>ArrayList</code>的那些方法吗？看看 <code>remove</code>、<code>contains</code>以及 <code>indexOf</code> 这些方法，他们都使用到一个类型为.....的对象，是的，那就是 <code>Object</code>！</p>
<p><em><strong>Java 中的所有类，都是对类 <code>Object</code> 的扩展</strong></em>。</p>
<p>类 <code>Object</code> 是所有类的始祖；他是万事万物的超类。</p>
<p>尽管运用了多态，但还必须创建一个有着接收和返回多态类型方法的类。如果在Java中缺少这么一个可以作为万物始祖的超类，那么Java程序员就无法创建出有着可以接收定制类型，<em>那些他们在编写类似 <code>ArrayList</code> 这样的类时无法想象到的各种各样的类型</em> ，的方法的各种类来（Even if you take advantage of polymorphism, you still have to create a class with methods that take and return your polymorphic type. Without a common superclass for everything in Java, there'd be no way for the developers of Java to create classes with methods that could take your custom types... <em>types they never knew about when they wrote the ArrayList class</em>）。</p>
<p>因此实际上在不知情的情况下，从一开始就已经在构造类 <code>Object</code> 的子类了。 <em><strong>你所编写的每一个类，都是对 <code>Object</code> 的扩展</strong></em>，尽管没有提到 <code>Object</code>。但可以看着像是下面这个样子：</p>
<pre><code class="language-java">public class Dog extends Object {}
</code></pre>
<p>等一下，<code>Dog</code> 不是已经扩展了 <code>Canine</code> 了吗？好吧，编译器将让 <code>Canine</code> 去扩展 <code>Object</code>，然而 <code>Canine</code>又是扩展的 <code>Animal</code>。还是没问题，这个时候编译器又会去让 <code>Animal</code> 对 <code>Object</code> 进行扩展。</p>
<p><strong>所有的没有显式扩展另一个类的类，都是隐式地扩展了 <code>Object</code>。</strong> </p>
<p>那么，因为 <code>Dog</code> 扩展了 <code>Canine</code>，他就不算是直接扩展了 <code>Object</code>（但他还是间接扩展了 <code>Object</code>），对于 <code>Canine</code>，也是这样的，不过<code>Animal</code>则是直接扩展了 <code>Object</code>。</p>
<p><img src="images/Ch08_10.png" alt="第三版的数组列表 -- ArrayList" /></p>
<p><em>图 10 - 第三版的数组列表 -- ArrayList</em></p>
<p><strong>那么在这个超超元类的 <code>Object</code> 中究竟有些什么呢</strong> ？</p>
<p><em>So what's in this ultra-super-megaclass <code>Object</code></em> ?</p>
<p>假如你是Java，那么你会希望每个对象都有些什么行为（方法）呢？ 嗯...，来查一下吧，一个可以检查两个对象是否相等的方法如何？一个可以获取到对象的确切类类型的方法怎样？或许有那么一个可以获取到对象的哈希码的方法，从而可以在哈希表中去使用到对象会更好（关于Java的哈希表，会在第16章中涉及）；哦，还有一个更不错的，可以打印出对象字符串讯息的方法。</p>
<p>就好像施了魔法一样，类 <code>Object</code> 确实有着实现这四个目的的方法。虽然他还有着其他方法，但这里只关注这四个。</p>
<p><img src="images/Ch08_11.png" alt="所有类都会继承到类 Object 的那些方法" /></p>
<p><em>图 11 - 所有类都会继承到类 Object 的那些方法</em></p>
<h2 id="答疑-2"><a class="header" href="#答疑-2">答疑</a></h2>
<ul>
<li><strong>类 <code>Object</code> 是抽象类吗</strong> ？</li>
</ul>
<blockquote>
<p>不是。这不是通常意义上的抽象类（Well，not in the formal Java sense anyway）。由于 <code>Object</code>具有可被所有类继承、且开箱即用的方法实现代码，因此他是非抽象类。</p>
</blockquote>
<ul>
<li><strong>那么可以重写 <code>Object</code>中的这些方法吗</strong> ？</li>
</ul>
<blockquote>
<p>可以重写其中一些。但有些方法是被标记为 <code>final</code>的，因此就不能对其进行重写。对于 <code>hashCode()</code>、<code>equals()</code>及<code>toString()</code>三个方法，是强烈建议进行重写的，本书后面会叫你怎么去重写他们。对于另一些代码，比如<code>getClass()</code>，他们就必须以特定的、有保证的方式运作。</p>
</blockquote>
<ul>
<li><strong>既然 <code>ArrayList</code> 的那些方法，对于使用 <code>Object</code> 已经足够通用，那写 <code>ArrayList&lt;DotCom&gt;</code> 又有什么意义呢？是将 <code>ArrayList</code>限制为只能保存 <code>DotCom</code> 对象的意思吗</strong> ？</li>
</ul>
<blockquote>
<p>那确实是在对其进行限制。在 Java 5.0 版本之前，<code>ArrayList</code>就是无法施加限制的。不过时至今日，在Java 5.0中，通过 <code>ArrayList&lt;Object&gt;</code> 这种方式对其进行限制，已成为必须的了。<code>ArrayList&lt;Object&gt;</code> 的意思，就是 <strong>一个被限制为属于对象的任何东西的 <code>ArrayList</code></strong> ，也就是Java中从任何类类型初始化得来的任何对象。后面会讨论到这种新的  <code>&lt;type&gt;</code> 语法。</p>
</blockquote>
<ul>
<li><strong>好的，回到类 <code>Object</code> 作为非抽象的问题上（那么我猜那意味着他是具体的），我们该 <em>怎样</em> 构造出一个 <code>Object</code> 的对象？ 那样做不就和构建一个 <code>Animal</code> 的对象一样古怪了吗</strong> ？</li>
</ul>
<blockquote>
<p>不错的问题！确实有构造 <code>Object</code> 实例的需求。在有的时候，就是只需要一个作为对象使用的通用对象。也就是一个 <em>轻量级（lightweight）</em> 对象。就目前所知，<code>Object</code>类型的实例最常用在线程同步上（将在第15章涉及，By far, the most common use of an instance of type <code>Object</code> is for thread synchronization）。现在可以不管这个，只需知道即使可以构造出 <code>Object</code> 的对象，也很少会用到这个。</p>
</blockquote>
<ul>
<li><strong>那么可以说 <code>Object</code> 类型的主要目的，就是用作多态下的参数和返回值类型，就像是在 <code>ArrayList</code>中那样吗</strong> ？</li>
</ul>
<blockquote>
<p><code>Object</code>类的主要目的有两个：其一是对于那些需要处理自己或其他人编写的所有类的方法，作为他们的多态类型；再者就是，为Java中所有对象，提供给他们在运行时所需要的方法代码（把这些代码都放在类 <code>Object</code>中，那么所有类都能继承到这些代码）。在 <code>Object</code>中的一些重要方法与线程相关，在本书的后面会看到。</p>
</blockquote>
<ul>
<li><strong>既然使用多态类型有这么多好处，那为什么不把 <em>所有</em> 方法都做成接收和返回 <code>Object</code> 类型呢</strong> ？</li>
</ul>
<blockquote>
<p>呃......想想这样做会发生什么。那样肯定会完全破坏“类型安全”（For one thing, you would defeat the whole point of 'type-safty'），而“类型安全”正是Java语言中，对代码的最大保护机制。Java的类型安全机制，确保不会在计划的对象类型之外，请求到其他对象类型。比如，让一个 <code>Ferrari</code> （以为是一个 <code>Toaster</code>）去烤面包。
事实上即使在各处使用了 <code>Object</code> 类型的引用变量，也不必担心会出现热烘烘的<code>Ferrari</code>情形。因为当那些类型是由 <code>Object</code> 引用变量类型表示时，Java 就会将其视为类型 <code>Object</code> 的一个实例变量。那么就只能调用类 <code>Object</code> 中声明的那些方法！所以假如这样写代码：</p>
</blockquote>
<pre><code class="language-java">Object o = new Ferrari ();
o.goFast (); // 这是非法的！
</code></pre>
<blockquote>
<p>这样的代码甚至无法通过编译器检查。
Java作为强类型语言，其编译器将就所调用对象的某个方法，看这个对象是否实际有能力响应，进行检查（Because Java is a strongly-typed language, the compiler checks to make sure that you're calling a method on an object ）。也就是说，在调用某个对象引用变量上的方法时，只能调用该引用类型确实有的方法。在后续章节，会详细讨论Java的“类型安全”特性，所以即使现在还不是很明白，也没有关系。</p>
</blockquote>
<h2 id="使用多态的object类型的引用变量的代价"><a class="header" href="#使用多态的object类型的引用变量的代价">使用多态的<code>Object</code>类型的引用变量的代价</a></h2>
<p>在开始将类型<code>Object</code>用于所有超灵活参数级返回值之前，需要考虑一些将类型 <code>Object</code>作为参数使用时的一些小问题。同时记住这里不会涉及构造类型<code>Object</code>实例；这里讲的是构造其他类型的实例，而只是使用类型<code>Object</code>做引用变量（we're talking about making instances of some other type, but using a reference of type <code>Object</code>）。</p>
<p>在将某个对象放入 <code>ArrayList&lt;Dog&gt;</code>时，是作为 <code>Dog</code>被放入进去的，同时取出来时也是一个 <code>Dog</code>:</p>
<pre><code class="language-java">ArrayList&lt;Dog&gt; myDogArrayList = new ArrayList&lt;Dog&gt;;

Dog aDog = new Dog ();
myDogArrayList.add (aDog);
Dog d = myDogArrayList.get(0);
</code></pre>
<p>而如果将其声明为了 <code>ArrayList&lt;Object&gt;</code> 时，会怎样呢？在要构造一个名义上要保存任何种类的<code>Object</code>的 <code>ArrayList</code>时，就可以这样声明：</p>
<pre><code class="language-java">ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;;
Dog aDog = new Dog();
myDogArrayList.add(aDog);
</code></pre>
<p>但在尝试获取这个<code>Dog</code>对象，并将其赋值给一个 <code>Dog</code> 的引用变量时，会怎样呢？</p>
<pre><code class="language-java">Dog d = myDogArrayList.get(0);
</code></pre>
<blockquote>
<p>这样是行不通的。这不会被编译！！ 在使用<code>ArrayList&lt;Object&gt;</code>时，那么 <code>get()</code> 方法将返回类型 <code>Object</code>。编译器知道对象是从<code>Object</code>继承的（在其继承树的某处），但不知道对象就是 <code>Dog</code>！！</p>
</blockquote>
<p><em><strong>所有从 <code>ArrayList&lt;Object&gt;</code> 中出来的东西，都是作为类型 <code>Object</code> 的一个引用变量，而不管他原本是个什么样的对象，或者在将其加入到清单时他的引用变量类型是什么</strong></em>。</p>
<p><img src="images/Ch08_12.png" alt="ArrayList&lt;Object&gt;对象的存入与取出" /></p>
<p><em>图 12 - <code>ArrayList&lt;Object&gt;</code>对象的存入与取出</em></p>
<p><strong>当一个 <code>Dog</code> 不再像一个 <code>Dog</code> 那样行事时</strong></p>
<p>将所有东西都多态地处理，看成是一个 <code>Object</code>，这样做的问题就是，这些对象将失去（暂时，而不是永久）他们自己的特质。<code>Dog</code>将失去他的狗性。下面是一个传入<code>Dog</code> 类型对象，返回同一 <code>Dog</code> 对象，不过将返回类型声明为了类型 <code>Object</code> 而不是 <code>Dog</code> 的示例：</p>
<pre><code class="language-java">public void go () {
    Dog aDog = new Dog();
    Dog sameDog = getObject (aDog); 
}

public Object getObject (Object o) {
    return o;
}
</code></pre>
<blockquote>
<p>上面的 <code>Dog sameDog = getObject (aDog)</code> 是不会工作的！就是该方法返回了一个到与参数所引用的 <code>Dog</code> 非常相似的引用变量，但返回类型 <code>Object</code> 就意味着编译器不会让你将返回的引用变量，赋值给除了 <code>Object</code> 之外的任何类型的变量。
<code>getObject()</code> 方法中返回的是同一个 <code>Dog</code> 的引用，但是作为类型 <code>Object</code> 返回的。这样做仍然是合法的。注意：就与使用 <code>ArrayList&lt;Object&gt;</code> 而非 <code>ArrayList&lt;Dog&gt;</code> 时的 <code>get()</code>方法类似。</p>
</blockquote>
<pre><code class="language-console">incompatible types: Object cannot be converted to Dog
</code></pre>
<blockquote>
<p>在所有东西都可以通过对 <code>Object</code> 的 <code>IS-A</code> 测试，所以可将所有东西都赋值给类型为 <code>Object</code> 的引用变量，而正因为如此，修改为下面这样，就可以运行（尽管这样的代码没有什么用处，马上就能见到）。因为对于Java中的所有类，在其继承树的顶端，都是 <code>Object</code>，正因为如此，Java 中所有东西，都是类型 <code>Object</code> 的实例。</p>
</blockquote>
<pre><code class="language-java">public void go () {
    Dog aDog = new Dog ();
    Object sameDog = getObject (aDog);
}

public Object getObject (Object o) {
    return o;
}
</code></pre>
<p><strong>这些无法叫唤的对象</strong></p>
<p><img src="images/Ch08_13.png" alt="到具体类型引用变量的类型为 Object 的多态引用变量" /></p>
<p><em>图 13 - 到具体类型引用变量的类型为 <code>Object</code> 的多态引用变量</em></p>
<p>到这里就清楚了，在某个对象是由声明为类型 <code>Object</code>的变量引用时，就无法将其赋值给声明为对象具体类型的变量了。还知道在返回值或参数类型被声明为类型 <code>Object</code>时，这种情况就会发生，如如同上面的示例，在将对象放入到一个使用 <code>ArrayList&lt;Object&gt;</code>的、类型为 <code>Object</code> 的 <code>ArrayList</code>中那样。然而这样会有什么影响呢？使用一个 <code>Object</code>的引用变量来表示一个 <code>Dog</code>对象会是一个问题吗？下面就来尝试在原本是<code>Dog</code>但编译器以为是<code>Object</code>的对象上，调用一下<code>Dog</code>的一些方法试试：</p>
<pre><code class="language-java">Object o = al.get(index);
int i = o.hashcode();
o.bark();
</code></pre>
<blockquote>
<p>其中的 <code>int i =o.hashcode();</code> 语句没有问题，类<code>Object</code>是有 <code>hashCode()</code>方法的，因此可以在 Java中的所有对象上调用这个方法。
<code>o.bark();</code>语句就不会被编译！<code>o</code> 做不了这事！类 <code>Object</code> 对 <code>bark()</code>是毫无头绪的。就是作为人类是知道位于 <code>index</code>处的对象实际上是一个 <code>Dog</code>对象，但作为机器的编译器是不知道的。</p>
</blockquote>
<p><strong>编译器根据 <em>引用变量</em> 类型，而不是实际的对象类型，来判断是否可以调用某个方法</strong>。</p>
<p>就算作为人类，知道那个对象可以（“老实说，他确实是个 <code>Dog</code>......”）调用某个方法，编译器还是指挥将其视为一个通用的 <code>Object</code>。就编译器所能知道的全部来讲，将在那里放了个 <code>Button</code> 对象，抑或是一个 <code>Microwave</code> 对象，或其他任何的不知道如何去叫唤的对象。</p>
<p>在使用某个引用变量时，编译器将检查 <em><strong>引用变量</strong></em> 的类型，而不是 <em><strong>对象</strong></em> 本身的类型，来得出是否可以调用那个引用变量上的方法。</p>
<p><img src="images/Ch08_14.png" alt="引用变量上所能调用方法的范围" /></p>
<p><em>图 14 - 引用变量上所能调用方法的范围</em></p>
<h2 id="了解核心的-object"><a class="header" href="#了解核心的-object">了解核心的 <code>Object</code></a></h2>
<p>对象包含了 <em><strong>所有</strong></em> 其从他的各个超类所继承的东西。也就意味着 <em><strong>每个</strong></em> 对象 -- 不管他的具体类类型是什么 -- 都是类 <code>Object</code> 的一个实例。那也意味着，在 Java 中的所有对象，不仅可以作为一个 <code>Dog</code>、<code>Button</code>、<code>Snowboard</code>看待，同时都可以作为一个 <code>Object</code> 看待。在写出 <code>new Snowboard()</code>时，就得到一个位于内存堆上的对象 -- 一个 <code>Snowboard</code> 对象 -- 而这个 <code>Snowboard</code> 则是在作为他自身一部分的、一个表示 <code>Object</code> 对象的内核周围，封装上各层超类得来的。</p>
<p><img src="images/Ch08_15.png" alt="Object 是所有对象的内核" /></p>
<p><em>图 15 - Object 是所有对象的内核</em></p>
<p><em><strong>“多态” 意即 “多种形式”（&quot;Polymorphism&quot; means &quot;many forms&quot;）</strong></em>。</p>
<p>比如在上面的示例中，就 <strong>可将 <code>Snowboard</code> 既可以视为 <code>Snowboard</code>，也可视为 <code>Object</code></strong>。</p>
<blockquote>
<p><em><strong>在将某个对象放入到 <code>ArrayList&lt;Object&gt;</code>中后，就只能将这个对象视为 <code>Object</code> 了，而与在将其放入时他的类型无关</strong></em>。
<em><strong>在从某个 <code>ArrayList&lt;Object&gt;</code> 取得一个引用变量时，该引用变量始终时类型 <code>Object</code>的</strong></em>。
<em><strong>也就是得到的是一个<code>Object</code>的遥控器</strong></em>。</p>
</blockquote>
<p><img src="images/Ch08_16.png" alt="同一对象不同引用变量的区别" /></p>
<p><em>图 16 - 同一对象不同引用变量的区别</em></p>
<h2 id="将某个对象引用变量强制转换为其真实类型"><a class="header" href="#将某个对象引用变量强制转换为其真实类型">将某个对象引用变量，强制转换为其真实类型。</a></h2>
<p><strong>Casting an object reference bask to its <em>real</em> type</strong>.</p>
<p>虽然是用 <code>Object</code> 类型引用变量来表示的 <code>Dog</code> 对象，但该对象实际仍是一个 <code>Dog</code> 对象，但在要调用一个特定于 <code>Dog</code>的方法时，就需要一个声明为类型 <code>Dog</code>的引用变量。在可以肯定该对象真的是一个 <code>Dog</code>时，就可以通过拷贝那个 <code>Object</code> 引用变量，并使用一个强制转换运算符<code>(Dog)</code>，来强制那个拷贝成为一个 <code>Dog</code>的引用变量，从而构造出一个新的到该对象的 <code>Dog</code> 引用变量。现在就可以使用这个新构造出来的 <code>Dog</code> 引用变量，来调用类 <code>Dog</code> 中的方法了。</p>
<pre><code class="language-java">Object o = al.get(index);
Dog d = (Dog) o;
d.roam();
</code></pre>
<blockquote>
<p>其中 <code>Dog d = (Dog) o;</code>语句，强制将 <code>o</code> 转换成我们可以肯定的就在那里的 <code>Dog</code>。</p>
</blockquote>
<p><img src="images/Ch08_17.png" alt="拷贝一个 Object 类型的引用变量，并将其强制转换为 Dog类型" /></p>
<p><em>图 17 - 拷贝一个 <code>Object</code> 类型的引用变量，并将其强制转换为 <code>Dog</code>类型</em></p>
<p>若不确定那个对象是一个 <code>Dog</code>，则可以使用 <code>instanceof</code> 运算符进行检查。这是因为在进行强制转换时出错的话，就会在运行时收到<code>ClassCastException</code>，并进入一个程序挂起。</p>
<pre><code class="language-java">if (o instanceof Dog) {
    Dog d = (Dog) o;
}
</code></pre>
<p><strong>现在知道Java有多么重视 <em>引用</em> 变量的类中的方法了吧</strong>。</p>
<p>只有引用变量的类中有着某个方法，才能对其引用对象上的那个方法进行调用（You can call a method on an object <em>only</em> if the class of the reference variable has that method）。</p>
<p>回想一下类中作为合约的那些 <code>public</code> 方法，即对外界有关可以完成的事情的许诺。</p>
<p>在编写某个类时，总是会对外部代码 <em>暴露</em> 一些方法。<em>暴露</em> 某个方法即是要令到某个方法可被访问，这通常通过将其标记为 <code>public</code> 实现。</p>
<p>设想这样的情景：正在编写一个小企业的账户系统。一个为 “西蒙冲浪用品店”定制的应用。作为一名良好的代码重用者，根据某个 <code>Account</code>类的文档，发现该类正好能满足这个应用的需求。每个账户实例，代表着该店铺的一名顾客的账户。那么这里就会考虑在自己的业务逻辑中，当意识到要获取某个账户余额时，去调用某个账户对象上的 <code>credit()</code>及<code>debit()</code>方法。毫无问题 -- 因为会有一个 <code>getBalance()</code>方法可以很好的做到。</p>
<p>除非......在调用 <code>getBalance()</code> 方法后，运行时整个事情失控。忘掉 <code>Account</code> 类的文档吧，他根本就没有那个方法。</p>
<p>但这不会发生在我们身上的。因为每次在引用变量上使用<code>.</code>运算符（<code>a.doStuff()</code>），编译器都会查看该 <em>引用变量</em> 的类型（也就是 <code>a</code> 所声明的类型），并对那个类进行检查以确保其有着那个方法（<code>doStuff()</code>），且那个方法确实接收传递给他的参数，并返回所期望得到值的类型。</p>
<p><strong>只要记住，编译器就参考变量的类进行检查，而不是对 <code>=</code> 另一端的实际对象的类进行检查</strong>。</p>
<h2 id="在需要修改合约时怎么办"><a class="header" href="#在需要修改合约时怎么办">在需要修改合约时，怎么办？</a></h2>
<p>好的，假设你是一个 <code>Dog</code> （对象/实例）。那么你的 <code>Dog</code>类就不是定义何为你的 <em>唯一</em> 合约。记住，你还从你的所有超类，继承到一些可访问（accessible, 通常就是 <code>public</code>）方法。</p>
<p>确实，你的 <code>Dog</code> 类定义了一份合约。</p>
<p>但不是你的合约的 <em>全部</em>。</p>
<p><strong>类 <code>Canine</code> 中的所有东西，是你的合约的一部分</strong> 。</p>
<p><strong>类 <code>Animal</code> 中的所有东西，是你合约的一部分</strong> 。</p>
<p><strong>类 <code>Object</code> 中的所有东西，是你合约的一部分</strong> 。</p>
<p>通过 <code>IS-A</code> 测试，你都是这些事物 -- <code>Canine</code>、<code>Animal</code> 以及 <code>Object</code> 的一员。</p>
<p>然而假如那个在 <code>Animal</code> 模拟程序中涉及了你的类的那个人，现在想要在一个有关 <code>Animal</code> 对象的 “Science Fair Tutorial” 的应用中使用你（<code>class Dog</code>）的话，会怎样呢？</p>
<p>好的，现在假设你就是那名类 <code>Dog</code> 的程序员。没问题吧？只要往类 <code>Dog</code> 里加入几个方法就可以了。通过加入方法，就不会破坏其他人的代码，这是因为你并没有碰到那些其他人可能会调用的、<code>Dog</code>对象上的既有方法。</p>
<p>你发现了这样的方法的劣势了吗（将 <code>Pet</code>的那些方法，加入到 <code>Dog</code>类可以吗）？</p>
<p><strong>脑力时间</strong></p>
<p>假如你是类 <code>Dog</code>的程序员，而需要将 <code>Dog</code>修改为可以干 <code>Pet</code> 的事情，你会做些什么。我们知道可以将新的 <code>Pet</code> 的行为（方法），添加到<code>Dog</code>类就可以，而且不会破坏其他人的代码。</p>
<p>但是......这是一个 <code>PetShop</code> 应用。他不光有 <code>Dog</code>s！同时如果有人要在一个有着野狗的应用中使用你的 <code>Dog</code>类时怎么办？你只是在考虑你的选项可能会怎样，而没有考虑Java怎么来处理这些事。想想你该怎样去修改那些 <code>Animal</code> 类，来包含进 <code>Pet</code> 的行为，从而解决这个问题吧。</p>
<p>现在停下来思考一下，在下一页就会揭晓答案。</p>
<p>（如果直接看答案，就会让练习没有意义，也让你失去燃烧脑力的机会）</p>
<p><strong>先来看看在 <code>PetShop</code>应用中，重用原有一些类的各个设计选项</strong></p>
<p>接下来的几页中，将贯穿几种可能。不会关注后续各种情形下 Java 是否可以切实做到。在各种取舍中求得平衡后，就自然会跨过这条沟壑。</p>
<h3 id="选项一"><a class="header" href="#选项一">选项一</a></h3>
<p>这是容易的路径，将 <code>Pet</code> 的方法放入到类 <code>Animal</code>中。</p>
<p><img src="images/Ch08_18.png" alt="合约的修改：选项一，把所有宠物的方法，放在类 Animal中" /></p>
<p><em>图 18 - 合约的修改：选项一，把所有宠物的方法，放在类 <code>Animal</code>中</em></p>
<p><strong>优点</strong> ：</p>
<p>所有动物将直接继承到这些 <code>Pet</code> 的行为。一点也不必修改既有的那些 <code>Animal</code> 的子类，同时往后创建的所有 <code>Animal</code>子类，也都将获益于对这些方法的继承。这样，类<code>Animal</code>就可以在所有打算将 <code>Animal</code>作为宠物对待的程序中，作为多态类型加以使用。</p>
<p><strong>缺点</strong> ：</p>
<p>那么......，你什么时候在宠物店看到过河马？狮子？狼？这说明将宠物的那些方法，给到那些非宠物上面，是很危险的。</p>
<p>还有，几乎可以肯定的是，将不得不去修改诸如 <code>Dog</code> 和 <code>Cat</code> 这样的宠物类，因为狗子和猫咪基本上在宠物行为的实现上，有着巨大的差别。</p>
<h3 id="选项二"><a class="header" href="#选项二">选项二</a></h3>
<p>在选项一的基础上，将宠物的那些方法，放在类 <code>Animal</code> 中，但这次是将这些方法标记为 <code>abstract</code>，从而强制让<code>Animal</code>的那些子类重写这些方法。</p>
<p><img src="images/Ch08_19.png" alt="合约的修改：选项二，把所有宠物的抽象方法，放在类 Animal中，继承树中的每个具体类，都必须加以实现" /></p>
<p><em>图 19 - 合约的修改：选项二，把所有宠物的抽象方法，放在类 <code>Animal</code>中，继承树中的每个具体类，都必须加以实现</em></p>
<p><strong>优点</strong>：</p>
<p>这样就可以在不必让那些非宠物的动物们按照宠物的那些方法（比如<code>beFriendly()</code>）行事的同时，又能享受到选项一的那些优势。所有<code>Animal</code>类都有着这些方法（因为这些方法放在类 <code>Animal</code>中），但因为这些方法是抽象的，因此那些非宠物的 <code>Animal</code>类就不会继承到任何功能。所有类都必须重写这些方法，但他们可以让这些方法“不做事”。</p>
<p><strong>缺点</strong> ：</p>
<p>因为在 <code>Animal</code>类中的那些宠物方法都是抽象的，那么所有 <code>Animal</code>的子类都被强制要求去实现全部的这些宠物的方法。（记住，所有抽象方法，都必须由继承树下部第一个具体子类去实现。）这是多么浪费时间的一件事！就必须坐在那里，把每个宠物的方法，在所有那些具体非宠物类，以及所有将来的那些子类中，都要敲入一遍。同时也没有解决那些非宠物的动物，在干着宠物的那些事情的问题（因为这些非宠物从类<code>Animal</code>继承到的宠物的功能），那么这样的合约是不良的。就算在非宠物那里这些宠物的方法不干任何事情，那些非宠物类，还是向外界宣告了，他们有着这些宠物的方法。</p>
<p>这种方式看起来一点也不好。那么把除开某种<code>Animal</code>类型所需的所有东西都装进类<code>Animal</code>，看起来是不对的。除非是把所有 <code>Animal</code> 子类都需要的才装进类<code>Animal</code>。</p>
<h3 id="选项三"><a class="header" href="#选项三">选项三</a></h3>
<p>将那些宠物的方法，只放入到这些宠物所在的类中。</p>
<p><img src="images/Ch09_20.png" alt="合约的修改：只将宠物的那些方法，放入到可以成为宠物的那些类中" /></p>
<p><em>图 19 - 合约的修改：只将宠物的那些方法，放入到可以成为宠物的那些类中</em></p>
<p><strong>优点</strong> :</p>
<p>再也不必担心河马会在门口欢迎你或舔你的脸了。宠物的那些方法，现在就在属于他们的地方，且只在属于他们的地方。狗子们可以实现这些方法，同时猫咪们也可以实现这些方法。但不是每种动物都必须知道这些方法。</p>
<p><strong>缺点</strong> ：</p>
<p>这种方法有两大问题。首先，必须就某个协议达成一致意见，同时所有当前及将来的那些宠物的 <code>Animal</code>类的程序员，也必须 <strong>了解</strong> 该协议。所谓协议，指的是那些确定下来的那些所有宠物都具有的方法。没有任何东西来承载这个宠物合约（The pet contract without anything to back it up）。那么如果某个程序员在理解这个协议时出了一点问题时后怎样呢？比如说，某个接收字符串的方法，在被错误的给与了整数时，或者把 <code>beFriendly()</code> 错误的命名为了 <code>doFriendly()</code>？因为这个方法没有放在合约中，编译器就没有办法帮你检查是否正确地实现这些宠物的方法。就会有人随后就使用到这些宠物的 <code>Animal</code>类，并发现这些类并不是所有都能正常工作。</p>
<p>其次，无法再对这些宠物的方法，使用多态机制了。所有需要使用到宠物行为的类，就都必须了解每个的宠物类！也就是说，现在再也不能把 <code>Animal</code>当作多态类型了，因为编译器不允许你在 <code>Animal</code> 引用变量上调用某个宠物的方法（即使那确实是一个 <code>Dog</code> 对象），因为 <code>Animal</code> 没有这个方法。</p>
<p><strong>那么我们真正需要的是什么呢</strong> ？</p>
<ul>
<li>一种只在宠物类中才有的宠物行为的方式（A way to have pet behavior in just the pet classes）</li>
<li>一种不需要重复的键盘输入，就能确保所有宠物类都具有同样的所定义全部方法的方式（这些方法名字相同、参数相同、同样的返回值类型、不会有找不着的方法等等），且所有程序员都能正确获取到这些方法。</li>
<li>一种可以利用上多态优势，以便在无需对每个、每种宠物类，都使用参数、返回值类型及数组的情况下，所有宠物都能被调用到他们的方法（A way to take advantage of polymorphism so that all pets can have their pet methods called, without having to use arguments, return types, and arrays for each and every pet class）。</li>
</ul>
<p><strong>看起来似乎需要在顶部放置 <em>两个</em> 超类</strong>。</p>
<p><img src="images/Ch08_21.png" alt="顶部有 Animal 和 Pet 两个超类的动物继承树" /></p>
<p><em>图 21 - 顶部有 <code>Animal</code> 和 <code>Pet</code> 两个超类的动物继承树</em></p>
<p><em>这种 “两个超类” 的方案，只有一个问题</em> ......</p>
<p>** 这种做法，叫做 “多重继承”，这样做可能成为 <em>相当糟糕的事情</em>**。</p>
<p>当然，这要是能在 Java 中做到才能称得上是“相当糟糕的事”。</p>
<p>显然，Java是不允许多重继承的。因为多重继承有着著名的 “致命死亡钻石”问题（a problem known as The Deadly Diamond of Death）。</p>
<p><img src="images/Ch08_22.png" alt="致命死亡钻石问题，the Deadly Diamon of Death" /></p>
<p><em>图 22 - 致命死亡钻石问题，the Deadly Diamon of Death</em></p>
<p>允许致命死亡钻石的语言，因为不得不加入特殊规则来解决潜在的歧义，从而会带来一些恶心的复杂性。额外的那些规则，除了意味着在学习掌握这些规则时付出额外努力，还有在编写代码时对这些“特别实例”的关注。Java语言作为一种简单的语言，有着不会在某些情形下就随意改变的一致性规则。因此Java（与 C++ 不一样）就不用你去考虑这个致命死亡钻石问题。但这又回到了最初的问题！<em>怎么去解决这个 <code>Animal</code>/<code>Pet</code> 问题</em>？</p>
<h2 id="使用接口来拯救"><a class="header" href="#使用接口来拯救"><a id="interface_rescue"></a>使用接口来拯救！</a></h2>
<p><strong>Interface to the rescue</strong>!</p>
<p>Java给到了一个解决方案。就是 <em>接口</em>。这指的不是 <em>GUI</em> 中的接口，也不是通常说的接口，如“那是 <code>Button</code> 类 API 的公开接口”中的接口，这里的接口，是 Java 语言的关键字 <code>interface</code>。</p>
<p>Java <code>interface</code> 在不带来致命死亡钻石（the Deadly Diamon of Death, DDD）伤害的同时，又带来了多重继承的大部分多态好处，从而解决了多重继承的问题。</p>
<p><code>interface</code> 避开 DDD 那些坑的方式，惊人的简单：<em><strong>把所有方法做成抽象的方法</strong></em>！照这种方式，子类就 <strong>必须</strong> 实现这些方法（记住，抽象的方法，必须在第一个具体类中实现），因此在运行时JVM不会被到底应该调用两个继承版本中的哪一个搞晕。</p>
<p><img src="images/Ch08_23.png" alt="Java 的 interface" /></p>
<p><em>图 23 - Java 的 <code>interface</code></em></p>
<p><strong>这样来定义一个 <code>interface</code></strong>:</p>
<pre><code class="language-java">public interface Pet {...}
</code></pre>
<blockquote>
<p>使用关键字 <code>interface</code> 而不是 <code>class</code>。</p>
</blockquote>
<p><strong>这样来实现一个 <code>interface</code></strong>:</p>
<pre><code class="language-java">public class Dog extends Canine implements Pet {...}
</code></pre>
<blockquote>
<p>使用关键字 <code>implements</code> 带上 <code>interface</code> 的名字。注意在实现某个 <code>interface</code>时，同时仍然好对某个类进行扩展。</p>
</blockquote>
<p><img src="images/Ch08_24.png" alt="Pet interface的构造与实现" /></p>
<p><em>图 24 - Pet <code>interface</code>的构造与实现</em></p>
<h2 id="答疑-3"><a class="header" href="#答疑-3">答疑</a></h2>
<ul>
<li><strong>等一下，由于不能把任何实现代码放在 <code>interface</code>s 里，那么这些 <code>interface</code>s 就没有真正带来多重继承。如果所有方法都是抽象的，那么 <code>interface</code>究竟有什么好处呢</strong>？</li>
</ul>
<blockquote>
<p>多态机制，多态机制，多态机制。使用 <code>interface</code>s 在灵活性上是终极的，因为使用 <code>interface</code>s 而不是具体子类（甚至抽象的超类类型），作为参数或返回值类型，就可以以实现了那个 <code>interface</code>的所有具体类类型，进行传递（Interfaces are the ultimate in flexibility, because if you use interfaces instead of concrete subclasses(or even abstract superclass types) as arguments and return types, you can pass anything that implements that interface）。同时可以试想一下， 在具备 <code>interface</code> 的情况下，类就不必只来自单一的继承树了。某个类可以对一个类进行扩展，再去实现某个 <code>interface</code>。而另一个类在实现同一个接口的同时，可以来自完全不同的继承树！所以就可以根据对象所扮演的角色，而不是其从哪个类类型初始化得来去对待他（So you can get treat an object by the role it plays, rather than by the class type from which it was instantiated）。</p>
</blockquote>
<blockquote>
<p>事实上，在运用 <code>interface</code> 来编写代码后，甚至不需要将某个超类给到其他人去扩展。只需要给他们一个接口然后告诉他们：“这就够了，我不在乎你那边的继承结构是怎样的，只需要实现这个 <code>interface</code> 就可以了”。</p>
</blockquote>
<blockquote>
<p>因为<code>interface</code>中的大多数方法，在进行通用实现后都没有什么意义，因此不将实现代码放在<code>interface</code>里头这种实践，对大多数优良设计就不再是个问题。也就是说，即使不强制将这些大多数<code>interface</code>方法设置为抽象方法，这些方法也需要被重写。</p>
</blockquote>
<p><img src="images/Ch08_25.png" alt="来自不同继承树的类，可以实现同一个interface" /></p>
<p><em>图 25 - 来自不同继承树的类，可以实现同一个<code>interface</code></em></p>
<p>在将 <em>类</em> 作为多态类型（比如某个类型为 <code>Animal</code> 的数组，或者取 <code>Canine</code> 类型参数的某个方法）时，该类型下的对象，就只能来自同样的继承树。而且不能时继承树的所有地方，这些对象只能来自用作多态类型的超类的某个子类。类型 <code>Canine</code>的参数，就只能接受一个 <code>Wolf</code>或者<code>Dog</code>，而不能接受 <code>Cat</code> 或 <code>Hippo</code>。</p>
<p>但在使用 <em><strong><code>interface</code></strong></em> 作为多态类型时（比如一个 <code>Pet</code> 的数组），该 <code>interface</code> 类型下的变量所指的对象，就可以来自继承树的任意位置了。唯一要求是这些对象，是来自某个实现了该 <code>interface</code> 的类。Java API中允许不同继承树中的类对同一 <code>interface</code> 进行实现，是非常关键的。想要某个对象能够将其状态保存到文件中？那么对 <code>Serializable</code> 这个 <code>interface</code> 进行实现就可以了。想要一些对象在一个单独的执行线程中运行他们的方法？那么对 <code>Runable</code> 这个 <code>interface</code>进行实现就可以了。明白了吧。在后续章节将了解更多有关 <code>Serializable</code> 和 <code>Runable</code> 这两个 <code>interface</code>的细节，这里就只是要记住，不管类来自继承树的哪里，都可能需要继承这些 <code>interface</code>s。几乎 <em>所有</em> 类，都是希望能进行保存或执行的。</p>
<p><em><strong>更重要的是，一个类可以实现多个 <code>interface</code>s</strong></em>！！</p>
<p>某个 <code>Dog</code> 对象 <code>IS-A</code> <code>Canine</code>，同时 <code>IS-A</code> <code>Animal</code>，还 <code>IS-A</code> <code>Object</code>，这些都是通过继承得来的。但经由实现 <code>interface</code>得来的一个 <code>Dog</code> <code>IS-A</code> <code>Pet</code>，同时该<code>Dog</code>还可以实现其他的接口。可以这样写：</p>
<pre><code class="language-java">public class Dog extends Animal implements Pet, Saveable, Paintable {...}
</code></pre>
<blockquote>
<h2 id="牢记"><a class="header" href="#牢记">牢记</a></h2>
<p>红玫瑰，白牡丹</p>
<p>扩展一，实现俩</p>
<p>Java重视家庭观</p>
<p><strong>父辈只能有一个</strong>！某个Java类只能有 <strong>一个</strong> 父辈（超类），而正是那个父辈，定义了你是谁。但你可以实现多个 <code>interface</code>s, 这些 <code>interface</code>s 定义了你可以扮演的角色。</p>
</blockquote>
<p><em><strong>怎样才知道，究竟应该构造一个类，一个超类，一个抽象类，还是一个 <code>interface</code>呢</strong></em>？</p>
<ul>
<li>
<p>在新的类不能通过既有类型的 <code>IS-A</code> 测试时，就要构造一个不对其他类（当然除了 <code>Object</code>）进行扩展的类了</p>
</li>
<li>
<p>仅在需要构造某个类的 <strong>更具体</strong> 版本，且需要重写或加入新的行为时，才去构建一个子类（也就是对某个类进行扩展）</p>
</li>
<li>
<p>在打算为一组子类定义一个 <strong>模板</strong>，且已经有一些所有子类都能使用的实现代码时，就要使用一个抽象类了。如果要保证其他人不能构造出某个类的对象，那么就让这个类作为抽象类。</p>
</li>
<li>
<p>在想要定义对于不论位处哪个继承树的类，都可以扮演的角色时，就要使用一个 <code>interface</code>。</p>
</li>
</ul>
<h3 id="调用某个方法的超类版本"><a class="header" href="#调用某个方法的超类版本">调用某个方法的超类版本</a></h3>
<ul>
<li><em><strong>在构造某个具体子类时，既要重写某个方法，又需要该方法的超类版本的行为，该怎么办？也就是说，不希望通过重写来替换掉这个方法，而只想把一些额外特定代码，添加到这个方法</strong></em>。</li>
</ul>
<blockquote>
<p>呃... 请想想“扩展” 一词的意思。良好“面向对象”设计的一个方面，就是对如何去设计那些为了重写的代码的关注。也就是说，在抽象类中所写下的方法代码，就应该是可以支撑到具体实现的那些足够通用的代码（One area of good OO design looks at how to design concrete code that's meant to be overridden. In other words, you write method code in, say, an abstract class, that does work that's generic enough to support typical concrete implementations）。不过这些具体代码，并不足以应对 <em>全部</em> 特定于子类的工作。因此子类就会重写方法，并通过添加其剩余代码，对类进行 <em>扩展</em>。在子类里使用关键字 <code>super</code> ，就可以调用到某个重写方法的超类版本。</p>
</blockquote>
<p><img src="images/Ch08_26.png" alt="子类对超类方法的调用：关键字 super" /></p>
<p><em>图 26 - 子类对超类方法的调用：关键字 <code>super</code></em></p>
<h2 id="重点"><a class="header" href="#重点">重点</a></h2>
<ul>
<li>在不希望某个类被实例化（也就是不希望有人构造那个类的对象）时，就将该类用关键字 <code>abstract</code> 标记起来；</li>
<li>抽象类可以同时有抽象与非抽象方法；</li>
<li>某个类就算只要有一个抽象方法，就必须被标记为抽象类；</li>
<li>抽象方法没有方法体，同时其声明是以分号（<code>;</code>）结束的（没有花括弧）；</li>
<li>继承树中的第一个具体类，必须实现全部抽象方法；</li>
<li>Java中每个类，都直接或间接是类 <code>Object</code>（<code>java.lang.Object</code>）的子类；</li>
<li>可以 <code>Object</code> 类型的参数和/或返回值类型，来声明方法；</li>
<li>对于某个对象，只能调用作为该对象的引用变量类型的类（或<code>interface</code>）中有的那些方法，这跟该对象实际类型无关。因此引用变量类型为 <code>Object</code> 类型的对象，就只能用于调用类 <code>Object</code>中定义的方法，而与该引用变量实际所指的对象类型无关；</li>
<li>类型 <code>Object</code> 的引用变量，在不使用强制转换运算符的情况下，不能赋值给任何其他类型的引用变量。可使用强制转换，来将一种类型的引用变量，赋值给该类型的子类型的引用变量，但如果内存堆中的对象，与强制类型转换运算不兼容时，运行时就会转换失败。比如：</li>
</ul>
<pre><code class="language-java">Dog d = (Dog) x.getObject(aDog);
</code></pre>
<ul>
<li>从 <code>ArrayList&lt;Object&gt;</code> 中拿出的所有对象的类型，都是 <code>Object</code>（意即除非使用强制类型转换，否则这些对象只能被 <code>Object</code> 类型的引用变量所引用）；</li>
<li>由于多重继承会带来“致命死亡钻石”问题，因此Java中不允许多重继承。这就意味着只能对一个类进行扩展（也就是只能有一个直接的超类）；</li>
<li><code>interface</code> 就像一个 100% 的抽象类。只用于定义抽象方法；</li>
<li>使用关键字 <code>interface</code> ，而不是 <code>class</code>, 来创建 <code>interface</code>；</li>
<li>使用关键字 <code>implements</code> 来实现 <code>interface</code>，比如：</li>
</ul>
<pre><code class="language-java">public class Dog extends Canine implements Pet
</code></pre>
<ul>
<li>类可以实现多个 <code>interface</code>s；</li>
<li>因为 <em><code>interface</code>的全部方法，隐式的都是 <code>public</code> 与 <code>abstract</code> 的</em>，所以实现某个 <code>interface</code> 的类，就必须实现该 <code>interface</code> 的全部方法；</li>
<li>使用关键字 <code>super</code> 来从子类中调用所重写方法的超类版本。比如 <code>super.runReport();</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构造器与垃圾回收对象的生命与死亡"><a class="header" href="#构造器与垃圾回收对象的生命与死亡">构造器与垃圾回收：对象的生命与死亡</a></h1>
<p><strong>对象生下来又死去（Objects are born and objects die）</strong>。你负责了某个对象的生命周期。你决定何时及怎样去 <strong>构造</strong> 他。你决定何时去 <strong>摧毁</strong> 他。即使你没有亲自去 <em>摧毁</em> 某个对象，也是有意无意的 <em>抛弃</em> 了他。而一旦某个对象被抛弃，无情的 <strong>垃圾收集器（Garbage Collector, gc）</strong> 就会让他消失，收回该对象所占用的内存。要编写Java程序，就会创建对象。早晚都会让某些对象死去，否则就会耗尽运行内存。本章将了解对象是如何创建出来的，在他们存活的时候呆在哪里，以及如何高效地留存或弃用他们。这就是说要涉及到内存堆（the heap）、栈（the stack）、作用范围（scope）、构造器、超级构造器（super constructors）、空引用（null references）等等。警告：本章涉及可能令某些人反感的对象死亡的材料。介意者请勿阅读。</p>
<h2 id="栈与堆java万物存在之处"><a class="header" href="#栈与堆java万物存在之处">栈与堆：Java万物存在之处</a></h2>
<p>在了解创建对象涉及到的东西之前，就必须先往后一点。需要了解Java中各种东西都存在于什么地方（以及存在多长时间）。那就要了解栈和堆（the Stack and the Heap）。Java程序员关心内存的两个区域 -- 一个是对象所在的内存堆（the heap），另一个是方法执行（method invocations）与本地变量所在的栈（the stack）。在JVM启动时，就从所在的OS获取到一块内存，并使用这块内存来运行你的Java程序。至于有多少内存，以及后期是否可以调整大小，取决于所运行的JVM版本（以及在何种平台）。不过通常你没有话语权，且在良好编程下，也无需关心（这方面后期会讨论更多）。</p>
<p>已知所有 <em>对象</em> 都存活在可垃圾回收的堆上，而对于那些 <em>变量</em> 在什么地方，还没有关注。变量存在于何处，取决于变量是何种类别。所谓“类别（kind）”，就跟 <em>类型（type）</em>，也就是原生变量与对象引用变量，有所不同。在讲到变量存在于何处时所关心的变量类别，是指 <em>实例</em> 变量与 <em>本地</em> 变量两种。本地变量又被成为是 <em>栈</em> 变量，之所以这样称呼，正是与其所存在的位置有关。</p>
<p><img src="images/Ch09_01.png" alt="栈与堆，实例与本地变量" /></p>
<p><em>图 1 - 栈与堆，实例与本地变量</em></p>
<h2 id="方法是堆叠的methods-are-stacked"><a class="header" href="#方法是堆叠的methods-are-stacked">方法是堆叠的（Methods are stacked）</a></h2>
<p>在对某个方法进行调用时，所调用的那个方法，就位处调用栈的顶部（When you call a method, the method lands on the top of a call stack）。这里被推到栈上去的，是一个叫做栈 <em>帧（frame）</em> 的新事物，栈帧驻留着方法的状态，包括正在执行哪一行代码，以及所有本地变量当前的值。</p>
<p>在栈顶部的方法，始终是那个栈上当前正在运行的方法（此时假设只有一个栈，后续第14章会加入更多栈）。栈上的方法在抵达其最后的结束花括弧（表示方法执行完毕）后，就从栈上消失了，在这之前方法都是留在栈上的。在 <code>foo()</code> 方法调用 <code>bar()</code>方法时，那么 <code>bar()</code>方法是堆叠在 <code>foo()</code> 方法之上的。</p>
<p><img src="images/Ch09_02.png" alt="有两个方法的调用栈" /></p>
<p><em>图 2 - 有两个方法的调用栈</em></p>
<p><img src="images/Ch09_03.png" alt="另一个栈场景" /></p>
<p><em>图 3 - 另一个栈场景</em></p>
<h2 id="对于是对象的那些本地变量的情况"><a class="header" href="#对于是对象的那些本地变量的情况">对于是对象的那些本地变量的情况</a></h2>
<p>记住，保存了对某个对象的引用的非原生值变量，并不是对象本身（是到对象在堆上的地址）。前面已经知道了对象存活的地方 -- 在内存堆上。不论对象是被声明的还是创建出来的，对象都是在堆上。 <em><strong>当本地变量是一个到某对象的引用时，只是该变量（引用/遥控器）在栈上</strong></em>。</p>
<p><em>对象本身，还是在堆上的</em>。</p>
<pre><code class="language-java">public class StackRef {
    public void foof {
        barf();
    }

    public void barf () {
        Duck d = new Duck (24);
    }
}
</code></pre>
<p><img src="images/Ch09_04.png" alt="本地变量为对象时的情况" /></p>
<p><em>图 4 - 本地变量为对象时的情况</em></p>
<ul>
<li><strong>再问一次，<em>为何</em> 要了解这些栈/堆的情况？了解他们对编写 Java 程序有什么帮助？真的需要了解这些吗？</strong></li>
</ul>
<blockquote>
<p>具备 Java 栈和堆的基础知识，对于掌握变量作用域（variable scope）、对象创建中的问题（object creation issues）、内存管理（memory management）、线程（threads），以及例外处理（exception handling）等等，至关重要。再后续章节，会涉及线程与例外处理，其他内容本章就会讲到。对特定JVM及/或平台上，栈和堆的实现细节不必了解。只需要了解这里讲到有关栈和堆的情况。如吃透了这里的内容，那么对上述的其他知识点的掌握，就会容易得多。记得我说过的，往后你会感谢我在这里啰嗦栈和堆的。</p>
</blockquote>
<h3 id="知识点-1"><a class="header" href="#知识点-1">知识点</a></h3>
<ul>
<li>Java有着两块我们所关心的内存：栈（the Stack）和堆（the Heap）</li>
<li>实例变量是在类中、方法外部声明的变量</li>
<li>本地变量是在方法里声明的变量，或方法的参数</li>
<li>所有本地变量，都是存活在栈上的，在声明本地变量的相应方法的帧中</li>
<li>对象引用变量像原生值变量那样运作 -- 若引用变量是作为本地变量声明，那么该引用变量在栈上</li>
<li>所有对象都存活在堆中，不管对象的引用变量是本地变量，还是实例变量</li>
</ul>
<h2 id="既然本地变量存活在栈上那实例变量又存活在哪里呢"><a class="header" href="#既然本地变量存活在栈上那实例变量又存活在哪里呢">既然本地变量存活在栈上，那实例变量又存活在哪里呢？</a></h2>
<p>在写下 <code>CellPhone()</code>时，Java就必须给那个 <code>CellPhone</code>对象在堆上分配空间。但要分配多少空间呢？就要给那个对象足够的空间，就是说要就足够的空间来保存对象的实例变量。那就得了，实例变量存活在堆上，在他们所属对象内部。</p>
<p>请记住对象的实例变量的值，是存活在对象的内部的。在实例变量都是原生值时，Java根据原生变量类型，为这些实例变量分配空间。一个<code>int</code>实例变量，需要 32个二进制位，一个 <code>long</code>长整型需要 64个二进制位等等。Java并不去看原生变量里的值；对于一个 <code>int</code> 的变量，不管他的值是 <code>32,000,000</code>还是 <code>32</code>，其所占据的位大小，始终都是 32位。</p>
<p>但如果实例变量是 <em>对象</em>，那又是怎样的呢？比如 <code>CellPhone</code> 就 <code>HAS-A</code> <code>Antenna</code>？也就是说，<code>CellPHone</code>有一个<code>Antenna</code>类型的引用变量。</p>
<p>在对象有着一些除开原生变量的、对象引用变量的实例变量时，真正的问题就是：对象需要空间来保存他的那些引用变量所指的对象吗（When the new object has instance variables that are object references rather than primitives, the real question is: does the object need space for all of the objects it holds reference to）？答案是肯定的，但 <em>不准确</em>。不管哪种情况，Java都必须给实例变量 <em>值（values）</em> 分配空间。但要记住，引用变量不是 <em>对象</em> 本身，而仅仅是到对象的 <em>遥控器</em>。因此在 <code>CellPhone</code> 有一个声明为非原生类型的 <code>Antenna</code> 实例变量时，Java 就只需在 <code>CellPhone</code>对象里头，给 <code>Antenna</code> 的遥控器，而不是<code>Antenna</code>对象本身，分配空间即可。</p>
<p>那么什么时候<code>Antenna</code>会在堆上获取到空间呢？首先就必须找到对象 <code>Antenna</code>本身在什么时候创建出来。这是由<code>Antenna</code>这个实例变量的声明决定的。在只声明了这个实例变量，而没有给他赋值的时候，就只有声明的这个引用变量（遥控器）的空间会被创建。</p>
<pre><code class="language-java">private Antenna ant;
</code></pre>
<p>直到有新的 <code>Antenna</code> 对象赋值给这个对象引用实例变量，才会有真实的 <code>Antenna</code>对象在堆上创建出来。</p>
<pre><code class="language-java">private Antenna ant = new Antenna();
</code></pre>
<p><img src="images/Ch09_05.png" alt="对象的实例变量" /></p>
<p><em>图 5 - 对象的实例变量</em></p>
<h2 id="对象创建的奇迹"><a class="header" href="#对象创建的奇迹">对象创建的奇迹</a></h2>
<p>现在知道了变量与对象存活的地方，就可以深入到对象创建的神奇世界。请记住对象声明与赋值的三个步骤：声明一个引用变量，创建出一个对象，还有将对象赋值给引用变量。</p>
<p>到现在为止，其中的第二步 -- 奇迹发生的地方和新对象 “诞生”的地方 -- 仍旧是个大秘团。准备好了解对象生命的一些实情了吗？ <em>希望你不要太过娇气</em>。</p>
<p><img src="images/Ch09_06.png" alt="对象3步骤" /></p>
<p><em>图 6 - 对象3步骤</em></p>
<p><em><strong>这里是调用了一个名为 <code>Duck()</code> 的方法吗？因为他真的看起来像个方法</strong></em>。</p>
<p><img src="images/Ch09_07.png" alt="对象创建的问题" /></p>
<p><em>图 7 - 对象创建的问题</em></p>
<p><em><strong>不是的</strong></em>。
<em><strong>这里调用的是 <code>Duck</code> 构造器</strong></em>。</p>
<p>构造器 <em>确实</em> 看起来且感觉很像是个方法，但他并不是一个方法。在写下关键字 <code>new</code> 时，他就有了运行的代码。也就是说，<em>在实例化某个对象时，所运行的代码</em> （It's got the code that runs when you say <code>new</code>. In other words, <em>the code that runs when you instantiate an object</em>）。</p>
<p>运行构造器的唯一方式，就是使用关键字 <code>new</code> 加上类名字。JVM去找到类并运行类中的构造器（好吧，技术上讲这不是运行构造器的 <em>唯一</em> 方式。但这确实是从构造器 <em>外部</em> 运行他的唯一方式。是 <em>可以</em> 在构造器中有限制地调用另一个构造器的，本章后面会讲到这点）。</p>
<blockquote>
<p><em><strong>构造器</strong></em> 有着在实例化某个对象时运行的代码。也就是说，当于某个类类型上写下 <code>new</code> 时，所运行的代码。
你所创建的或不是你创建的全部类，都有一个构造器。</p>
</blockquote>
<p><em><strong>那构造器在哪里呢？如果我们没有编写构造器，那又是谁编写的呢</strong></em>？</p>
<p>自己是可以编写自己的类的构造器的（我们就即将那样做），但如果自己没有编写他，那么<em><strong>编译器将为你编写出一个来</strong></em>！</p>
<p>编译器默认的构造器看起来是这样的：</p>
<pre><code class="language-java">public Duck () {}
</code></pre>
<p><em><strong>注意到缺了什么吗？这和方法有什么不同的地方</strong></em>？</p>
<p><img src="images/Ch09_08.png" alt="构造器与方法的不同" /></p>
<p><em>图 8 - 构造器与方法的不同</em></p>
<h3 id="构造一个-duck"><a class="header" href="#构造一个-duck">构造一个 <code>Duck</code></a></h3>
<p><img src="images/Ch09_09.png" alt="构造器实例" /></p>
<p><em>图 9 - 构造器实例</em></p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
Quack
</code></pre>
<h3 id="初始化某个新-duck对象的状态"><a class="header" href="#初始化某个新-duck对象的状态">初始化某个新 <code>Duck</code>对象的状态</a></h3>
<p>多数人使用构造器来初始化对象的状态。也就是给对象的实例变量构造和赋值。</p>
<pre><code class="language-java">public Duck () {
    size = 34;
}
</code></pre>
<p>在<code>Duck</code>类 <em>开发者</em> 知道 <code>Duck</code> 对象应该是多大的时候，这样做没有问题。但在希望由 <em>使用</em> <code>Duck</code> 类的程序员来决定，某个特定的 <code>Duck</code> 对象应该多大的时候会怎样呢？</p>
<p>设想 <code>Duck</code> 有个 <code>size</code> 实例变量，同时希望使用这个<code>Duck</code>类的程序员来设置新 <code>Duck</code> 对象的 <code>size</code>。可以怎么办到呢？</p>
<p>当然，可以给类加上一个设置器<code>setSize()</code>（setter）。但这样做会给 <code>Duck</code> 的 <code>size</code> 暂时没有取值（实例变量是有默认值的。对于数值原生值，为<code>0</code>或者浮点数的<code>0.0</code>，对于布尔值是 <code>false</code>，对于引用变量默认值是 <code>null</code>），并会让使用者必须用 <em>两条</em> 语句 -- 一条来创建 <code>Duck</code> 对象，一条来调用 <code>setSize()</code> 方法。下面的代码就是使用了一个设置器方法来设置新 <code>Duck</code> 的 <code>size</code> 初始值。</p>
<p><img src="images/Ch09_10.png" alt="使用设置器而不是构造器参数的弊端" /></p>
<p><em>图 10 - 使用设置器而不是构造器参数的弊端</em></p>
<h3 id="答疑-4"><a class="header" href="#答疑-4">答疑</a></h3>
<ul>
<li><strong>既然编译器会提供构造器，那为何还有自己编写构造器</strong> ？</li>
</ul>
<blockquote>
<p>在需要代码来帮助对象初始化，以及为使用该对象做好准备时，就必须编写自己的构造器。或许也会需要对象使用者的输入，才能完成对象的构建。就算自己不需要任何的构造器代码，但还是有必须编写构造器的理由，这一点与超类的构造器有关，后面很快就会讲到这点。</p>
</blockquote>
<ul>
<li><strong>怎样区分构造器与普通方法？也可以让某个方法与类有相同的名字吗？</strong></li>
</ul>
<blockquote>
<p>Java允许声明与类名字相同的方法。不过这样做不会使其成为构造器。将普通方法和构造器区别开的，就是返回值的类型。方法必须有一个返回值类型，与此相反，构造器就不能有返回值类型（<strong>注意：构造器返回的实际上是一个对象的引用</strong>！）。</p>
</blockquote>
<ul>
<li><strong>构造器会被继承吗？在当前类的超类具有构造器，他本身没有构造器时，会将超类的构造器作为默认的构造器吗</strong>？</li>
</ul>
<blockquote>
<p>不会。构造器是不被继承的。在后面后讨论这个问题。</p>
</blockquote>
<h3 id="使用构造器来对一些-duck-的重要状态进行初始化"><a class="header" href="#使用构造器来对一些-duck-的重要状态进行初始化">使用构造器来对一些 <code>Duck</code> 的重要状态进行初始化</a></h3>
<p>若要求在对象状态（实例变量）的一个或多个部分未初始化之前，不能使用该对象的话，就应该在完成对象初始化之前，不应将 <code>Duck</code> 对象交给任何引用变量（If an object shouldn't be used until one or more parts of its state(instance variables) have been initialized, don't let anyone get ahold of a <code>Duck</code> object until you're finished initializing）！让别人构造一个需要再次调用 <code>setSize()</code> 这样的设置器，才能得到一个可以使用的构造器，是具有相当风险的。因为在调用设置器之前，就已经将这个未准备好的对象，交给了其引用变量。如果类 <code>Duck</code>的使用者不知道或者忘记了调用设置器，那么会怎样呢？</p>
<p>放置初始化代码的最佳地点，就是在构造器中。只需要构造一个带有参数的构造器。</p>
<p><img src="images/Ch09_11.png" alt="带有参数的构造器" /></p>
<p><em>图 11 - 带有参数的构造器</em></p>
<h2 id="让-duck-的构造更容易"><a class="header" href="#让-duck-的构造更容易">让 <code>Duck</code> 的构造更容易</a></h2>
<p><strong>就要确保有一个不带参数的构造器</strong></p>
<p>若 <code>Duck</code> 构造器接受一个参数时会怎样？想一下这个问题。在上面的示例中，只有一个 <code>Duck</code> 构造器 -- 并接收一个 <code>int</code> 参数作为 <code>Duck</code> 的大小。这或许不是个大问题，但将让那些尚不知道某个 <code>Duck</code> 应该多大的程序员，感到手足无措。如果 <code>Duck</code> 能有个默认的 <code>size</code>，就会很有帮助，那样 <code>Duck</code> 类的使用者，即使不知道一个合适的 <code>size</code>，也仍然可以构造出一个可工作的 <code>Duck</code>来。</p>
<p><strong>设想打算让 <code>Duck</code> 的使用者，在构造<code>Duck</code> 时有两个选项 -- 一个时提供到<code>Duck</code>的 <code>size</code>（构造器参数），另一个则不指定 <code>size</code>，因此就要使用预先准备的 <em>默认</em> <code>Duck</code> <code>size</code></strong>。</p>
<p>若只有一个构造器，那么肯定就实现不了这个。记住，某个方法（或构造器--适用同样的规则）有个参数，那么在执行该方法或构造器时，就 <em>必须</em> 传递一个适当的参数给他。就不能这样写，“如果没有传递任何东西给构造器，就使用默认的 <code>size</code>”，因为在没有传递一个 <code>int</code> 参数给构造器调用的话，就甚至不能进行编译的。<em>或许</em> 可以像下面这样写：</p>
<p><img src="images/Ch09_12.png" alt="只使用一个构造器" />]</p>
<p><em>图 12 - 只使用一个构造器</em></p>
<p>这样做还是要求构造新 <code>Duck</code> 对象的程序员知道，传入一个 <code>0</code> 就可以得到默认 <code>Duck</code> <code>size</code> 的约定。这就很恶心了。要是其他程序员不知道呢？或者某人真的需要一个大小为零的 <code>Duck</code>呢？（假设大小为零的 <code>Duck</code> 是允许的。就是真的不想要大小为零的 <code>Duck</code> 对象存在，就要在构造器中放入验证代码来防止）关键是，不总是能识别出<code>Duck</code>的使用者，到底是真的想要一个大小为零的 <code>Duck</code>，还是他要传入一个 <code>0</code>来得到默认的 <code>Duck</code> <code>size</code>。</p>
<p><strong>实际上，需要的是有两种构造新 <code>Duck</code>的方式</strong> :</p>
<pre><code class="language-java">public class Duck2 {
    int size;

    public Duck2 () {
        // 提供一个默认的 size
        size = 27;
    }

    public Duck2 (int duckSize) {
        // 使用 duckSize 参数
        size = duckSize;
    }
}
</code></pre>
<p><strong>要构造一个已知 <code>size</code> 的新 <code>Duck</code> 时</strong> ：</p>
<pre><code class="language-java">Duck2 d = new Duck2 (15);
</code></pre>
<p><strong>要构造一个不知道 <code>size</code> 的 <code>Duck</code> 时</strong> ：</p>
<pre><code class="language-java">Duck2 d2 = new Ducks()
</code></pre>
<p>因此这种 <strong>构造 <code>Duck</code> 的双项选择</strong> 做法，就需要 <em>两个</em> 构造器。其一接收一个 <code>int</code> 参数，其二没有参数。 <strong>在类中有着多个构造器时，就是说使用了 <em>过载的构造器（overloaded constructors）</em></strong>。</p>
<h2 id="编译器总是会自动构造一个不带参数的构造器吗-不会"><a class="header" href="#编译器总是会自动构造一个不带参数的构造器吗-不会">编译器总是会自动构造一个不带参数的构造器吗？ <em>不会！</em></a></h2>
<p>你可能会想，在 <em>只</em> 编写了一个有参数的构造器时，编译器会发现那里没有不带参数的构造器，并自动为你补上这么一个。但这并不是编译器的行事方式。编译器 <em>只会在你完全没有编写构造器时</em>，才介入到构造器的生成中来。</p>
<p><strong>在编写了带参数的构造器，且仍需一个不带参数的构造器时，就必须自己去构建这个不带参数的构造器</strong>！</p>
<p>一旦你提供了一个构造器，<strong>不管</strong> 这个构造器是哪种，编译器就后退下来，并以为 “好的兄弟，看起来你负责了构造器这个事情”。</p>
<p><strong>某个类中有了多个构造器时，那么这些构造器就 <em>必须</em> 带有不同的参数清单</strong>。</p>
<p>参数清单包含了参数的顺序及类型。只要参数清单各异，那么就可以有着多个的构造器。对于方法，这条规则也是适用的，后面的章节会讲到。</p>
<p>** <em>过载</em> 构造器，就是说，在类中可以有多个构造器**。</p>
<p><strong>要通过编译，各个构造器就必须有 <em>不同</em> 的参数清单</strong>！</p>
<p>下面的类是合法的，因为全部5个构造器，都有着不同的参数清单。若某个类的两个构造器，都接收 <code>int</code> 参数，那么该类就不会被编译。参数变量的名称，不作为考虑参数清单差异的考虑。参数变量的 <em>类型</em>（比如 <code>Dog</code>） 和 <em>顺序</em> 才影响参数清单差异。两个构造器可以有同样的类型，<em><strong>只要顺序不一样</strong></em> 就可以。接收一个字符串加一个整数的构造器，就不同于与接收一个整数与一个字符串的构造器。</p>
<p><img src="images/Ch09_13.png" alt="合法的多个构造器" />]</p>
<p><em>图 13 - 合法的多个构造器</em></p>
<h2 id="知识点-2"><a class="header" href="#知识点-2">知识点</a></h2>
<ul>
<li>实例变量存活于他们所属的对象，因此也是在内存堆上的；</li>
<li>若实例变量是多某个对象的引用变量，那么该引用变量及其所指的对象，都是在堆上的；</li>
<li>构造器是在某个类类型上，提及 <code>new</code> 关键字时所运行的代码；</li>
<li>构造器的名字，必须与类的名字相同，且不能有返回值类型；</li>
<li>可使用构造器，来初始化将要构造对象的状态（即初始化对象的那些实例变量）；</li>
<li>如类中没有构造器，那么编译器将放入一个默认的构造器；</li>
<li>默认的构造器，总是不带参数的构造器；</li>
<li>若在类中放入了构造器，那么编译器就不在会构建默认的构造器了；</li>
<li>在已经放入了带参数的构造器后，还想要一个不带参数的构造器，就必须亲自构建那个不带参数的构造器；</li>
<li>应尽可能的提供不带参数的构造器，这是为了让其他程序员可以更容易的构造一个能用的对象出来。通过不带参数的构造器提供到实例变量默认值；</li>
<li>Java 的 “过载构造器”特性，是指类中可以有多个构造器；</li>
<li>过载构造器必须有不同的参数清单；</li>
<li>两个构造器不能有同样的参数清单。参数清单包括了参数类型和/或顺序；</li>
<li>就是没有显式地赋值给实例变量，实例变量仍然具有默认值。对于原生变量，默认值为 <code>0</code>/<code>0.0</code>/<code>false</code>，对于引用变量，默认值为 <code>null</code>。</li>
</ul>
<h2 id="答疑-5"><a class="header" href="#答疑-5">答疑</a></h2>
<ul>
<li><strong>早前说到编写一个不带参数的构造器，是一种良好的编程习惯，那样就可以在其他人调用不带参数的构造器时，提供到 “缺失” 参数的默认值。但会不会有时候无法提供默认值？有时候类种不应该有着不带参数的构造器呢</strong>？</li>
</ul>
<blockquote>
<p>对的。某些时候不带参数的构造器就毫无意义。在 Java API种就能见到这样的情况 -- 一些类就没有没有不带参数的构造器。比如类 <code>Color</code>，表示了某个 ... 颜色。<code>Color</code> 对象用于，比如设置或改变某个屏幕字体，或GUI按钮的颜色。在构造某个 <code>Color</code> 实例时，所构造的实例，就是某种特定颜色（也就是“死亡巧克力棕（Death-by-Chocolate Brown）”、“死机蓝屏蓝（Blue-Screen-of-Death Blue）”、“绯闻红（Scandalous Red）”等等）。在构建某个 <code>Color</code> 对象时，就必须以某种方式指定颜色。</p>
</blockquote>
<pre><code class="language-java">Color c = new Color(3, 45, 200);
</code></pre>
<blockquote>
<p>（这里使用的就是表示RGB数值的三个整数。后面在 <code>Swing</code> 章，将使用到<code>Color</code>类。）否则将得到什么呢？Java API的程序员本来可以决定，一个不带参数的<code>Color</code>构造器给出可可爱爱的紫红色。不过最后还是理智决定（But good taste prevailed）。</p>
</blockquote>
<blockquote>
<p>那么在尝试不通过参数就构造颜色时：</p>
</blockquote>
<pre><code class="language-java">Color c = new Color();
</code></pre>
<blockquote>
<p>编译器就会吓坏，因为在类 <code>Color</code>里头，找不到不带参数的构造器。</p>
</blockquote>
<h3 id="小复习关于构造器需要记住的4件事"><a class="header" href="#小复习关于构造器需要记住的4件事">小复习：关于构造器，需要记住的4件事</a></h3>
<ol>
<li>
<p>构造器是在某种类类型上写关键字 <code>new</code> 所运行的代码</p>
<pre><code class="language-java">Duck d = new Duck();
</code></pre>
</li>
<li>
<p>构造器必须有着与类同样的名字，且 <strong>没有</strong> 返回值类型</p>
<pre><code class="language-java">public Duck (int size) {}
</code></pre>
</li>
<li>
<p>当类里没写构造器时，编译器就会放入一个默认的构造器。默认构造器都是不带参数的构造器。</p>
<pre><code class="language-java">public Duck () {}
</code></pre>
</li>
<li>
<p>类中可以写多个构造器，只要他们的参数清单不同即可。在类中有着多个构造器时，就用到了 Java 的过载构造器特性。</p>
<pre><code class="language-java">public Duck () {}
public Duck (int size) {}
public Duck (String name) {}
public Duck (String name, int size) {}
</code></pre>
</li>
</ol>
<blockquote>
<p>脑力大挑战</p>
<p><strong>对于超类来讲是什么情况</strong>？
<strong>在构造一个 <code>Dog</code> 时，<code>Canine</code> 的构造器，也会运行吗</strong>？
<strong>在超类是抽象的时候，他甚至也需要一个构造器吗（If the superclass is abstract, should it even hava a constructor）</strong>?</p>
<p>后面将讨论这些问题，现在可以不用想这些问题，而是可以思考一下构造器与超类，这两个东西在一起的影响。</p>
</blockquote>
<h2 id="答疑-6"><a class="header" href="#答疑-6">答疑</a></h2>
<ul>
<li><strong>构造器必须要是 <code>public</code> 的吗</strong>？</li>
</ul>
<blockquote>
<p>不必是。构造器可以是 <code>public</code>、<code>protected</code>、<code>private</code> 或者 <em>默认（default）</em> （也就是没有访问修饰器，which means no access modifier at all）。在第16章及附录 B中将讨论 <em>默认</em> 访问修饰器。</p>
</blockquote>
<ul>
<li>** <code>private</code> 的构造器怎么发挥作用呢？没人可以调用到这样的构造器，那么就不会有人能构造出一个新的对象来**！</li>
</ul>
<blockquote>
<p>是不会构造出新的对象，但这样说并不完全正确。将某个东西标记为 <code>private</code> 并不是说没人可以访问到他，只是说 <em>类外部没人</em> 可以访问他。我敢打赌你一定是想到了 《第22条军规》（Bet you're thinking &quot;Catch-22&quot;）。只有在定义了私有构造器的类中的那些代码，才能构造那个类的新对象，但在没有构造出第一个对象的时候，又怎样才能从那个类的最初对象运行代码呢？<em>Patience grasshopper</em>。接下来的章里，将讨论这个问题。</p>
</blockquote>
<p><strong>等一下，我们似乎还没有讲到超类与继承，以及他们跟构造器是怎么相互作用的</strong>。</p>
<p>这里就开始变得有趣了。还记得上一章里，讲到的 <code>Snowboard</code> 对象，其围绕着表示<code>Snowboard</code>类的 <code>Object</code> 部分的内部核心进行封装吗？这里最重要的地方，就是所有对象，都不仅保存了他自己声明的实例变量，同时还保存了 <em>所有来自其超类的东西</em> （最起码有类 <code>Object</code>的东西，因为所有类都扩展了 <code>Object</code>）。</p>
<p>那么在某个对象被创建出来是（由于某人写下了关键字 <code>new</code>，除有人在某个时候在类类型之上写了 <code>new</code>之外，并无其他构造新对象的方式），对象就获取到其 <em>所有</em> 实例变量的空间，包括其从继承树往上继承到的，以及自身声明的实例变量。这得要花点时间才能搞清楚......某个超类就可能有着一些对私有变量进行封装的设置器方法（Think about it for a moment...a superclass might have setter methods encapsulating a private variable）。而那个变量，就必须存活于 <em>某处</em>。在某个对象被创建出来时，总是会有 <em>多个</em> 对象生成 -- 对象被生成，同时每个超类的对象也被生成。概念上讲，像下图这样去考虑这个问题将更好一些，那里所创建出的对象，有着分别表示各个超类的对象 <em>自身</em> 的 <em>各层</em>。</p>
<p><img src="images/Ch09_14.png" alt="堆上的 Snowboard 类" />]</p>
<p><em>图 14 - 堆上的 Snowboard 类</em></p>
<h3 id="超类构造器在对象生命周期中的角色"><a class="header" href="#超类构造器在对象生命周期中的角色">超类构造器在对象生命周期中的角色</a></h3>
<p><strong>The role of superclass constructors in an object's life</strong></p>
<p><em><strong>在构造新的对象时，对象继承树中的所有构造器都必须运行（All the constructors in an object's inheritace tree must run when you make a object）</strong></em>。</p>
<p>让我们细细品味这句话是什么意思（Let that sink in）。</p>
<p>这意味着每个超类都有一个构造器（因为每个类都有一个构造器），同时沿继承层次往上的每个构造器，在子类的某个对象被创建出来时，都会运行。</p>
<p>写下关键字 <code>new</code> 可是个大事情。这就开启了整个构造器链的反应（Saying <code>new</code> is a Big Deal. It starts the whole constructor chain reaction）。且就算抽象类，也是有构造器的。虽然不在在某个抽象类上写 <code>new</code>，但抽象类同样是超类，因此在有人构造某个具体类的实例时，抽象类的构造器同样会运行。</p>
<p>超类构造器运行，是为了构造出对象的超类部分。记住，某个子类可能依据超类的状态（即超类实例变量的值），而继承超类的某些方法。对象要成型，他自身的所有超类部分必须要成型，这就是超类构造器 <em>必须</em> 运行的原因。继承树中所有类的实例变量，都必须被声明和初始化。基本 <code>Animal</code>中有 <code>Hippo</code> 未曾继承的实例变量（比如在实例变量为 <code>private</code>时），<code>Hippo</code>仍然会依赖<code>Animal</code>中 <em>使用</em> 到这些变量的方法。</p>
<p><img src="images/Ch09_15.png" alt="构造器链" /></p>
<p><em>图 15 - 构造器链</em></p>
<p>在构造器运行时，他就立即沿构造器链往上，调用他的超类构造器，直到类<code>Object</code>的构造器（When a contructor runs, it immediately calls its superclass constructor, all the way up the chain until you get to the class <code>Object</code> constructor）。</p>
<p>在后面的内容中，将了解怎样调用超类构造器，以及怎么亲自去调用超类构造器。还会了解在超类构造器带有参数时，该怎样去调用他们。</p>
<pre><code class="language-java">package com.xfoss.learningJava;

abstract class Animal {
    Animal () {
        System.out.println (&quot;Making an Animal&quot;);
    }
}

abstract class Canine extends Animal {}
abstract class Feline extends Animal {}

class Dog extends Canine {}
class Cat extends Feline {}
class Hippo extends Animal {
    Hippo () {
        System.out.println(&quot;Making a Hippo&quot;);
    }
}

public class AnimalTestDrive {
    public static void main (String [] args) {
        System.out.println(&quot;Starting...&quot;);
        Hippo h = new Hippo();
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
Starting...
Making an Animal
Making a Hippo
</code></pre>
<p><img src="images/Ch09_16.png" alt="构造器链" /></p>
<p><em>图 16 - 构造器链（Constructor Chaining）</em></p>
<h3 id="该怎样来亲自执行超类构造器"><a class="header" href="#该怎样来亲自执行超类构造器">该怎样来亲自执行超类构造器？</a></h3>
<p><strong>How do you invoke a superclass constructor</strong>?</p>
<p>你可能已经想到，比如对于 <code>Duck</code> 的构造器，在 <code>Duck</code> 扩展了 <code>Animal</code>时，就会去调用 <code>Animal()</code>。但不是这样干的：</p>
<pre><code class="language-java">class Duck extends Animal {
    int size;

    Duck (int newSize) {
        Animal (); // 错！不行，这样是非法的！
        size = newSize;
    }
}
</code></pre>
<p>调用超构造器（a super constructor）的唯一方式，是通过调用 <code>super()</code>。对 -- <code>super()</code> 就会调用到 <em><strong>超构造器</strong></em>。</p>
<p>时机在哪里呢（What are the odds）？</p>
<pre><code class="language-java">class Duck extends Animal {
    int size;

    Duck (int newSize) {
        super();
        size = newSize;
    }
}
</code></pre>
<p>构造器 <code>Duck()</code> 中的 <code>super()</code> 调用，把超类构造器放置在栈顶部。而那个超类构造器又会干什么呢？<em>调用他自己的超类构造器</em>。如此这般，直到<code>Object</code>的构造器位于栈的顶部为止。一旦 <code>Object()</code> 运行完毕，他就从栈上被移除，同时栈上的下一个构造器（调用 <code>Object()</code> 的那个子类构造器）现在就位于顶部了。随后 <em>那个</em> 构造器也执行完毕，如此这般，直到最初的构造器位于栈顶部为止，到这里这个最初的构造器才执行完毕。</p>
<blockquote>
<p><strong>那么之前为什么就没这么做呢（And how is it that we've gotten away without doing it）</strong>?</p>
</blockquote>
<blockquote>
<p>你或许已经接近发现事实真相了。
<strong>在我们没有放入一个 <code>super()</code>时，我们的好友编译器就会放入一个</strong>。
因此编译器在介入到构造器构造时，有两种方式（So the compiler gets involved in constructor-making in two ways）：</p>
<ol>
<li>在我们不提供构造器时：
编译器放入一个这样的构造器：</li>
</ol>
</blockquote>
<pre><code class="language-java">class ClassName {
    super();
}
</code></pre>
<blockquote>
<ol start="2">
<li>在提供了构造器却没有放入一个到 <code>super()</code> 的调用时</li>
</ol>
<p>编译器将在所有过载构造器中，放入一个到 <code>super()</code>的调用（除了那些调用了其他过载构造器的构造器中，这在后面会见到）。编译器所提供的调用是这样的：</p>
</blockquote>
<pre><code class="language-java">super();
</code></pre>
<blockquote>
<p>且会一直是这样的。编译器插入的 <code>super()</code> 调用，始终是不带参数的。在超类有着过载构造器时，只会调用不带参数的构造器。</p>
</blockquote>
<h3 id="子类可以在父类之前就存在吗"><a class="header" href="#子类可以在父类之前就存在吗">子类可以在父类之前就存在吗？</a></h3>
<p><strong>Can the child exist before the parents</strong>?</p>
<p>在将超类想象为子类孩子的父辈时，就能搞清楚哪个会首先存在。<em><strong>对象的超类部分，必须要在子类部分构造之前就完全成型（构建完毕）</strong></em>。记住，子类对象可能依赖他所继承的超类的某些东西，因此这些被继承的东西有必要是完备的。这事没有商量的余地。超类构造器必须在子类构造器之前执行完毕。</p>
<p>回顾前面的栈序列，就可以发现尽管首先运行的是 <code>Hippo()</code> 构造器（他是栈上第一个事物），但却是最后一个执行完毕的！各个子类构造器将立即运行他自己的超类构造器，直到 <code>Object</code> 构造器位居栈顶部为止。这是<code>Object</code>的构造器执行完毕，随后我们往下被带回到 <code>Animal</code> 的构造器。只有在 <code>Animal</code> 的构造器执行完毕，才能最终往下回到 <code>Hippo</code>构造器的剩余部分。因为这个原因：</p>
<p><strong>对 <code>super()</code> 的调用，必须是每个构造器中的第一条语句</strong>（此规则也有例外，后面马上就会看到）！</p>
<p><img src="images/Ch09_17.png" alt="对 super() 的调用" /></p>
<p><em>图 17 - 对 <code>super()</code> 的调用</em></p>
<h3 id="带参数的超类构造器"><a class="header" href="#带参数的超类构造器">带参数的超类构造器</a></h3>
<p>若超类构造器带有参数会怎样呢？可将某些东西传递进入到 <code>super()</code> 调用吗？当然可以。如若不能，就无法去扩展那些，没有不带参数的构造器的类了。设想这样的场景：所有动物都有个名字。类 <code>Animal</code> 中有个 <code>getName()</code> 的方法，返回实例变量 <code>name</code> 的值。该实例变量被标记为了<code>private</code>，但子类（此示例中的 <code>Hippo</code>）继承了 <code>getName()</code> 方法。那么就有这个问题：<code>Hippo</code>有着一个 <code>getName()</code>方法（通过继承得到），但并没有 <code>name</code>这个实例变量。<code>Hippo</code>就不得不依赖自己的 <code>Animal</code>部分，来保存那个<code>name</code>的实例变量，并在某人调用到 <code>Hippo</code>对象上的 <code>getName()</code>方法时，返回 <code>name</code> 的值。但 <code>Animal</code> 部分该怎样获取到这个 <code>name</code> 呢？<code>Hippo</code>到他的 <code>Animal</code>部分的唯一引用，是经由 <code>super()</code> 实现的，那么那里就是 <code>Hippo</code> 把 <code>Hippo</code> 的名字，发送给他的 <code>Animal</code> 部分的地方，如此这般，<code>Animal</code> 部分才可以将 <code>Hippo</code>的名字，存储在那个 <code>private</code> 的 <code>name</code> 实例变量中。</p>
<pre><code class="language-java">abstract class Animal {
    private String name; // 所有动物（包括子类）都有一个名字

    public String getName () { // Hippo 继承到的一个读取器方法（a getter method）
        return name;
    }

    Animal (String theName) {
        name = theName; // 接收名字并将其赋值给 name 实例变量的构造器
    }
}

class Hippo extends Animal {
    Hippo (String name) { // Hippo构造器接收一个名字
        super(name); // 这个语句将名字在栈上向上发送给 Animal 构造器
    }
}

public class AnimalTestDrive {
    public static void main (String [] args) {
        Hippo h = new Hippo(&quot;Buffy&quot;); // 构造一个 Hippo, 并将名字 &quot;Buffy&quot; 传递给 Hippo 构造器。
        System.out.println(h.getName()); // 随后调用 Hippo 继承到的 getName() 方法
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
Buffy
</code></pre>
<h3 id="从一个过载构造器运行另一个过载构造器"><a class="header" href="#从一个过载构造器运行另一个过载构造器">从一个过载构造器运行另一个过载构造器</a></h3>
<p>在过载构造器具有处理不同参数类型的例外，而去做同样的事情时，会怎样呢（What if you have overloaded construtors that, with the exception of handling different argument types, all do the same thing）？显然是不希望在各个构造器中有 <em>重复（duplicate）</em> 代码（苦于维护等等），那么就有把大部分构造器代码（包括对 <code>super()</code> 的调用），放在 <em>一个</em> 过载构造器中。让其他构造器去运行这个真正构造器（The Real Constructor），并让这个真正构造器去完成对象构造工作。很简单：使用 <code>this()</code> 语句，或者 <code>this(aString)</code>，或者<code>this(27, x)</code>这样的语句即可。也就是说，只需将关键字 <code>this</code>，想象为 <strong>当前对象</strong> 即可。</p>
<p><strong>只有在构造器中，才能写 <code>this</code>, 且必须是构造器的第一条语句</strong>！</p>
<p>但那是个问题，不是吗？早先说过，<code>super()</code>必须是构造器中的第一条语句。好吧，上面这句话就是说，现在多了一个选择。</p>
<p><strong>每个构造器都可以有一个 <code>super()</code> 或 <code>this()</code> 的调用，但不能两个同时调用</strong>！</p>
<blockquote>
<p><strong>在一个构造器中使用 <code>this()</code> 来调用同一类中的另一个构造器</strong>。
<strong>可以在构造器中使用对 <code>this()</code> 的调用，但必须是构造器的第一条语句</strong>。
<strong>构造器可以保有一个对 <code>super()</code> <em>或</em> <code>this()</code> 的调用，但不能同时使用 <code>super()</code> 和 <code>this()</code></strong>。</p>
</blockquote>
<p><img src="images/Ch09_18.png" alt="this() 与 super()" /></p>
<p><em>图 18 - <code>this()</code> 和 <code>super()</code>的使用</em> </p>
<h3 id="现在了解了对象是如何诞生的那么对象会存活多长时间呢"><a class="header" href="#现在了解了对象是如何诞生的那么对象会存活多长时间呢">现在了解了对象是如何诞生的，那么对象会存活多长时间呢？</a></h3>
<p>对象的 <em>生命</em> 完全取决于指向他的引用变量的存活时间。在引用变量还是 “存活的” 时候，那么对象也就还存活在内存堆上。如果引用变量死去（马上就会讲到“引用变量死去”的意思），那么对象也会死去。</p>
<p><strong>既然对象的生命取决于他的引用变量的存活时间，那么究竟 <em>变量</em> 会存活多长时间呢</strong>？</p>
<p>变量存活时间，又取决于变量是 <em>本地</em> 变量还是 <em>实例</em> 变量。下面的代码展示了本地变量的存活时间。在示例中，变量是个原生值，但不论变量是原生值还是引用变量，他们的存活时间都是一样的。</p>
<p><img src="images/Ch09_19.png" alt="本地变量存活时间" /></p>
<p><em>图 19 - 本地变量存活时间</em></p>
<p><strong>本地变量 <em>存活时间</em> 与 <em>作用范围</em> 的区别</strong>：</p>
<ul>
<li>
<p><strong>存活时间（Life）</strong></p>
<p>本地变量与其所在的栈帧同在。也就是说，<em>在其所属方法执行完毕之前，本地变量都是存活的</em>。</p>
</li>
<li>
<p><strong>作用范围（Scope）</strong></p>
<p>本地变量作用范围，仅限于声明变量的方法内部。在他自己的方法调用另一个方法期间，该变量仍然是存活的，但直到他的方法恢复运行之前，都不在他的作用范围中。<em><strong>只有当本地变量在其作用范围中时，才能使用那个变量</strong></em>。</p>
</li>
</ul>
<p><img src="images/Ch09_20.png" alt="本地变量存活时间与作用范围" /></p>
<p><em>图 20 - 本地变量存活时间与作用范围</em></p>
<p>在本地变量处于存活状态是，他的状态就会持续存在。只要 <code>doStuff()</code> 方法还在栈上，那么变量 <code>b</code> 就会保持他的值不变。但变量 <code>b</code> 只能在 <code>doStuff()</code> 栈帧位于顶部时才能使用。也就是说，只有在本地变量的方法正在运行时（而非等待其上的栈帧执行完毕期间），才能使用那个本地变量。</p>
<blockquote>
<p><strong>Wrap vs. Encapsulation</strong></p>
</blockquote>
<blockquote>
<p>Wrap, 缠绕，包裹起来，更形象
Encapsulation, 封装，Java 中的 <code>getter</code> 和 <code>setter</code> 对 <code>private</code> 变量的封装，不如 wrap 形象，意义也大不相同</p>
</blockquote>
<h3 id="引用变量的存活时间问题"><a class="header" href="#引用变量的存活时间问题">引用变量的存活时间问题</a></h3>
<p>对于原生变量与引用变量，规则是一样的。引用变量也只能在其作用范围使用，也就是说，除非在作用范围中有某个引用变量，否则就不能使用某个对象的遥控器。然而 <em>真正的</em> 问题是：</p>
<p><strong>“引用变量的存活时间，是如何对其所指向的 <em>对象</em> 的存活时间施加影响的”</strong>？</p>
<p>对象与对象的引用变量共存。在某个引用变量脱离作用范围却依然存活时，他 <em>所指向的</em> 对象，也依然是存活在内存堆上的。那么你就会问......“当引用变量所在方法结束，从而导致保存引用变量的栈帧被移除栈时，会发生什么呢”？</p>
<p>如果那个引用变量是到对象的 <em>唯一</em> 引用，那么该对象此时就会在堆上被抛弃。随着栈帧的瓦解，那个引用变量也瓦解了，因此被抛弃的对象，现在就 <em>正式地</em> 吃席了。这里的窍门在于明白某个对象在什么时候 <em><strong>可被垃圾回收</strong></em>。</p>
<p>一旦某个对象可被垃圾回收（eligible for garbage collection, GC），就不用操心怎么去收回被那个对象使用的内存的问题。在程序需要更多内存时，Java的垃圾回收特性，就会自动损毁掉部分或全部的可回收对象，从而避免内存耗尽。在所有可回收对象被投进垃圾场之前，是不会耗尽内存的（If your program gets low on memory, GC will destroy some or all of the eligible objects, to keep you from running out of RAM. You can still run out of memory, but <em>not</em> before all eligible objects have been hauled off to the dump）。你的任务就只是确保在用完对象后，及时抛弃他们即可（也就是让用完的对象成为可被垃圾回收的对象），这样垃圾回收器（the garbage collector,）就有东西可以回收了。如果一直吊着这些对象不放，垃圾回收就帮不上你，你就只有自己承担程序陷入耗尽内存而亡的风险了。</p>
<blockquote>
<p><strong>在没有指向对象的引用变量时，对象的存活没有价值、没有意义，也没有时间点</strong>。
<strong>若不能捕获到对象，那么就没法要求对象完成任何事情，这时对象就是一堆废物的二进制位</strong>。
<strong>但在某个对象不可到达时，垃圾回收器就会把他找出来。很快他就会消失</strong>。</p>
</blockquote>
<p><img src="images/Ch09_21.png" alt="对象的存活时间" /></p>
<p><em>图 21 - 对象的存活时间</em></p>
<p><img src="images/Ch09_22.png" alt="对象回收：引用变量永久脱离作用范围" /></p>
<p><em>图 22 - 对象回收：引用变量永久脱离作用范围</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数字与静态值数字为要"><a class="header" href="#数字与静态值数字为要">数字与静态值：数字为要</a></h1>
<p><strong>Numbers and Statics: Numbers Matter</strong></p>
<p><strong>做运算（Do the Math）</strong>。除了原生算术运算，数字方面还有更多的要做。可能要获取某个数字的绝对值，或对某个数字四舍五入，或者找出两个数中较大的等等。还可能希望只打印某个数的两位小数，或者要在大数中放进逗号，从而让大数更易于阅读。日期又该怎样处理呢？或许要以各种方式来打印日期，甚至要对日期进行 <em>操作（manipulate）</em>，比如“把今天的日期加上三周”。还有怎样把字符串解析到数字呢？或是把数字转换成字符串？有幸的是，Java API 提供了很多易于上手的数字处理方法（full of handy number-tweaking methods）。但这些方法大多是 <strong>静态的（<code>static</code>）</strong>，因此先要了解某个变量或方法为静态时，以及 Java 中的常量 -- 静态最终变量，是什么意思（But most of them are <code>static</code>, so we'll start by learning what it means for a variable or method to be static, including constants in Java -- <code>static</code> <code>final</code> variables）。</p>
<h2 id="数学方法接近全局方法"><a class="header" href="#数学方法接近全局方法">数学方法：接近全局方法</a></h2>
<p><strong>MATH methods: as close as you'll ever get to a <code>global</code> method</strong></p>
<p>虽然 Java 中不存在全局的 <em>任何东西</em>。但请想想：有个不依赖实例变量值的方法会怎样。就拿类 <code>Math</code> 中的 <code>round()</code> 方法来说。他会每次都会执行相同的操作 -- 将浮点数（该方法的参数）四舍五入到最接近的整数。每次都这样的。就是有一万个类 <code>Math</code> 的实例，都运行 <code>round(42.2)</code> 方法，得到的结果都是 <code>42</code>。每次都是。也就是说，方法在参数上执行，而绝不会受某个实例变量状态影响。改变方法 <code>round()</code>运行方式的唯一值，就是传递给该方法的参数！</p>
<p>看起来为了运行 <code>round()</code> 方法而构造一个类 <code>Math</code> 的实例，确实是浪费了很多高价值的内存堆空间吧？对于 <em>其他</em> 一些 <code>Math</code> 的方法，比如接收两个数字原生值并返回二者中较小的值的 <code>min()</code>，或 <code>max()</code>，或者返回某个数的绝对值的 <code>abs()</code>等等，又会怎样呢？</p>
<p><em><strong>这些方法绝不会用到实例变量值</strong></em>。事实上类 <code>Math</code> 是没有任何实例变量的。那么构造一个类 <code>Math</code> 的实例就没有任何价值。所以猜猜会怎样？所以就不必构造类 <code>Math</code> 的对象。事实上也无法构造类<code>Math</code>的实例。</p>
<p><strong>在尝试构造类 <code>Math</code> 的实例时</strong>：</p>
<pre><code class="language-java">Math mathObj = new Math();
</code></pre>
<p><strong>将得到这个错误消息</strong>：</p>
<pre><code class="language-console">Math() has private access in java.lang.Math
</code></pre>
<blockquote>
<p>该错误消息显示，<code>Math</code> 构造器是被标记为 <code>private</code> 的！那就是说，<strong>绝</strong> 不可以在类 <code>Math</code> 上写 <code>new</code> 来构造一个新的 <code>Math</code> 对象。</p>
</blockquote>
<p><img src="images/Ch10_01.png" alt="类Math的方法" /></p>
<p><em>图 1 - 类<code>Math</code>的方法</em></p>
<h3 id="常规非静态方法与静态方法的区别"><a class="header" href="#常规非静态方法与静态方法的区别">常规（非静态）方法与静态方法的区别</a></h3>
<p>虽然Java作为面向对象语言，不过后面就会发现一个特殊案例，尤其是那些工具方法（就像这些<code>Math</code>的方法），在这些地方就没有必要用到类的实例。关键字 <code>static</code> 让方法在 <em><strong>没有任何其所属类的实例</strong></em> 情况下，就可以运行。静态方法就是指 “其行为不依赖实例变量，因此不需要实例或对象。只需要类就行”。</p>
<p><img src="images/Ch10_02.png" alt="常规方法与静态方法的区别" /></p>
<p><em>图 2 - 常规方法与静态方法的区别</em></p>
<p><img src="images/Ch10_03.png" alt="静态方法与非静态方法的调用" /></p>
<p><em>图 3 - 静态方法与非静态方法的调用</em></p>
<h3 id="让类具有静态方法有什么意义"><a class="header" href="#让类具有静态方法有什么意义">让类具有静态方法有什么意义？</a></h3>
<p>通常（尽管不总是这样），有着静态方法的类，都是些不打算被实例化的类（Often(although not always), a class with static methods is not meant to be instantiated）。在第8章就谈到过抽象类，以及如何使用 <code>abstract</code> 关键字类对类进行标记，从而使得任何人都不可以在那个类类型上写 <code>new</code>。也就是说，<em><strong>绝无可能对抽象类进行实例化</strong></em>。</p>
<p>到这里，还可以通过将构造器标记为 <code>private</code>，来阻止其他代码对 <em>非</em>抽象类进行实例化了。请记住，标记为 <code>private</code> 的方法意味着只有类中的代码才可以运行那个方法。标记成 <code>private</code> 的构造器，基本与标记为 <code>private</code> 的方法一样 -- 只有类中的代码才可以运行构造器。那么在类 <em>外部</em> 就没有人可以对类写 <code>new</code> 了。这就是类 <code>Math</code> 的运作方式。他的构造器是私有的，就不能构造出 <code>Math</code> 的实例。编译器了解你的代码是不能访问私有构造器的。</p>
<p>这又并不是说，有着一个或多个静态方法的类，绝对不会被实例化。事实上，只要放入了一个 <code>main()</code> 方法，那个类中就有了一个静态方法！</p>
<p>通常是要构造一个 <code>main()</code> 方法来启动或测试另一个类的，几乎总是要在 <code>main()</code> 方法中去实例化某个类，且随后会在构造的新实例上运行某个方法。</p>
<p>因此虽然存在一个非静态方法，就意味着一定有某种构造类实例的方式，但在类中结合静态和非静态方法一起使用，是自由的。获取新对象的唯二方式，是通过关键字 <code>new</code>，或者逆序列化（deserialization, 或称为Java Reflection API，附录会讲到）。此外并无他法。不过还有一个非常有趣的问题，那就是到底是 <em>谁</em> 来写下 <code>new</code>，后面会讨论这个问题。</p>
<h3 id="静态方法不能使用非静态实例变量"><a class="header" href="#静态方法不能使用非静态实例变量">静态方法不能使用非静态（实例）变量！</a></h3>
<p><strong>Static methods can't use non-static (instance) variable</strong>!</p>
<p>静态方法的运行，无需对其所属类的任何特定实例有所了解。就如同前面所说的，静态方法所属类甚至没有实例变量。因为静态方法是使用 <em>类</em>（<code>Math.random()</code>），而非 <em>实例引用变量</em> （<code>t2.play()</code>）调用，所以静态方法就不能引用其所属类的任何实例变量。</p>
<p><strong>若尝试编译这样的代码：</strong></p>
<pre><code class="language-java">class Duck {
    private int size;

    public static void main (String [] args) {
        System.out.format(&quot;Size of duck is %s\n&quot;, size);    // 哪个 Duck? 谁的 size ?
    }                                                       // 若在内存堆上的某处有个 Duck, 这里也是对其一无所知的

    public void setSize (int s) {
        size = s;
    }

    public int getSize () {
        return size;
    }
}
</code></pre>
<p><strong>将收到这样的错误信息</strong>：</p>
<pre><code class="language-console">non-static variable size cannot be reference from a static context
</code></pre>
<blockquote>
<p><strong>在某个静态方法中尝试使用实例变量时，编译器就会想 “我不知道你讲的是哪个对象的实例变量”！就算在内存堆上有 10 只鸭子，静态方法也对他们一无所知</strong>。</p>
</blockquote>
<h3 id="静态方法也不能使用非静态方法"><a class="header" href="#静态方法也不能使用非静态方法">静态方法也不能使用非静态方法！</a></h3>
<p>非静态方法是用来做什么的？<em><strong>非静态方法通常要使用实例变量的状态，来影响他们自己的行为</strong></em>。<code>getName()</code>方法，返回的是变量 <code>name</code> 的值。谁的名字？当然是用于运行 <code>getName()</code> 方法的那个对象的 <code>name</code>。</p>
<p><strong>这段代码不会被编译</strong>：</p>
<pre><code class="language-java">class Duck {
    private int size;

    public static void main (String [] args) {
        System.out.format(&quot;Size of duck is %s\n&quot;, getSize());    // 调用 getSize () 方法只是推迟了必然会出现的问题 -- getSize() 使用了实例变量 size
    }

    public void setSize (int s) {
        size = s;
    }

    public int getSize () {
        return size; // 这里又回到同样的问题......到底是谁的 size ？
    }
}
</code></pre>
<p><strong>错误信息</strong>：</p>
<pre><code class="language-console">non-static method getSize() cannot be reference from a static context
</code></pre>
<h3 id="答疑-7"><a class="header" href="#答疑-7">答疑</a></h3>
<ul>
<li><strong>去调用那些不使用任何实例变量的非静态方法会怎么样，编译器会允许吗</strong>？</li>
</ul>
<blockquote>
<p>不行。编译器对是否在非静态方法中有没有使用实例变量清楚得很。设想如果那样可以通过编译，而又在未来的某一天，修改了非静态方法的实现而带进了实例变量，会有什么影响？或者更离谱，在某个子类重写了那个非静态方法，并在重写版本中带入了一个实例变量呢？</p>
</blockquote>
<ul>
<li><strong>对天发誓，见到过使用引用变量，而并非类名字去调用静态方法的代码</strong>。</li>
</ul>
<blockquote>
<p>是可以那样做，但就跟你妈妈经常教导你那样，“仅仅因为它是合法的并不意味着它是好的（Just because it's legal doesn't mean it's good）”。虽然使用类实例去调用静态方法可行，但这样写会构造出带误导性（缺乏可读性）代码。你可以这样写：</p>
</blockquote>
<pre><code class="language-java">Duck d = new Duck ();
String[] = {};
d.main(s);
</code></pre>
<blockquote>
<p>这段代码是合法的，但编译器只会将这段代码解析回真正的类（“好的”，<code>d</code> 的类型为 <code>Duck</code>，同时 <code>main()</code> 是静态的，那么我就会调用类 <code>Duck</code> 中的静态 <code>main()</code>）。也就是说，使用实例 <code>d</code> 来运行 <code>main()</code> 并不会让 <code>main()</code> 对这个引用的对象 <code>d</code> 有更多具体知识。这只是另一种调用静态方法的方式而已，方法本身仍然是静态的！</p>
</blockquote>
<p>故有诗云：</p>
<blockquote>
<p>红玫瑰</p>
<p>开得晚</p>
<p><strong>实例变量的状态</strong></p>
<p><strong>静态方法见不到</strong></p>
</blockquote>
<h3 id="静态变量对类的-所有-实例其值保持一致"><a class="header" href="#静态变量对类的-所有-实例其值保持一致">静态变量：对类的 <em>所有</em> 实例，其值保持一致</a></h3>
<p><strong>Static variable: value is the same for ALL instances of the class</strong></p>
<p>设想打算数一下程序运行时创建了多少个 <code>Duck</code> 的实例。怎样才能做到呢？或许需要一个在构造器中递增的实例变量？</p>
<pre><code class="language-java">clas Duck {
    int duckCount = 0;

    Duck () {
        duckCount++; // 这会在每次构造出一个 Duck 时，将 duckCount 设置为 1
    }
}
</code></pre>
<p>这样写是做不到的，因为<code>duckCount</code>是个实例变量，对每个 <code>Duck</code>都是以 <code>0</code> 开始的。当然可以再构造另一个类来完成 <code>Duck</code> 的计数，但那样就显得笨拙。这个时候就需要一个只有某变量的单份拷贝，且所有实例变量都共享那份拷贝的类。</p>
<p>这就是静态变量可以给到的特性：可被所有类实例共享的值。也就是说，每个类一个值，而非每个实例一个值（In other words, one value per <em>class</em>, instead of one value per <em>instance</em>）。</p>
<pre><code class="language-java">class Duck {
    private int size;
    private static int duckCount = 0;   // 这个静态变量 `duckCount` 只会在类第一次加载时初始化
                                        // 而不会在每次构造新实例时初始化

    Duck () {
        duckCount++;    // 因为 duckCount 是静态的，且不会被重置为 0
                        // 所以现在静态变量 duckCount 就会在 Duck 构造器每次运行时递增
    }

    public void setSize (int s) {
        size = s;
    }

    public int getSize () {
        return size;
    }
} 
</code></pre>
<p><img src="images/Ch10_04.png" alt="实例变量与静态变量的区别" /></p>
<p><em>图 4 - 实例变量与静态变量的区别</em></p>
<p><strong>静态变量是共享的</strong>。</p>
<p><strong>同一类的所有实例，共享静态变量的单个拷贝</strong>。</p>
<ul>
<li>实例变量：每个 <strong>实例</strong> 一个</li>
<li>静态变量：每个 <strong>类</strong> 一个</li>
</ul>
<h3 id="脑力锻炼"><a class="header" href="#脑力锻炼">脑力锻炼</a></h3>
<p>在本章早先部分，我们见到了私有构造器表示类不可被类外部的代码实例化。也就是说，只有类里面的代码，才可以使用私有构造器，构造类的新实例。（这里就有了“鸡生蛋蛋生鸡”问题。）</p>
<p>若要编写一个只能构造一个实例，且要使用类实例的所有人，就都只能使用这单个的实例，会怎样呢？</p>
<h3 id="静态变量的初始化"><a class="header" href="#静态变量的初始化">静态变量的初始化</a></h3>
<p><strong>Initializing a static variable</strong></p>
<p>静态变量是在 <em>类加载</em> 的时候初始化的。而类的加载，则是 JVM 判定应该加载他的时候，才加载的。通常情况下，JVM加载某个类，是因为第一次有人尝试构造那个类的新实例，或者使用该类的静态方法或静态变量。作为 Java 程序员，当然还有显式地让JVM去加载某个类的选项，不过极不可能需要去那样做的。在几乎所有情况下，都最好让JVM去决定何时加载类。</p>
<p>同时静态变量初始化有两条定律：</p>
<ul>
<li>类中的静态变量，是在类的所有对象可被创建出来之前初始化的</li>
<li>类中的静态变量，是在类的所有静态方法运行之前初始化的</li>
</ul>
<pre><code class="language-java">class Player {
    static int playerCount = 0; // playerCount 是在类 Player 加载时初始化的。
    private String name;        // 这里显式将其初始化为 0，不过并不需要，因为整数
                                // 的默认值本来就是 0。静态变量获取默认值的方式，与
                                // 实例变量是一样的。
    Player (String n) {
        name = n;
        playerCount++;          // 已声明但未初始化的静态变量与实例变量，他们的默认值
    }                           // 一样：
}                               // 原生整数（长整形、短整型等）：0
                                // 原生浮点数（单精度、双精度）：0.0
                                // 布尔值：false
public class PlayerTestDrive {  // 对象引用变量：null 
    public static void main (String[] args) {
        System.out.println(Player.playerCount);
        Player one = new Player (&quot;Tiger Woods&quot;);
        System.out.println(Player.playerCount);
    }                        // 对静态变量的访问，就如同对静态
}                            // 方法的访问 -- 使用类的名字。
</code></pre>
<p>运行结果：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
0 &lt;-- 在没有构造任何实例时
1 &lt;-- 在构造了一个对象后
</code></pre>
<h3 id="静态最终变量即为常量"><a class="header" href="#静态最终变量即为常量">静态最终变量即为常量</a></h3>
<p><strong><code>static</code> <code>final</code> variables are constants</strong></p>
<p>标记为 <code>final</code> 的变量，就意味着 -- 一旦被初始化 -- 就绝不会再改变。也就是说，静态最终变量的值，从类被加载开始，就始终保持一致。查看 Java API 中的 <code>Math.PI</code> ，就会发现：</p>
<pre><code class="language-java">public static final double PI = 3.1415926535889793;
</code></pre>
<p>变量 <code>PI</code> 被标记为 <code>public</code> 表示所有代码都可以访问他。</p>
<p>标记为<code>static</code>就无需类 <code>Math</code> 的实例就可以使用（还要记住不能创建类 <code>Math</code>的实例）。</p>
<p>还因为 <code>PI</code> 是不会改变的，因此变量 <code>PI</code> 又被标记为了 <code>final</code>（就Java 这个编程语言来说）。</p>
<p>除了上面这种方式，就再没有其他方式将变量指定为常量了，但对常量命名的约定，可以帮助我们识别出其为常量。<em><strong>常量的名字，应全为大写</strong></em>！</p>
<blockquote>
<p><strong>静态初始化器（static initializer），是一个在类加载时，于外部代码可以使用这个类前，运行的一个代码块，因此这个代码块就是对静态最终变量进行初始化的好地方</strong>。</p>
</blockquote>
<pre><code class="language-java">class Foo {
    final static int X;

    static {
        X = 42;
    }
}
</code></pre>
<p><img src="images/Ch10_05.png" alt="静态最终变量 -- 常量，与静态初始化器" /></p>
<p><em>图 5 - 静态最终变量 -- 常量，与静态初始化器</em></p>
<h3 id="final-不止于-static-变量"><a class="header" href="#final-不止于-static-变量"><code>final</code> 不止于 <code>static</code> 变量</a></h3>
<p>也可使用关键字 <code>final</code> 去修改非静态变量，包括实例变量、本地变量，甚至方法的参数。在每种情况下，关键字 <code>final</code> 都意味着同样的事情：再也不能改变值了。还可以使用关键字 <code>final</code> 去阻止别人重写方法，或构造子类。</p>
<ul>
<li><strong><code>final</code> 的那些非静态变量</strong></li>
</ul>
<pre><code class="language-java">class Foof {
    final int size = 3; // 现在就再不能修改 size 了
    final int whuffie;

    Foof () {
        whuffie = 42; // 这里是不能修改 whuffie 的
    }

    void doStuff (final int x) {
        // 就无法改变 x 了
    }

    void doMore () {
        final int z = 7;
        // 就无法改变 z 了
    }
}
</code></pre>
<blockquote>
<p>实际上这里有个问题。其中的 <code>final int whuffie;</code> 语句中的 <code>whuffie</code> 实例变量，其默认值不是 <code>0</code> 吗？怎么后面又可以再构造器中赋值呢？说明构造器是最先运行的。</p>
</blockquote>
<ul>
<li><strong><code>final</code> 的方法</strong></li>
</ul>
<pre><code class="language-java">class Poof {
    final void calcWhuffie () {
        // 必须保证不被重写的
        // 一些重要事务
    }
}
</code></pre>
<ul>
<li><strong><code>final</code> 的类</strong></li>
</ul>
<pre><code class="language-java">final class MyMostPerfectClass {
    // 这个类就不能被扩展了
}
</code></pre>
<blockquote>
<p><strong><code>final</code> 的 <em>变量</em>，就是说不能修改他的值</strong>。</p>
<p><strong><code>final</code> 的 <em>方法</em>，就是说不能重写这个方法</strong>。</p>
<p><strong><code>final</code> 的 <em>类</em>，就是说不能对这个类进行扩展（即不能构造他的子类）</strong>。</p>
</blockquote>
<h2 id="答疑-8"><a class="header" href="#答疑-8">答疑</a></h2>
<ul>
<li><strong>静态方法不能访问非静态变量。那么非静态方法可以访问静态变量吗</strong>？</li>
</ul>
<blockquote>
<p>当然，类中的非静态方法，总是可以调用类中的静态方法，以及类的静态变量。</p>
</blockquote>
<ul>
<li><strong>将类标记为 <code>final</code> 的目的是什么？这样做不就与面向对象的整体目标相违背了吗</strong>？</li>
</ul>
<blockquote>
<p>是的，不会。将类构造成 <code>final</code>的典型原因，是为了安全性。比如就无法构造类 <code>String</code> 的子类。设想有人扩展了类 <code>String</code>，并以多态方式，在原本是 <code>String</code> 对象的地方，使用他们自己的<code>String</code>子类对象，会是多大的麻烦。在需要一些方法保持特定实现时，就要把他们的类标记为 <code>final</code>。</p>
</blockquote>
<ul>
<li><strong>如果类已经是 <code>final</code>了，那么再把其中的方法标记为 <code>final</code>，不就是多余的吗</strong>？</li>
</ul>
<blockquote>
<p>在类为 <code>final</code> 时，就不需要将方法标记为 <code>final</code>了。想想吧 -- 在类为 <code>final</code> 时，就不能被扩展为子类，那么当然他的方法就不能被重写了。</p>
<p>此外，在确实打算允许其他人对你编写的类进行扩展，又不想要他们重写其中的一些而不是全部的方法时，就可以不将这个类整个标记为 <code>final</code>，而是有选择性地将特定方法标记为 <code>final</code>就行了。最终方法指的就是子类不能对其进行重写。</p>
</blockquote>
<h2 id="知识点-3"><a class="header" href="#知识点-3">知识点</a></h2>
<ul>
<li>
<p>调用静态方法应使用类名字，而不是对象引用变量：</p>
<p><code>Math.random()</code> 与 <code>myFoo.go()</code></p>
</li>
<li>
<p>无需堆上静态方法所属类上的任何实例变量，就可以运行静态方法；</p>
</li>
<li>
<p>对于不依赖特定实例变量值的那种工具性方法，写成静态方法是不错的选择；</p>
</li>
<li>
<p>静态方法不与特定实例关联 -- 而只与类关联 -- 因此静态方法就访问不到其所属类的所有实例变量。静态方法不知道该去使用那个实例的值；</p>
</li>
<li>
<p>静态方法无法访问到非静态方法，这是因为非静态方法通常是与实例变量状态关联起来的；</p>
</li>
<li>
<p>在类只有静态方法时，就不希望整个类被实例化，从而可将类构造器标记为 <code>private</code>；</p>
</li>
<li>
<p><em>静态变量</em>是类的全体实例共享的变量。类中的静态变量只有一份拷贝，而不是实例变量那样每个实例都有一份拷贝；</p>
</li>
<li>
<p>静态方法可以访问静态变量；</p>
</li>
<li>
<p>在 Java 语言中要构造一个常量，是将某个变量同时标记为 <code>static</code> 与 <code>final</code>实现的；</p>
</li>
<li>
<p>最终静态变量必须被赋值，要么在声明时，要么在某个静态初始化器中。</p>
</li>
</ul>
<pre><code class="language-java">static {
    DOG_CODE = 420;
}
</code></pre>
<ul>
<li>常量（<code>final</code> <code>static</code> variables）的命名约定是要将名字全部大写；</li>
<li>标记为 <code>final</code> 的变量，一经赋值后就不能在改变了；</li>
<li>给某个 <code>final</code> 的实例变量赋值，要么在该变量声明时，要么在构造器中；</li>
<li><code>final</code> 的方法不能被重写；</li>
<li><code>final</code>的类无法被扩展（子类化操作）。</li>
</ul>
<h2 id="类math的那些方法"><a class="header" href="#类math的那些方法">类<code>Math</code>的那些方法</a></h2>
<p>既然已经知道静态方法工作的方式，不如现在来看看类 <code>Math</code>中的一些静态方法。这里举例的只是其中一些常用的。对照 API 文档，就可以查看到剩余的那些，包括 <code>sqrt()</code>、<code>tan()</code>、<code>ceil()</code>、<code>floor()</code>以及 <code>asin()</code>等等。</p>
<ul>
<li><strong><code>Math.random()</code></strong></li>
</ul>
<blockquote>
<p>返回一个<code>0.0</code>到<code>1.0</code>（不包括<code>1.0</code>）之间的双精度数。</p>
</blockquote>
<pre><code class="language-java">double r1 = Math.round();
int r2 = (int) (Math.random() * 5);
</code></pre>
<ul>
<li><strong><code>Math.abs()</code></strong></li>
</ul>
<blockquote>
<p>返回一个双精度数，为参数的绝对值。该方法有多个过载方法，因此如果传入的是整数，那么返回的也是整数；传入的是双精度数，返回的也是双精度数。</p>
</blockquote>
<pre><code class="language-java">int x = Math.abs(-240); // 返回 240
double d = Math.abs(240.45); // 返回 240.45
</code></pre>
<ul>
<li><strong><code>Math.round()</code></strong></li>
</ul>
<blockquote>
<p>返回参数被取整到最近的整数或长整数（取决于参数是单精度或是双精度数）。</p>
</blockquote>
<pre><code class="language-java">int x = Math.round(-24.8f); // 返回 -25
int y = Math.round(24.45f); // 返回 24
                        //请记住，浮点数在没有加上字母 ‘f’ 时，默认都假定是双精度数
</code></pre>
<ul>
<li><strong><code>Math.min()</code></strong></li>
</ul>
<blockquote>
<p>返回两个参数中较小的数。该方法也具有多个过载方法，用于接收整数、长整数、单精度浮点数或双精度数。</p>
</blockquote>
<pre><code class="language-java">int x = Math.min(24, 240); // 返回 24
double y = Math.min(90876.5, 90876.49); // 返回 90876.5
</code></pre>
<ul>
<li><strong><code>Math.max()</code></strong></li>
</ul>
<blockquote>
<p>与 <code>Math.min()</code> 类似，返回两个参数中的较大值。也是过载的方法。</p>
</blockquote>
<h2 id="对原生值进行包装"><a class="header" href="#对原生值进行包装">对原生值进行包装</a></h2>
<p><strong>Wrapping a primitive</strong></p>
<p>一些时候要将原生值当作对象来对待。比如在 Java 早于5.0的全部版本中，是无法把原生值直接放入到 <code>ArrayList</code>或 <code>HashMap</code>等数据结构中去的：</p>
<pre><code class="language-java">int x = 32;
ArrayList list = new ArrayList();
list.add(x);    // 在 5.0 之前的 Java 版本中，这样写是不行的！！ 
                // 那个时候 ArrayList 还没有 add(int) 方法
                // 来接收整数！（那个时候的 ArrayList 只有
                // 接收对象引用变量，而非原生值的 add() 方法）
</code></pre>
<p>每种原生值类型都有一个打包类，且因为这些打包类都是在 <code>java.lang</code> 包中，所有不必导入他们。由于这些类的名字，都是将（全小写字母的）原生值类型的首字母改为大写得来，因此就很容易识别和区分这些类。</p>
<p>由于某种无人所知的原因，JAVA API 设计者们，决定了不把这些类的名字，按照原生值类型与类类型准确地映射起来（Oh yeah, for reasons absolutely nobody on the planet is certain of, the API designers decided not to map the names <em>exactly</em> from primitive type to class type）。后面就会明白这句话说的是什么。</p>
<p><img src="images/Ch10_06.png" alt="原生类型包装类的名字：例外" /></p>
<p><em>图 6 - 原生类型包装类的名字：例外</em></p>
<p><img src="images/Ch10_07.png" alt="什么是原生值包装类" /></p>
<p><em>图 7 - 什么是原生值包装类</em></p>
<h3 id="在-50-版本之前的-java-中就不得不自己去做"><a class="header" href="#在-50-版本之前的-java-中就不得不自己去做">在 5.0 版本之前的 Java 中，就不得不自己去做...</a></h3>
<blockquote>
<p>太TM愚蠢了，那时候不能构造整数的 <code>ArrayList</code>？必须把每个整数都包装成新的 <code>Integer</code> 对象，然后再在要访问 <code>ArrayList</code> 中的值的时候，从 <code>Integer</code>对象解包为 整数？这样真是浪费时间，并必然会出错的......</p>
</blockquote>
<p>在先于 5.0 版本的所有 Java 版本中，原生值就是原生值，对象引用就是对象引用，二者直接绝不会视为可互换的（In all versions of Java prior to 5.0, primitives were primitives and object references were object references, and they were NEVER treated interchangeably）。都是依赖程序员去完成打包和解包。并无将原生值传递给期望得到对象引用变量的方法，也没有方法来把方法返回的对象引用变量，直接赋值给原生值变量 -- 就算是返回的引用变量指向的是一个 <code>Integer</code>对象，要赋值的是个原生的 <code>int</code> 变量也是不行的。<code>Integer</code>与<code>int</code>两个类型之间，就是没有联系，而实际上 <code>Integer</code>是有一个类型为 <code>int</code> 的实例变量的（用于保存 <code>Integer</code> 所包裹的原生值）。这些事情，都有由程序员来亲自做。</p>
<p><strong>一个原生整数的 <code>ArrayList</code></strong></p>
<p><em><strong>在没有 “自动装箱” 特性时（Java 5.0 之前的版本）</strong></em></p>
<pre><code class="language-java">public void doNumsOldWay () {
    ArrayList listOfNumbers = new ArrayList (); // 构造一个 ArrayList。（请记住，在 5.0 之前是无法
                                                // 指定类型的，因此所有的 ArrayList 都是 Object 的
                                                // 清单）
    listOfNumbers.add(new Interger(3)); // 是不能将原生值 '3' 加入到清单的，因此
                                        // 必须首先将其包装为一个 Integer
    Integer one = (Integer) listOfNumbers.get(0);   // 从 listOfNumbers 这个 ArrayList 中出来的
                                                    // 是个 Object, 不过可以将其强制转换为 Integer
    int intOne = one.intValue(); // 终于可以从 Integer 得到整个原生值了。
}
</code></pre>
<h3 id="自动装箱模糊原生值与对象之间的界线"><a class="header" href="#自动装箱模糊原生值与对象之间的界线"><a id="autoboxing"></a>自动装箱：模糊原生值与对象之间的界线</a></h3>
<p><em><strong>Autoboxing: bluring the line between primitive and object</strong></em></p>
<p>Java 5.0 加入进来的自动装箱特性（the autoboxing feature），就可以 <em>自动</em> 完成原生值到包装对象的转换！</p>
<p>下面瞧瞧在构造一个保存整数的 <code>ArrayList</code> 时，发生了什么。</p>
<p><strong>一个原生整数的 <code>ArrayList</code></strong></p>
<p><em><strong>有着自动装箱时（Java 5.0 及以后的版本中）</strong></em></p>
<pre><code class="language-java">public void doNumsNewWay () {
                                    // 构造一个类型为 Integer 的 ArrayList 
    ArrayList&lt;Integer&gt; listOfNumbers = new ArrayList&lt;Integer&gt;;

    listOfNumbers.add(3); // 这样就加入进去了！
                                    // 尽管 ArrayList 中没有 add(int) 的方法，编译器
                                    // 仍然为你做了所有包装（打包）的工作。也就是说
                                    // 现在确实有一个 Integer 对象存储在这个 ArrayList
                                    // 中了，只不过这里 “假装” ArrayList 接收的是整数而已
                                    // （既可以把整数，也可以把 Integer 对象添加到
                                    // ArrayList&lt;Integer&gt;中去）

    int num = listOfNumbers.get(0);
        // 编译器还会自动将 Integer 对象解包，从而可将整数值直接赋值到原生变量
        // 无需调用 Integer 对象上的 intValue() 方法
}
</code></pre>
<ul>
<li><strong>既然要保存 <code>int</code>s, 为什么不声明一个 <code>ArrayList&lt;int&gt;</code> 呢</strong>？</li>
</ul>
<blockquote>
<p>因为...不可以这样。请记住，泛型规则（the rule for generic types）就是，你只能指定的，仅为类或接口的类型，并非原生类型。因此 <code>ArrayList&lt;int&gt;</code> 是不会被编译的。不过就如同上面的代码，实际上这并不重要，因为编译器允许把整数放到 <code>ArrayList&lt;Integer&gt;</code> 中去。事实上，在使用兼容Java 5.0 的编译器时，对于把原生值放入到清单为原生值包装类类型的 <code>ArrayList</code>，是没有办法阻止的，也因为在这样的编译器下，自动装箱是默认启用的。那么就可以把原生布尔值放入到 <code>ArrayList&lt;Boolean&gt;</code>中，把字符放入到 <code>ArrayList&lt;Character&gt;</code>里。</p>
</blockquote>
<h3 id="自动装箱几乎无处不在"><a class="header" href="#自动装箱几乎无处不在">自动装箱几乎无处不在</a></h3>
<p><strong>Autoboxing works almost everywhere</strong></p>
<p>自动装箱特性不光是可以完成数据集（a collection）中原生值的打包和解包......还可以让我们在几乎所有期望得到原生值，或原生值包装的任何地方，去方便地直接二者互用。这就非常方便了！</p>
<p><strong>自动装箱的乐趣</strong></p>
<ul>
<li><strong>作为方法的参数使用</strong></li>
</ul>
<blockquote>
<p>在某个方法接收原生值包装类类型时，既可以传递一个引用变量，也可以直接传递一个与包装类类型匹配的原生值。反之依然 -- 在某个方法接收原生值时，既可以传递一个兼容的原生值，也可以传递一个原生值类型对应的包装类类型的引用变量。</p>
</blockquote>
<ul>
<li><strong>在返回值处运用</strong></li>
</ul>
<blockquote>
<p>在某个方法声明了一个原生的返回类型时，既可以返回一个兼容的原生类型值，也可以返回一个声明的原生类型对应的包装类类型的引用变量。反之依然，在某个方法声明了一个原生的包装类类型时，既可以返回一个引用变量，也可以返回一个兼容原生类型的值。</p>
</blockquote>
<ul>
<li><strong>在布尔表达式中运用</strong></li>
</ul>
<blockquote>
<p>在希望得到一个布尔值的任何地方，都既可以使用一个可以计算得到布尔值的表达式（比如：<code>4 &gt; 2</code>），也可以直接使用一个原生布尔值，还可以使用一个到 <code>Boolean</code> 包装类的对象引用变量。</p>
</blockquote>
<ul>
<li><strong>在数字运算中的运用</strong></li>
</ul>
<blockquote>
<p>这可能时最奇怪的运用了 -- 是的，运算中即使期望的是原生值，但仍然可以使用包装类类型。这就意味着可以把自增运算符（<code>++</code>）运用在类 <code>Integer</code> 的对象上！</p>
<p>但不必焦虑，这只是编译器的小把戏。并没有对Java语言本身进行修改来支持这样的在对象上应用运算符的特性；编译器只是在执行运算前，简单地把对象转换成了对象的原生值类型。不过这看起来还是很奇怪的。</p>
</blockquote>
<pre><code class="language-java">Integer i = new Integer(42);
i++;
</code></pre>
<p>同样可以这样写：</p>
<pre><code class="language-java">Integer j = new Integer (5);
Integer k = j + 3;
</code></pre>
<ul>
<li><strong>用在赋值中</strong></li>
</ul>
<blockquote>
<p>可把包装类类型对象或原生值，赋值给匹配的包装类类型引用变量或原生值。比如，一个原生值的 <code>int</code> 变量，就可以赋值给一个 <code>Integer</code>类类型的引用变量，反之亦然。</p>
</blockquote>
<p>下面的这个 <code>TestBox</code> 类，可以通过编译，但运行时会报错。</p>
<pre><code class="language-java">package com.xfoss.learningJava;

public class TestBox {
    Integer i;
    int j;

    public static void main (String [] args) {
        TestBox t = new TestBox ();
        t.go();
    }

    public void go () {
        j = i;
        System.out.format(&quot;j is %s\n&quot;, j);
        System.out.format(&quot;i is %s\n&quot;, i);
    }
}
</code></pre>
<p>错误信息为：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
Exception in thread &quot;main&quot; java.lang.NullPointerException
        at com.xfoss.learningJava.TestBox.go(TestBox.java:13)
        at com.xfoss.learningJava.TestBox.main(TestBox.java:9)
</code></pre>
<h3 id="等等还有些东西呢这些包装类还有自己的静态工具方法"><a class="header" href="#等等还有些东西呢这些包装类还有自己的静态工具方法">等等！还有些东西呢！这些包装类还有自己的静态工具方法！</a></h3>
<p><strong>But wait! There's more! Wrappers hava static utility methods too!</strong></p>
<p>除了可以像普通类那样行事，包装类还有一大堆相当有用的静态方法。前面就用到过一个 -- <code>Integer.parseInt()</code>。</p>
<p>这些解析方法接收一个字符串，并返回一个原生值。</p>
<p><strong>把字符串转换成原生值就很容易</strong>：</p>
<pre><code class="language-java">String s = &quot;2&quot;;
int x = Integer.parseInt(s); // 把 “2” 解析为 2 是没问题的。
double d = Double.parseDouble(&quot;420.24&quot;);

boolean b = Boolean.parseBoolean(&quot;True&quot;);
                        // Java 1.5 中新的 parseBoolean() 方法会忽略那个字符串参数中的大小写字母。
</code></pre>
<p><strong>但如果这样写</strong>：</p>
<pre><code class="language-java">String t = &quot;two&quot;;
int y = Integer.parseInt(t);    //  噢。这可以通过编译，但在运行时会报错。所有不能被解析为数字的
                                // 的东西，都将导致一个 NumberFormatException 的报错
</code></pre>
<p><strong>将收到这样的运行时例外</strong>：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;two&quot;
        at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
        at java.base/java.lang.Integer.parseInt(Integer.java:652)
        at java.base/java.lang.Integer.parseInt(Integer.java:770)
        at com.xfoss.learningJava.TestBox.go(TestBox.java:13)
        at com.xfoss.learningJava.TestBox.main(TestBox.java:9)
</code></pre>
<p><strong>对字符串进行解析的所有方法或构造器，都可能抛出 <code>NumberFormatException</code>。这是运行时例外，因此可以不必对其加以处理或进行例外声明。不过或许会想要对其进行处理或进行例外声明的</strong>。</p>
<blockquote>
<p>（在下一章就会讲到例外<code>Exception</code>。）</p>
</blockquote>
<h3 id="现在反过来把原生值转换成字符串"><a class="header" href="#现在反过来把原生值转换成字符串">现在反过来......把原生值转换成字符串</a></h3>
<p><strong>And now in reverse......turning a primitive number into a String</strong></p>
<p>把数字转换成字符串的方法有好几种。最容易的就是，把数字直接连接到一个既有的字符串上。</p>
<pre><code class="language-java">double d = 42.5;
String doubleString = &quot;&quot; + d;   // 请记住这里的 ‘+’ 运算符，是 Java 中唯一的一个过载的
                                // 运算符，在这里是一个字符串连接器。所有添加到某个字符串
                                // 的东西，都将被字符串化。

double d = 42.5;
String doubleString = Double.toString(d);   // 另一种使用类 Double 中静态方法 toString()
                                            // 的方式
</code></pre>
<h3 id="数字的格式化操作"><a class="header" href="#数字的格式化操作">数字的格式化操作</a></h3>
<p><strong>Number formatting</strong></p>
<p>在 Java 语言中，对数字进行格式化，不必与 <code>I/O</code> 相关联。细想一下。把数字展示给用户的一种典型方式，就是经由 GUI 途径。把数字放在一个滚动的文本框、或者在表格里。若把格式化写在打印语句中，那么就根本没办法把数字格式化到可以在 GUI 中很好呈现的字符串了。在 Java 5.0 之前的版本中，大部分的格式化操作，是通过 <code>java.text</code> 包中的类来完成的，而这个包在现在版本的本书中甚至没有提及，因为现在Java中已经不是这样的了。</p>
<p>在 Java 5.0 中，Java 团队通过 <code>java.util</code> 包中的 <code>Formatter</code> 类，带来了更加强大且灵活的格式化功能。不过无需自己去创建和调用<code>Formatter</code>类上的方法，因为Java 5.0 已经将一些便捷方法，添加到部分 <code>I/O</code> 类（包括 <code>printf()</code>）及<code>String</code>类了。因此调用 <code>String.format()</code>并把需要格式化的东西，以及格式化指令传递给他，就变得相当简单了。</p>
<p>当然，还是必须知道该怎样去提供这些格式化指令，同时如果对 <code>C/C++</code> 中的 <code>printf()</code> 函数不熟悉，那就要费点劲儿了。幸运的是，就算不知道<code>printf()</code>，也可以按照指引，完成一些最基本的格式化操作（就是这里所展示的）。但如果要进行混合与匹配，来得到想要的全部，那么就要对<code>printf()</code>有所掌握了。</p>
<p>下面以一个基本例子开始，并在其后看看数字格式化是怎样运作的。（注意：在 <code>I/O</code> 那一章，将再度回顾格式化）</p>
<ul>
<li><strong>将数字格式化为逗号分组样式</strong></li>
</ul>
<p><strong>Formatting a number to use commas</strong></p>
<pre><code class="language-java">package com.xfoss.learningJava;

public class TestFormats {
    public static void main (String [] args) {
                                    // '1234567890' -- 要格式化的数字
                                    // 这里希望让他有些逗号
        System.out.format(&quot;%,d\n&quot;, 1234567890);
                        // &quot;%,d&quot; 就是用于指示如何对作为第二个参数的数字（在
                        // 此示例中，就是一个整数）进行格式化的指令。
                        // 请记住，format() 方法仅有两个参数 -- 第一个逗号是
                        // 在字符串字面值（the String literal, &quot;%,d&quot;）里面的
                        // 因此这个逗号，与第二个逗号不同，他不是把参数分开
                        // 提供给 format() 方法的。
    }
}
</code></pre>
<p>输出：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
1,234,567,890
</code></pre>
<blockquote>
<p>于是就得到了插入到数字中的多个逗号了。</p>
</blockquote>
<h3 id="对格式化的解构"><a class="header" href="#对格式化的解构">对格式化的解构</a></h3>
<p><strong>Formatting deconstructed...</strong></p>
<p>在格式化的最底层（At the most basic level），包含了两个主要部分（当然还有其他东西，不过这里为了简明目的，只讨论两个）：</p>
<ol>
<li>
<p><strong>格式化指令，Formatting instructions</strong></p>
<p>使用了特定的，用于描述如何对参数进行格式化的 <em>格式化说明符</em>（You use special <em>format specifiers</em> that describe how the argument should be formatted）。</p>
</li>
<li>
<p><strong>要格式化的参数，The argument to be formatted</strong></p>
<p>虽然可以有多个参数，但这里会从一个开始。这个参数并非任何类型都可以的...... 只能是可以使用前面格式化指令的格式化说明符可以格式化的。比如在格式化指令指定了一个 <em>浮点数</em> 时，就不能传入一个 <code>Dog</code>，甚至一个看起来像浮点数的 <code>String</code>也是不可以的。</p>
<blockquote>
<p>注意：假如已经了解 <code>C/C++</code> 中的 <code>printf()</code> 函数，那么只要跳过接下来的本节的内容就好。</p>
</blockquote>
<p><img src="images/Ch10_08.png" alt="解构格式化" /></p>
<p><em>图 8 - 解构格式化</em></p>
</li>
</ol>
<p><strong>那么这些指令到底说了什么呢</strong>？</p>
<p>“取该方法的第二个参数，并将其作为一个十进制整数进行格式化，并插入 <strong>逗号</strong> （Take the second argument to this method, and format it as a <strong>d</strong>ecimal and insert <strong>commas</strong>）”。</p>
<p><strong>这些指令是怎样来描述的呢（How do they say that）</strong>？</p>
<p>接下来的内容将深入分析语法 <code>&quot;%, d&quot;</code> 的具体意义，但对于初学者来说，当你在某个格式化字符串（a format String, 格式化字符串始终是 <code>format()</code> 方法的第一个参数）中，看到百分号（<code>%</code>）时，把他想作表示某个变量就行了，而这个变量就是<code>format()</code>方法的第二个参数。百分号后其余的字符，描述的就是那个参数的格式指令。</p>
<p><em><strong>百分号（<code>%</code>）说，“在这里插入参数”（并使用这些指令来对参数进行格式化）</strong></em></p>
<pre><code class="language-java">System.out.format(&quot;%, d&quot;, 1234567890);
                // 注意：这里的 &quot;%, d&quot; 和 &quot;%,d&quot; 有区别
                // &quot;%,&quot; 和 &quot;d&quot; 之间，只能有两种情况：
                // 1. 什么也没有
                // 2. 一个空格
                // 不能有其他任何字符，包括转义字符
                // 两个空格都不可以
</code></pre>
<p><img src="images/Ch10_09.png" alt="&quot;%.2f&quot;示例" /></p>
<p><em>图 9 - <code>%.2f</code>示例</em></p>
<p>百分号 <code>%</code> 告诉格式化器（the formatter）把<code>format()</code> 方法的另一个参数（即那个数字），插入到这里，<strong>并</strong> 使用百分号后的 <code>.2f</code>字符对其进行格式化。随后将格式化字符串的其余部分，添加到最终输出。</p>
<p><strong>加上一个逗号</strong></p>
<p><img src="images/Ch10_10.png" alt="&quot;%,.2f&quot;示例" /></p>
<p><em>图 10 - <code>&quot;%,.2f&quot;</code>示例</em></p>
<blockquote>
<p>注意：浮点数加入逗号，只会在整数部分，小数部分始终不会添加逗号。</p>
</blockquote>
<pre><code class="language-java">System.out.format(&quot;I have %,d bugs to fix.\n&quot;, 476578.09876);
</code></pre>
<p>上面的语句，可以通过编译，但会报出运行时例外报错：</p>
<pre><code class="language-console">Exception in thread &quot;main&quot; java.util.IllegalFormatConversionException: d != java.lang.Double
</code></pre>
<blockquote>
<p>那么到底是怎样知道指令在何处结束，以及剩余字符从哪里开始的呢？又为何没有把 <code>&quot;%.2f&quot;</code> 中的 <code>f</code> 打印出来呢？怎样才知道 <code>.2f</code> 是格式化指令的一部分，而不是字符串的一部分的呢？</p>
</blockquote>
<p><strong>格式化字符串，使用了他自己的小语言语法（The format String uses its' own little language syntax）</strong></p>
<p>显然在百分号 <code>%</code> 后面是不能放上任意字符的。跟在百分号后面的东西的语法，要遵循非常明确的规则，这些百分号后面的部分，描述了对要插入到结果（已格式化）字符串的那个点上的参数，如何进行格式化（The syntax for what goes after the percent sign follows very specific rules, and describes how to format the argument that gets inserted at that point in the result(formatted) String）。</p>
<p>已经见到的两个示例：</p>
<ul>
<li><code>%,d</code> 是指“插入逗号，并把那个数字作为十进制整数进行格式化” </li>
</ul>
<p>以及</p>
<ul>
<li><code>%.2f</code> 指 “将那个数字作为具有两位小数精度的浮点数进行格式化”</li>
</ul>
<p>还有</p>
<ul>
<li><code>%,.2f</code> 指 “插入逗号，并将那个数字作为具有两位小数精度的浮点数进行格式化”</li>
</ul>
<p>真正的问题在于，“怎么知道，到底该在百分号后面放上什么，才能让 <code>format()</code> 按照自己的想法去执行？” 这就包括了对这些符号的掌握（比如<code>d</code>表示十进制，而<code>f</code>表示浮点数），以及百分号后面的指令放置顺序。比如在把逗号放在<code>d</code>后面，就像这样<code>%d,</code>，而不是<code>%,d</code>，就不会工作的！</p>
<p>或者说，下面这个语句会输出什么呢：</p>
<pre><code class="language-java">String.format(&quot;I have %.2f, bugs to fix.&quot;, 476578.09876);
</code></pre>
<p>其输出为：</p>
<pre><code class="language-console">I have 476578.10, bugs to fix.
</code></pre>
<h3 id="格式化说明符the-format-specifier"><a class="header" href="#格式化说明符the-format-specifier">格式化说明符（The format specifier）</a></h3>
<p>百分号后面直到类型指示符（the type indicator, 比如<code>d</code>或<code>f</code>），且包含类型指示符在内，就是格式化指令部分（part of the formatting instructions）。在类型指示符后，格式化器（the formatter）假定其余的字符集，是作为输出字符串的部分了，直到他遇到另一个百分号（<code>%</code>）。嗯......可能会在遇到百分号吗？可以有多个被格式化的参数变量吗？此时现把这个问题放一放；很快就会回到这个问题。现在就来看看格式化说明符 -- 就是百分号后面，描述参数该如何格式化的东西，他的语法。</p>
<p><strong>格式化说明符可以有最多5个不同的部分（不包括<code>%</code>在内）。下面的在 <code>[]</code> 中的每一样，都是可选的，因此只有百分号（<code>%</code>）和类型是必须的。不过他们的顺序也有强制要求，因此要用到的任何部分，都必须以这个顺序放置</strong>。</p>
<p><img src="images/Ch10_11.png" alt="格式化指示符，The format specifier" /></p>
<p><em>图 11 - 格式化指示符，The format specifier</em></p>
<h3 id="唯一必需的说明符是类型the-only-required-specifier-is-for-type"><a class="header" href="#唯一必需的说明符是类型the-only-required-specifier-is-for-type">唯一必需的说明符是类型（The only required specifier is for TYPE）</a></h3>
<p>虽然类型是唯一必需的说明符，但请记住若放入了其他任何部分时，类型都必须放在最后！类型修饰符（type modifiers）有十余种之多（还不包括日期和时间，他们有自己的修饰符集），但绝大多数时候，都会用到 <code>%d</code>（十进制）或 <code>%f</code>（浮点数）。且通常会将<code>%f</code>与精度指示符（a precision indicator）结合使用，来设置输出中所要的小数位数。</p>
<p><strong>类型是强制要求的，其他都是可选的</strong>。</p>
<ul>
<li><strong><code>%d</code> -- 十进制数</strong></li>
</ul>
<pre><code class="language-java">format(&quot;%d&quot;, 42);
            // '42.25' 就不会工作！这与尝试
            // 直接把双精度数赋值给整数变量
            // 一样。
</code></pre>
<p>这里的参数，必须与整数兼容，因此就只有 <code>byte</code>、<code>short</code>、<code>int</code>与<code>char</code>（或者他们的包装类类型）。</p>
<ul>
<li><strong><code>%f</code> -- 浮点数</strong></li>
</ul>
<pre><code class="language-java">format(&quot;%.3f&quot;, 42.000000);
        // 这里将 'f' 与精度指示符 '.3'结合
        // 因此输出就以 3 个 '0' 结束
</code></pre>
<p>参数必须是某种浮点类型，因此就只有单精度数和双精度数（原生值或包装类类型），还有一种叫做 <code>BigDecimal</code>的类类型。</p>
<ul>
<li><strong><code>%x</code> -- 十六进制数</strong></li>
</ul>
<pre><code class="language-java">format(&quot;%x&quot;, 42);
</code></pre>
<p>输出：</p>
<pre><code class="language-console">2a
</code></pre>
<p>这里的参数必须是 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>（包括他们的原生值和包装类类型），以及 <code>BigInteger</code> 类类型。</p>
<ul>
<li><strong><code>%c</code> -- 字符</strong></li>
</ul>
<pre><code class="language-java">format(&quot;%c&quot;, 42);
            // 数字 '42' 表示了字符 '*'
</code></pre>
<p>这里的参数必须是 <code>byte</code>、<code>short</code>、<code>char</code> 或 <code>int</code>（包括他们的原生值与包装类类型）。</p>
<h3 id="不止一个参数时会发生什么呢"><a class="header" href="#不止一个参数时会发生什么呢">不止一个参数时会发生什么呢？</a></h3>
<p>设想需要一个看起来像这样的字符串：</p>
<blockquote>
<p>“排名为 100,567,890.24 中的第 20,456,654 位。”</p>
</blockquote>
<p>而其中的数字则是来自变量。应该怎么办呢？只需在格式化字符串（第一个参数）后加上两个参数就可以了，那就意味着调用 <code>format()</code> 时，会有三个参数，而不再是两个了。在第一个参数（即格式化字符串）内部，将有两个不同的格式化说明符（两个都以<code>%</code>开头）。第一个格式化说明符将插入该方法的第二个参数，同时第二个格式化说明符会插入该方法的第三个参数。也就是说，格式化字符串中的变量插入，使用的是其余参数传入到<code>format()</code>方法的先后顺序。</p>
<pre><code class="language-java">int one = 20456654;
double two = 100567890.248907;
// 这里演示了格式化说明符种的第一个标志（flag），第一个标志可以是 '&lt;', 'n$'（其中'n'是参数编号，从1开始）
System.out.format(&quot;排名为 %,.2f(%&lt;,.4f, %1$f) 中的第 %,d(%2$16d) 位。\n&quot;, two, one);
</code></pre>
<blockquote>
<p>按照图11 中的说明，似乎格式化字符串（the format String）中的格式化说明符（the format specifier）中的第一个标志（总共四个标志），可以指定使用哪个参数变量的。</p>
</blockquote>
<p>到了日期格式化，就会看到可能会对同一参数变量运用不同格式化说明符的情况。在了解日期是如何格式化（与这里的数字格式化正好相反）之前，是很难设想这样的情况的。马上就会了解这方面的内容，就会看到怎样来更精细地控制哪个格式化说明符与哪个参数相对应。</p>
<ul>
<li><strong>这里可真是有些奇怪的东西呢。就是到底可以传入多少个参数？我的意思是，在<code>String</code>类中到底有多少个<code>format()</code>的重载方法呀？那么在把10个的参数传递给某个单独的输出字符串进行格式化时，会发生什么呢？</strong></li>
</ul>
<blockquote>
<p>问得好。是的，这里确实有了一些奇怪的东西（至少是新东西，且与以往有所不同），然而并不存在一堆的过载<code>format()</code>方法，用来处理未知个数的参数变量。为了支持Java语言中的这个新的格式化功能（类似<code>printf</code>），Java 语言就需要另一个新特性 -- <em>可变参数清单（variable arguments list）</em> （简称为 <code>varargs</code>）。对于设计良好的系统，基本不会用到这个可变参数清单特性。</p>
</blockquote>
<h3 id="讲了这么多的数字关于日期又是怎样的呢"><a class="header" href="#讲了这么多的数字关于日期又是怎样的呢">讲了这么多的数字，关于日期又是怎样的呢？</a></h3>
<p>设想需要这样的一个字符串：&quot;2004年11月28日，星期天&quot;。</p>
<p>是不是并没有什么特别的？好吧，如果全部从一个 <code>Date</code> -- Java中可以表示时间戳的类，类型的变量开始呢，现在就要取用这样的一个对象（与数字有所不同），并将其发送给格式化器。</p>
<p>数字与日期格式化的主要不同，在于日期的各种格式，都使用到一种以<code>t</code>开头的两字符的类型（a two-character type，这一点与数字格式化中使用的 <code>d</code> 或 <code>f</code> 是不同的）。下面的几个示例，可以给你一个日期格式化的运作有大致了解：</p>
<ul>
<li><strong>完整的日期和时间 -- <code>%tc</code></strong></li>
</ul>
<pre><code class="language-java">String.format(&quot;%tc&quot;, new Date());
</code></pre>
<p>输出为：</p>
<pre><code class="language-console">周日 12月 26 16:48:23 CST 2021
</code></pre>
<ul>
<li><strong>只显示时间 -- <code>%tr</code></strong></li>
</ul>
<pre><code class="language-java">String.format(&quot;%tr&quot;, new Date());
</code></pre>
<p>输出为：</p>
<pre><code class="language-console">04:51:24 下午
</code></pre>
<ul>
<li><strong>显示周几，几月，几日 -- <code>%tA</code>, <code>%tB</code>, <code>td</code></strong></li>
</ul>
<p>并没有单个的格式化说明符，来实现这里要求的显示内容，因此就要结合其中三个：周几（<code>%tA</code>）、月份（<code>%tB</code>），以及几号（<code>%td</code>）。</p>
<pre><code class="language-java">Date today = new Date();
String.format(&quot;%tA, %tB %td&quot;, today, today, today);
                // 这个逗号不是格式化的部分......他只是
                // 这里希望在第一个插入的格式化参数之后
                // 打印出来的一个字符。
</code></pre>
<p>的输出为：</p>
<pre><code class="language-java">星期日, 十二月 26
</code></pre>
<blockquote>
<p>不过这样写意味着必须传递 <code>today</code> 这个 <code>Date</code> 对象三次，对于格式化的每个部分，都有传递一次。换句话说，其中的 <code>%tA</code> 只会给到周几，随后还不得不再次传递 <code>today</code> 来获取月份，之后还要为获取几号再传递。</p>
</blockquote>
<p>这样写:</p>
<pre><code class="language-java">System.out.format(&quot;%tA, %tB %td&quot;, now);
</code></pre>
<p>会报出告警：</p>
<pre><code class="language-console">[WARNING] 
java.util.MissingFormatArgumentException: Format specifier '%tB'
</code></pre>
<ul>
<li><strong>与上一个相同，但无需重复的参数 -- <code>%tA, %&lt;tB %&lt;td</code></strong></li>
</ul>
<pre><code class="language-java">Date today = new Date();
String.format(&quot;%tA, %&lt;tB %&lt;td&quot;, today);
</code></pre>
<blockquote>
<p>这里的简括符 <code>&lt;</code>，只是说明符中的一个标志，他告诉格式化器去 “再次使用上一个参数（use the previous argument again）”。如此就避免了参数的重复，而是对同一个参数，进行三次不同方式的格式化。</p>
<p>可以把这样的用法想作是在<code>today</code>这个日期对象上调用三个不同的读取器（getter），来获取这个日期对象的三个不同片段的数据。</p>
</blockquote>
<h2 id="处理日期数据"><a class="header" href="#处理日期数据">处理日期数据</a></h2>
<p><strong>Working with Dates</strong></p>
<blockquote>
<p>来看看这个问题......如果项目是从二月27号开始，八月5号结束，期间有多数个工时呢？</p>
</blockquote>
<p>对于日期数据，除了获取当前日期外，往往还有更多的方面需要处理。比如需要程序去调整日期、找出已使用的时间、排定优先级、进度告警（heck）以及构建进度表等等。那么就需要具备一些工业能力的日期处理能力。</p>
<p>当然可以构造自己的一套日历......（还请不要搞忘了那些闰年！）还有那些时不时的、讨厌的润秒。这样一来情况就会变得很复杂了。不过好消息是 Java API有着丰富的、可帮助对日期进行处理的一些类。甚至有的时候感觉这些类过于丰富了......</p>
<h3 id="在时间中穿梭"><a class="header" href="#在时间中穿梭">在时间中穿梭</a></h3>
<p><strong>Moving backward and forward in time</strong></p>
<p>假设公司的工作安排是周一至周五。安排的任务是找出今年各个日历月中的最后一个工作日......</p>
<p><strong>这样看来<code>java.util.Date</code>，实际上就落伍了......</strong></p>
<p>早先使用了 <code>java.util.Date</code>类来找出当天的日期，那么逻辑上看，这个类在需要一些临时日期处理能力时，比较适合，但只有翻阅一下 API 文档，就会发现 <code>Date</code> 的大部分方法，都已经弃用了！</p>
<p>在获取一个表示当前日期和时间的对象，因此在想要表达“给我当下（give me NOW）”时，就要用到的时间戳时，类<code>Date</code>仍是一个不错的选择。</p>
<blockquote>
<p>在需要一个“现在”的时间戳时，使用类 <code>Date</code>。除此之外，都用类 <code>Calendar</code>。</p>
</blockquote>
<p>好消息时，API推荐使用 <strong><code>java.util.Calender</code></strong> 来代替类 <code>Date</code>，所以就要检视一下这个类：</p>
<p><strong>使用 <code>java.util.Calendar</code> 来操作日期</strong></p>
<p><code>Calendar</code> API 的设计者们，希望从全局、字面上进行思考（The designers of the <code>Calendar</code> API wanted to think globally, literally）。基本概念是在与日期打交道时，就会请求一个日历系统（通过类<code>Calendar</code>的一个静态方法），同时 JVM 把一个<code>Calendar</code>具体子类的实例递送回来。（<code>Calendar</code>实际上是一个抽象类，因此总是与某个具体子类打交道。）</p>
<p>更有趣的时，所获取到的日历系统类别，将适配你的语言环境（More interesting, though, is that the <em>kind</em> of calendar you get back will be <em>appropriate for your locale</em>）。世界上大部分地区都使用的是格里历，而如果不在使用格里历的地区，也可以让 Java 库处理其他的比如佛历、伊斯兰历法或日本历法（Much of the world uses the Gregorian calendar, but if you're in an area that doesn't use a Gregorian calendar you can get Java libraries to handle other calendars such as Buddhist, or Islamic or Japanese）。</p>
<p>标准 Java API 本身带有 <code>java.util.GregorianCalendar</code>类，因此这里将使用格里历。大部分情况下，都不需要了解所使用的 <code>Calendar</code>资料属于何种类别，而是要关注类 <code>Calendar</code>的那些方法。</p>
<h3 id="获取一个对类-calendar进行扩展的对象"><a class="header" href="#获取一个对类-calendar进行扩展的对象">获取一个对类 <code>Calendar</code>进行扩展的对象</a></h3>
<p><strong>Getting an object that extends <code>Calendar</code></strong></p>
<p>要获取某个抽象类的“实例”时，该怎么办呢？当然不会像下面这样，这样写是不行的：</p>
<p><strong>这 <em>不会</em> 工作</strong>：</p>
<pre><code class="language-java">Calendar cal = new Calendar();
                // 编译器不会允许这样干的！
</code></pre>
<p><strong>而是要使用静态的 <code>getInstance()</code> 方法</strong>：</p>
<pre><code class="language-java">Calendar cal = Calendar.getInstance();
                // 到这里这个语法应该看起来不陌生了 --
                // 这里运行了一个静态方法。
</code></pre>
<blockquote>
<p><strong>关于 call 和 invoke</strong>：前者是 “调用”，后者是 “运行”。</p>
</blockquote>
<blockquote>
<p>等一下。既然不能构造类 <code>Calendar</code> 的实例，那到底赋值给那个 <code>Calendar</code> 类型的引用变量了什么呢？</p>
</blockquote>
<p><strong>确实不能获取到一个类 <code>Calendar</code> 的实例，但可以获取一个<code>Calendar</code>具体子类的实例呀</strong>。</p>
<p>显然是无法获取到类 <code>Calendar</code> 的实例的，因为<code>Calendar</code>是一个抽象类。但对于调用 <code>Calendar</code>的静态方法没有影响，仍可以自由调用，因为静态方法是在类上，而不是某个特定实例上调用的。因此对<code>Calendar</code>类上的<code>getInstance()</code>方法进行调用，同时这个方法返回......一个具体子类的实例。这个实例对 <code>Calendar</code>进行扩展（也就是说这个实例可以多态地赋值给 <code>Calendar</code>类型的引用变量），且根据合约，这个实例还可以对类 <code>Calendar</code>的那些方法进行响应。</p>
<p>在世界上大多数地方，同时大多数的 Java版本，都将从<code>getInstance()</code>获取到一个 <code>java.util.GregorianCalendar</code>的实例。</p>
<h2 id="运用-calendar-对象"><a class="header" href="#运用-calendar-对象">运用 <code>Calendar</code> 对象</a></h2>
<p>为了运用好 <code>Calendar</code> 对象，就需要理解几个关键概念：</p>
<ul>
<li><strong>字段保存 <em>状态</em>（Fields hold <em>state</em>）</strong> -- <code>Calendar</code>类类型的对象，有着多个用于表示其最终状态、日期与时间等的字段。举例来说，可以设置某个 <code>Calendar</code> 的 <em>年份</em> 或者 <em>月份</em>；</li>
<li><strong>日期和时间，是可以 <em>增加</em> 的</strong> -- 类 <code>Calendar</code>有一些允许对不同字段的值进行加减的方法，比如“在月份上加一”，或“减去三年”；</li>
<li><strong>日期和时间可以 <em>毫秒</em> 表示</strong> -- 类 <code>Calendar</code> 允许把日期转换成其毫秒表示，以及把毫秒表示转换成日期形式。（需要指出的是，毫秒表示指从 1970年元旦到具体日期的毫秒数。）这样既可以执行诸如“两个时间之间所经历的时间”，或者“在此时间上加63小时23分12秒”等这样的精确计算。</li>
</ul>
<p><strong>运用 <code>Calendar</code>对象的示例</strong>：</p>
<pre><code class="language-java">Calendar c = Calendar.getInstance();

// 将时间设置为 2022年1月7日，15：40：01（注意月份是从零开始的）
c.set(2022, 0, 7, 15, 40);
// 把这个时间转换成一个相当大的毫秒数
//（Convert this to a big ol' amount of milliseconds.）
long day1 = c.getTimeInMillis();
System.out.format(&quot;以毫秒表示: %,d，正常表示：%s\n&quot;, day1, c.getTime());

// 加上相当于一个小时的毫秒数，随后更新这个时间。
// （注意这里的 '+='，作用与 day1 = day1 + ... 一样的）
day1 += 1000*60*60;
c.setTimeInMillis(day1);
System.out.format(&quot;新的几点钟： %d\n&quot;, c.get(c.HOUR_OF_DAY));

// 在日期上加 35， 这就会把我们带到二月份。
c.add(c.DATE, 35);
System.out.format(&quot;加上了35天后： %s\n&quot;, c.getTime());

// 在此日期上往前“滚动” 35天。此操作把日期往前滚动 35天，但不会改变月份！
c.roll(c.DATE, 35);
System.out.format(&quot;往前滚动 35 天： %s\n&quot;, c.getTime());

// 这里没有进行增减，而只是对日期字段执行了一个 “设置”。
c.set(c.DATE, 1);
System.out.format(&quot;日期设置到 1 号： %s\n&quot;, c.getTime());
</code></pre>
<p>输出为：</p>
<pre><code class="language-console">$ java -jar target/com.xfoss.learningJava-0.0.1.jar
以毫秒表示: 1,641,541,202,162，正常表示：Fri Jan 07 15:40:02 CST 2022
新的几点钟： 16
加上了35天后： Fri Feb 11 16:40:02 CST 2022
往前滚动 35 天： Fri Feb 18 16:40:02 CST 2022
日期设置到 1 号： Tue Feb 01 16:40:02 CST 2022
</code></pre>
<p><em>此输出就确认了以上的 <code>getTimeMillis()</code>、<code>add()</code>、<code>roll()</code>以及<code>set()</code>等方法是如何运作的</em>。</p>
<blockquote>
<p><strong>注意</strong>：The <code>java.util.Calendar.roll()</code> method adds(up) or subtracts(down) a single unit of time on the given time field without changing larger fields. -- <em>Java API</em> </p>
<p>这个方法有点古怪。</p>
</blockquote>
<h3 id="calendar-api的一些亮眼之处"><a class="header" href="#calendar-api的一些亮眼之处"><code>Calendar</code> API的一些亮眼之处</a></h3>
<p><strong>Highlights of the <code>Calendar</code> API</strong></p>
<p>上面刚粗略涉及了类 <code>Calendar</code> 中的一些字段及方法。<code>Calendar</code>作为一个大型API，因此这里只能展示一些会用到的最常用字段与方法。在理解了下面的少数几个字段与方法后，就应该能够游刃有余地使用这个API了。</p>
<ul>
<li>
<p><strong><code>Calendar</code>类的关键方法</strong></p>
<ul>
<li>
<p><strong><code>add(int field, int amount)</code></strong></p>
<p>在该日历字段上加减时间。</p>
</li>
<li>
<p><strong><code>get(int field)</code></strong></p>
<p>返回给定日历字段的值。</p>
</li>
<li>
<p><strong><code>getInstance()</code></strong></p>
<p>返回一个 <code>Calendar</code> 类类型对象，这里可以指定一个语言环境（<code>locale</code>）。</p>
</li>
<li>
<p><strong>getTimeInMillis()</strong></p>
<p>以长整型数形式，返回此 <code>Calendar</code> 对象的时间毫秒数。</p>
</li>
<li>
<p><strong><code>roll(int field, boolean up)</code></strong></p>
<p>在不改变较大字段的情况下加上或减去时间（Adds or subtracts time without changing larger fields）。</p>
</li>
<li>
<p><strong><code>set(int field, int value)</code></strong></p>
<p>对给定<code>Calendar</code>字段进行设置。</p>
</li>
<li>
<p><strong><code>set(year, month, day, hour, minute)</code>（全为整数）</strong></p>
<p><code>set()</code> 方法的一个常用变种，用来设置一个完整时间。</p>
</li>
<li>
<p><strong><code>setTimeInMillis(long millis)</code></strong></p>
<p>使用一个长整型的时间，来设置某个 <code>Calendar</code> 类类型对象的时间。</p>
</li>
<li>
<p>其余...</p>
</li>
</ul>
</li>
<li>
<p><strong><code>Calendar</code> 类的关键字段</strong></p>
<ul>
<li>
<p><strong><code>DATE</code>/<code>DATE_OF_MONTH</code></strong></p>
<p>获取/设置日期中的几号。</p>
</li>
<li>
<p><strong><code>HOUR</code>/<code>HOUR_OF_DAY</code></strong></p>
<p>获取/设置 12 小时或 24 小时值。</p>
</li>
<li>
<p><strong><code>MILLISECOND</code></strong></p>
<p>获取/设置毫秒数。</p>
</li>
<li>
<p><strong><code>MINUTE</code></strong></p>
<p>获取/设置分钟。</p>
</li>
<li>
<p><strong><code>MONTH</code></strong></p>
<p>获取/设置月份。</p>
</li>
<li>
<p><strong><code>YEAR</code></strong></p>
<p>获取/设置年份。</p>
</li>
<li>
<p><strong><code>ZONE_OFFSET</code></strong></p>
<p>以毫秒数形式，来获取/设置与GMT的偏移量（Get/set raw offset of GMT in millis）。</p>
</li>
<li>
<p>更多字段......</p>
</li>
</ul>
</li>
</ul>
<h2 id="更多的静态静态的导入"><a class="header" href="#更多的静态静态的导入">更多的静态！......静态的导入</a></h2>
<p><strong>Even more Statics!...static imports</strong></p>
<p>这是 Java 5.0 引入的新特性......这是是喜忧参半的一个特性。一些人喜爱这个主意，另一些则讨厌这个点子。静态导入之所以存在，只是因为他可以节省一些按键输入的时间。在讨厌键盘输入时，就可能会喜欢上这个特性。静态导入的弊端就是 -- 在不注意的时候 -- 他们的使用会造成代码难于阅读。</p>
<p>静态导入背后的基本概念就是，只要使用到静态类、静态变量，或者枚举变量（关于枚举变量，后续会涉及，an enum），就可以将其导入进来，从而节省一些键盘输入。</p>
<p><strong>一些老式代码</strong>：</p>
<pre><code class="language-java">import java.lang.Math;

class NoStatic {
    public static void main(String [] args) {
        System.out.println(&quot;sqrt &quot; + Math.sqrt(2.0));
        System.out.println(&quot;tan &quot; + Math.tan(60));
    }
}
</code></pre>
<p><strong>具有静态导入特性时的代码</strong>：</p>
<pre><code class="language-java">// 在声明静态导入时，所用到的语法
import static java.lang.System.out;
import static java.lang.Math.*;

class WithStatic {
    public static void main(String[] args){
        out.println(&quot;sqrt &quot; + sqrt(2.0));
                            // 运作中的静态导入
        out.println(&quot;tan &quot; + tan(60));
        // 运作中的静态导入
    }
}
</code></pre>
<blockquote>
<p><strong>注意事项（Caveats &amp; Gotchas）</strong></p>
<ul>
<li>
<p>在只打算为数不多地使用某个静态成员时，为了让代码更具可读性，建议避免使用静态导入；</p>
</li>
<li>
<p>在要大量使用某个静态成员时（比如要执行大量的数学计算），这个时候使用静态导入可能就不错；</p>
</li>
<li>
<p>注意在静态导入声明中，可以使用通配符（<code>.*</code>）；</p>
</li>
<li>
<p>静态导入的一个大问题是，容易造成命名冲突（A big issue with static imports is that it's not too hard to create naming conflicts）。
比如，在两个不同类都有 <code>add()</code>方法时（<code>Math</code>和<code>Calendar</code>就是这样的情况），编译器和你自己就不知道到底该使用那个 <code>add()</code> 方法了。</p>
</li>
</ul>
</blockquote>
<h2 id="围炉夜话"><a class="header" href="#围炉夜话">围炉夜话</a></h2>
<p><strong>Fireside Chats</strong></p>
<p>今日主题：<strong>实例变量鄙视静态变量</strong></p>
<p><strong>Tonight's Talk: <em>An instance variable takes cheap shots at a static variable</em></strong></p>
<ul>
<li><strong>实例变量（IV，Instance Variable）</strong>：我甚至不明白为什么我们会在这里讨论。人人皆知静态变量只用在常量上。有几个静态变量啊？我想整个的 API 也就只有四个吧？又没人会用到。</li>
<li><strong>静态变量（SV，Static Variable）</strong>：你真的应该检讨一下了。你都多久没有关注 API 了啊？API整个就是由静态加载的（It's frickin' loaded with statics）！API的一些类，全部都保存的常量值。比如就有一个名为 <code>SwingConstants</code>的类，其中就全是常量值。</li>
<li><strong>IV</strong>：全都是。当然了，你还可以讲出来好几个这样子的。不错，在 <code>Swing</code>库中是有几个这样的，但大家都知道 <code>Swing</code> 只是个特殊案例。</li>
<li><strong>SV</strong>：那可能只是个特例，但他确实是个重要的东西！那类 <code>Color</code>又怎么说？为了构造那些标准颜色去记住各种 RGB 数值，会不会很痛苦呢？可是类 <code>Color</code> 已经有着预先定义好的各种颜色了。这就非常方便了啊。</li>
<li><strong>IV</strong>：好吧，不过除了这少数几个 GUI 的东西外，请举个人人都会实实在在用到静态变量的例子好吗。在具体场合会用到的。</li>
<li><strong>SV</strong>：新手会用到的 <code>System.out</code>怎么样？<code>System.out</code>中的 <code>out</code>就是类 <code>System</code>的一个静态变量。就代码编写者本人而言，并没有构造新的 <code>System</code>的实例，只是请求<code>System</code>提供了他的 <code>out</code>变量。</li>
<li><strong>IV</strong>：好吧，这也不过是另一个特殊用例。而且除了调试之外，没人会用到那个的。</li>
<li><strong>SV</strong>：哦，难道程序调试不重要吗？
有些东西绝对是心胸狭隘的你不知道的 -- 请接受吧，静态变量更具效率。静态变量是每个类有一个的，而不像实例变量，是一个实例一个。这样节省下来的内存，是多么巨大！</li>
<li><strong>IV</strong>：嗯，你是不是搞忘了什么？</li>
<li><strong>SV</strong>：什么？</li>
<li><strong>IV</strong>：静态变量天生就是反面向对象的吧！既然要使用静态变量，那为何不倒退回去，使用过程编程呢（Static variables are about as un-OO as it gets!! Gee why not just go take a giant backwards step and do some procedural programming while we're at it）？</li>
<li><strong>SV</strong>：你说反面向对象是什么意思？</li>
<li><strong>IV</strong>：你静态变量就像是个全局变量，但凡是个程序员，就知道那通常不是件好事（any programmer worth his PDA knows that's usually a Bad Thing）。</li>
<li><strong>SV</strong>：我不是全局变量。Java里根本就没有全局变量。我是存活在类中的！你应该明白，类是一个相当面向对象的东西。我只是呆在那里，在内存空间中的某个地方；我是对象状态的一个天数部分；唯一区别在于，我是类的全体对象所共有的。非常有效率。</li>
<li><strong>IV</strong>：你是存活在类中，不过人们并没有把Java叫做面向类的编程。那样叫得多蠢。你就是个遗迹。你得存在是为了让那些旧时代的程序员过渡到 Java（You're a relic. Something to help the old-timers make the leap to java）。</li>
<li><strong>SV</strong>：好吧就此打住。你真是一派胡言。某个系统的一些静态变量，对于系统至关重要。就算是不那么重要的静态变量，也是为了编码的便利。</li>
<li><strong>IV</strong>：好吧，看起来静态变量/方法的使用似乎有点道理（Well, OK, every once in a while sure, it makes sense to use a static）。不过我告诉你，滥用静态变量（及方法），就是不成熟的面向对象程序员的标志。设计师应该考虑 <em>对象</em> 状态，而不是 <em>类</em> 的状态。</li>
<li><strong>SV</strong>：你说这个做什么？静态方法有什么问题吗？</li>
<li><strong>IV</strong>：静态方法是这中间最糟糕的了，因为使用静态方法常常意味着程序员是在进行过程思维，而没有以对象按照对象的独有状态来行事。</li>
<li><strong>SV</strong>：当然，我知道应该把对象作为面向对象涉及的焦点，但正是由于有那么些无知的程序员......请不要全盘否定过程编程好吧。静态变量/方法仍然有其存在的必要，同时在需要到他们时，他们可以说是无可比拟的（don't throw the baby out with the bytecode. There's a time and place for statics, and when you need one, nothing else beats it）。</li>
<li><strong>IV</strong>：好吧......你就自欺欺人吧（Riiiiiight. Whatever you need to tell yourself...）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="例外处理风险行为"><a class="header" href="#例外处理风险行为">例外处理：风险行为</a></h1>
<p><strong>Exception Handling: Risky Behavior</strong></p>
<blockquote>
<p>那肯定有风险，但在有什么事情出错的时候，可以处理风险。</p>
</blockquote>
<p><strong>发生了状况。文件不在那里。服务器宕机了</strong>。不过你是多么优秀的程序员，都没办法掌控所有事情。总会有些事情会出错。甚至错得离谱。在编写有风险的方法时，就需要代码来处理可能发生的不好情况。那么怎么知道某个方法具有风险呢？同时又要把 <em>处理</em> <strong>例外</strong> 情形的代码放在哪里呢？到目前为止，都还没有真正面对过任何风险。在运行时确实有出错的情况，但这些问题主要是自己编写代码的缺陷。也就是代码漏洞（bugs）。这些在开发时（development time, compilation time and runtime）都可以修复。然而这一章所说的问题处理代码，指的不是之前的那种，而是在运行时无法确保可以工作的代码。比如那些期望文件就在某个目录、服务器是在运行，或者线程确实保持睡眠等等的代码。同时也必须完成对异常处理的掌握。因为就要构建一个 “MIDI 音乐播放器”了。</p>
<h2 id="构造一个music-machine的应用"><a class="header" href="#构造一个music-machine的应用">构造一个“Music Machine”的应用</a></h2>
<p>在接下来的三章，会构建几个有着些许不同的声音应用，包括一个 “BeatBox Drum Machine”。实际上，在本教程完结时，就会写出一个可以把鼓节拍循环，像聊天室应用一样中聊天一样，发送给其他玩家的多玩家版本。虽然可以从GUI章节拷贝写好的程序，不过也可以马上开始编写这个应用的各个部分。</p>
<p>虽然不是每个IT部门都需要这样的一个 “BeatBox” 服务器，这里编写这个应用的目的是更好地掌握 Java 语言。构建的目的是在学习 Java 时可以带来些乐趣而已。</p>
<p><strong>完工后的 “BeatBox” 应用看起来像下面这样</strong>：</p>
<p><img src="images/Ch11_01.png" alt="完成后的“BeatBox”应用" /></p>
<p><em>图 1 - 完成后的“BeatBox”应用</em></p>
<p>玩法是在16个“节拍”的各种乐器的复选框中打勾。比如，在节拍 1（16拍中的）时，贝斯鼓和沙锤就会演奏，节拍 2 上就什么也不会演奏，而在节拍 3 上则是沙锤和踩镲......明白了吧。点击“开始（Start）”按钮，程序就会循环播放编排的这些模式，直到点击 “停止（Stop）”停下来为止。在任何时候都可以通过将这些模式发送给 <code>BeatBox</code>服务器，对自己编排的模式加以“捕获（capture）”（这样其他玩家就可以收听到）。通过点击聊天框中的消息，还可以收听到和消息一起发出来的收到的曲目。</p>
<h2 id="先从简单的开始"><a class="header" href="#先从简单的开始">先从简单的开始</a></h2>
<p><strong>We'll start with the basics</strong></p>
<p>显然在完成这整个的程序前，需要学习一些东西，包括怎样去构建一个 <code>Swing</code> GUI，怎样通过网络通信与另一台机器连接，还需要一个小型的 <code>I/O</code>，从而可以一些东西发送给其他机器。</p>
<p>当然还有 <code>JavaSound</code> 这个 API了。本章就要从这个API开始。现在先不要想 GUI的事情，忘掉网络通信和<code>I/O</code>，而是要专心获取到一些由 MIDI 产生、可以从电脑中传出来的声音。即使对 MIDI，也就是一种读取或构造音乐的技术不了解，也不用担心。</p>
<p>所有需要掌握的内容，这里都有讲到。几乎可以嗅到一个唱片生意的味道。</p>
<h3 id="关于-javasound-api"><a class="header" href="#关于-javasound-api">关于 <code>JavaSound</code> API</a></h3>
<p><code>JavaSound</code>是自 1.3 版本开始加入到 Java 中的一套类与接口。这些类与接口并非特别的附加组件；他们是标准 J2SE 类库的一部分。<code>JavaSound</code>又被分为了两个部分：<code>MIDI</code>和<code>Sampled</code>。这里只使用到 <code>MIDI</code>。<code>MIDI</code>表示“乐器数字接口（Musical Instrument Digital Interface）”，同时也是各种不同种类的电音设备得以通信的标准协议（a standard protocol for getting different kinds of electronic sound equipment to communicate）。但对于这里的 <code>BeatBox</code> app，可以把 <code>MIDI</code> 想作 <em>某种类型的乐谱</em>，可将一些装置，比如某种高科技的“演奏钢琴”，放进这个表格。也就是说，MIDI数据本身并没有包含任何的 <em>声音</em>，他保存的是由MIDI所读取的、某种乐器的、可以回放的 <em>指令</em>（MIDI data doesn't actually include any <em>sound</em>, but it does include the <em>instructions</em> that a MIDI-reading instrument can play back）。或以另一个比方说，可把某个MIDI文件当作一个HTML文档，那么乐器就会对这个MIDI文件进行渲染（也就是演奏这个MIDI文件），如同Web浏览器渲染HTML文档一样。</p>
<p>MIDI数据说的是要做 <em>什么</em>（奏出一个中音<code>C</code>调，还有多大力度，以及这个音有多长等等），但MIDI数据并不会描述会听到的 <em>声音</em>。MIDI是不知道怎样去发出长笛、钢琴或者 Jimi Hendrix 吉他声的。对于这些真实的声音，是需要某种可以读取和演奏MIDI文件的乐器（即MIDI设备）的。不过MIDI设备通常更像 <em>一整个乐队或乐团</em> 的很多种乐器了。这些乐器可以是实体装置，比如摇滚乐手使用的电子键盘合成器，也可以是存在于电脑种的、完全由软件构建的乐器。</p>
<p>对于这里的 <code>BeatBox</code>应用，只会使用到Java自带的、内建的、纯软件的乐器。这些乐器叫做 <em>合成器（synthesizer）</em> （有人也称他们为 <em>软件合成器（software synth）</em>），因为他们可以 <em>创建出</em> 声音来。就是能听到的声音。</p>
<p><img src="images/Ch11_02.png" alt="关于MIDI文件" /></p>
<p><em>图 2 - 关于MIDI文件</em></p>
<h3 id="首先需要一个-sequencer"><a class="header" href="#首先需要一个-sequencer">首先需要一个 <code>Sequencer</code></a></h3>
<p>在可以播放出一个声音出来之前，首先就需要一个 <code>Sequence</code>对象。音序器是一个可以接收全部MIDI数据并将其发送到相应乐器的对象（The sequencer is the object that takes all the MIDI data and sends it to the right instruments）。正是这个东东，负责把音乐 <em>播放</em> 出来。音序器可以完成很多不同的事情，这里只是将其作为一个回访设备使用而已。就跟立体声音响上的CD播放器一样，只不过还有一些其他附加功能特性。类 <code>Sequencer</code>是在 <code>javax.sound.midi</code>包中（这个包是自版本1.3开始的Java的标准库）。因此首先就要确保可以构造（或获取到）一个<code>Sequencer</code>对象。</p>
<pre><code class="language-java">package com.xfoss.BeatBox;

// 这里导入了 javax.sound.midi 包
import javax.sound.midi.*;

public class MusicTest1 {
    public void play () {
        // 这里需要一个 Sequencer 对象。他是要用到的MIDI设备/乐器
        // 的主要部分。他就是把所有MIDI信息编排为一首“乐曲”的那个
        // 东东。但这里不会由我们自己去构造一个全新的 Sequencer 
        // 对象 -- 必须请求 MidiSystem 给出一个来（与之前的用到的 
        // Calendar 类中的静态方法 getInstance() 类似）
        Sequencer seq = MidiSystem.getSequencer();

        System.out.println(&quot;我们就得到了一个‘音序器（Sequencer）’&quot;);
    }

    public static void main(String [] args) {
        MusicTest1 mt = new MusicTest1 ();
        mt.play();
    }
}
</code></pre>
<p>然而在编译编译这段代码时，就会抛出错误：</p>
<pre><code class="language-console">[ERROR] .../src/main/java/com/xfoss/BeatBox/MusicTest1.java:[7,48] unreported exception javax.sound.midi.MidiUnavailableException; must be caught or declared to be thrown
</code></pre>
<p><strong>显然有地方出错了</strong>！</p>
<p>这段代码不会被编译！编译器说有一个必须被捕获或声明的“未报告的例外（异常）”（The compiler says there's an &quot;unreported exception&quot; that must be caught or declared）。</p>
<h3 id="在打算调用的方法在某个不是由自己本人编写的类中存在风险时会发生什么呢"><a class="header" href="#在打算调用的方法在某个不是由自己本人编写的类中存在风险时会发生什么呢">在打算调用的方法（在某个不是由自己本人编写的类中）存在风险时，会发生什么呢？</a></h3>
<p><img src="images/Ch11_03.png" alt="异常处理原理" /></p>
<p><em>图 3 - 异常处理原理</em></p>
<h3 id="java中的方法使用异常来告诉调用代码不好的事情发生了运行失败"><a class="header" href="#java中的方法使用异常来告诉调用代码不好的事情发生了运行失败">Java中的方法使用异常来告诉调用代码，“不好的事情发生了。运行失败”</a></h3>
<p><strong>Methods in Java use <em>exceptions</em> to tell the calling code, &quot;Something Bad Happened. I failed&quot;</strong></p>
<p>Java的异常处理机制，作为处理运行时发生的“例外情形”方式，具有干净明亮的特点；可允许把全部的错误处理代码，放在易于阅读的位置。这种机制是基于代码编写者对调用到的方法具有风险性的了解（即调用的方法 <em>可能</em> 产生一个异常），因此就可以编写应对那种可能性的代码。在已经知道调用某个特定方法时可能得到异常时，就可以对导致异常的故障有所准备 -- 或许还可以从异常中恢复过来。</p>
<p>那么，又怎样才能获悉某个方法是否会抛出异常呢？可以在具风险性的方法中，发现某个 <code>throws</code> 的线索。</p>
<p><strong>方法 <code>getSequencer()</code> 带有风险。可能在运行时失败。因此他就必须 “声明” 在调用他时所有承担的风险</strong>。</p>
<p><img src="images/Ch11_04.png" alt="Java语言中方法抛出异常的约定示例" /></p>
<p><em>图 4 - Java语言中方法抛出异常的约定示例</em></p>
<h3 id="编译器也需要明确代码编写者是否知悉所调用的方法具有风险性"><a class="header" href="#编译器也需要明确代码编写者是否知悉所调用的方法具有风险性">编译器也需要明确代码编写者是否知悉所调用的方法具有风险性</a></h3>
<p><strong>The compiler needs to know that YOU know you're calling a risky method</strong>.</p>
<p>如果能够把风险代码使用 <code>try/catch</code> 包装起来，那么编译器就会轻松很多。</p>
<p>代码编写者运用<code>try/catch</code>代码块，就可以就告诉编译器，自己知道在所调用的方法中，可能会发生某种异常情况，同时准备好处理这种异常了。编译器不会关心怎样处理的异常；他只会关心代码编写者已经注意到有异常。</p>
<blockquote>
<p>亲爱的编译器：
我了解这里会有风险，你认为这样做值得吗？我应该怎么做呢？
Waikiki的 geeky</p>
<p>亲爱的geeky:
生命苦短（尤其是在内存堆上）。就承担那个风险吧。尝试（<code>try</code>）一下。只要在事情不妙的时候，在事情失控之前，可以捕获（<code>catch</code>）到所有问题就好。</p>
</blockquote>
<pre><code class="language-java">package com.xfoss.BeatBox;

import javax.sound.midi.*;

public class MusicTest1 {
    public void play () {
        try {
            // 把有风险的东西放在一个 'try' 的代码块中
            Sequencer seq = MidiSystem.getSequencer();
            System.out.println(&quot;我们就得到了一个‘音序器（Sequencer）’&quot;);
        } catch (MidiUnavailableException e) {
            // 构造一个用于在异常情形发生时 -- 也就是调用 getSequencer() 时
            // 抛出了 MidiUnavailableException 时，要做什么的 ‘catch’ 代码块 
            System.out.println(&quot;Bummer&quot;);
        }
    }

    public static void main(String [] args) {
        MusicTest1 mt = new MusicTest1 ();
        mt.play();
    }
}
</code></pre>
<blockquote>
<p>这里就要 <strong>尝试（TRY）</strong> 一下这个冒险的事，并且就要在失败时 <strong>捕获（CATCH）</strong> 自己了。</p>
</blockquote>
<h3 id="异常就是一个类型为-exception-的对象"><a class="header" href="#异常就是一个类型为-exception-的对象">异常就是一个......类型为 <code>Exception</code> 的对象</a></h3>
<p>这可是一件好事，因为比如如果异常为类型<code>Broccoli</code>类型时，要记住他的类型就很难了。</p>
<p><img src="images/Ch11_05.png" alt="类 Exception 本质" /></p>
<p><em>图 5 - 类 <code>Exception</code> 本质</em></p>
<p>回顾讲多态的那些章就知道，类型为 <code>Exception</code> 的某个对象，可以是类 <code>Exception</code> 任何子类的实例。</p>
<p>由于把 <em>异常</em> 当作了一个普通对象，那么 <em>捕获</em> 到的就是个对象了。接下来的代码中，<code>catch</code> 的参数就被声明为了类型 <code>Exception</code>，同时参数引用变量为 <code>ex</code>。</p>
<pre><code class="language-java">try {
    // 这里完成一些有风险的事情
} catch (Exception ex) { // 这就跟声明某个普通方法的参数是一样的
    // 尝试从异常中恢复过来
    // 这里的代码只会在抛出了某个异常时才运行。
}
</code></pre>
<p>在 <code>catch</code> 代码块中编写什么，取决于抛出什么样的异常。比如在某台服务器宕机时，可能就会使用这个<code>catch</code>代码块来对另一台服务器进行尝试。在需要的文件不存在时，可能会请求用户帮助找到那个文件。</p>
<h3 id="既然是自己编写的代码-捕获-了异常那么又是谁的代码-抛出-的异常呢"><a class="header" href="#既然是自己编写的代码-捕获-了异常那么又是谁的代码-抛出-的异常呢">既然是自己编写的代码 <strong>捕获</strong> 了异常，那么又是谁的代码 <strong>抛出</strong> 的异常呢？</a></h3>
<p>在以后的代码编写生涯中，花在异常 <em>处理</em> 上的时间，要比花在 <em>创建</em> 与 <em>抛出</em> 他们的时间，会多得多。现在只要知道在代码 <em>调用</em> 风险方法 -- 某个声明了异常的方法时 -- 是那个风险方法 <em>抛出</em> 异常给作为调用者的你。</p>
<p>在实际项目中，抛出异常的类和处理异常的类，都会由自己去编写。事实上到底谁去编写这些代码真的不重要......重要的是明白到底是那个方法 <em>抛出</em> 的异常，以及那个方法去 <em>捕获</em> 异常。</p>
<p><img src="images/Ch11_06.png" alt="调用风险方法及异常的抛出" /></p>
<p><em>图 6 - 调用风险方法及异常的抛出</em></p>
<p>在编写的代码会抛出异常时，就必须 <em>声明</em> 那个异常。</p>
<ol>
<li>
<p><strong>具风险性的方法的异常抛出代码</strong>：</p>
<pre><code class="language-java">// 该方法 必须 告诉（通过声明）外部世界，他抛出了一个 BadException
public void takeRisk () throws BadException {
    if (abandonAllHope) {
        // 创建一个新的 Exception 对象并将其抛出
        throw new BadException();
    }
}
</code></pre>
</li>
<li>
<p><strong>调用这个风险方法的代码</strong>：</p>
<pre><code class="language-java">public void crossFingers () {
    try {
        anObject.takeRisk();
    } catch (BadException ex) {
        System.out.println(&quot;Aaargh!&quot;);
        // 即使不能从异常中恢复过来，至少也可以使用所有例外都会
        // 继承的 printStackTrace() 方法
        // 获取到一个栈轨迹（a stack trace）信息。
        ex.printStackTrace();
    }
}
</code></pre>
</li>
</ol>
<blockquote>
<p>一个方法讲捕获到另一个方法所抛出的东西。例外总是被抛回给调用者。
抛出异常的方法，必须声明他可能会抛出的异常。</p>
</blockquote>
<h3 id="编译器会检查所有东西除了运行时异常-runtimeexceptions"><a class="header" href="#编译器会检查所有东西除了运行时异常-runtimeexceptions">编译器会检查所有东西，除了运行时异常（ <code>RuntimeException</code>s）</a></h3>
<p><strong>编译器要确保</strong>：</p>
<ol>
<li>
<p>在代码中抛出了某个异常时，就必须在方法声明中，使用关键字 <code>throws</code> 对其进行声明。</p>
</li>
<li>
<p>在调用到某个抛出了异常的方法时（也就是说，该方法声明了他会抛出异常），就必须就已经注意到可能的异常进行 <em>通告（acknowledge）</em>。让编译器得以放行的一种方式，就是把调用包装在一个 <code>try/catch</code> 中。（本章后面就会讲到第二种方法）</p>
</li>
</ol>
<p><img src="images/Ch11_07.png" alt="运行时异常与非运行时异常" /></p>
<p><em>图 7 - 运行时异常与非运行时异常</em></p>
<h2 id="答疑-9"><a class="header" href="#答疑-9">答疑</a></h2>
<ul>
<li><strong>请等一下！怎么就说这是我们第一次不得不对异常进行 <code>try/catch</code> 操作呢？之前不是已经见到过 <code>NullPointerException</code> 和 <code>DivideByZero</code> 这样的异常了吗？在 <code>Integer.parseInt()</code> 那里就已经得到过 <code>NumberFormatException</code>。对这些异常，怎么就不是必须捕获呢</strong>？</li>
</ul>
<blockquote>
<p>编译器会关注所有 <code>Exception</code> 子类，但会把特殊类型 <code>RuntimeException</code> 排除在外。对<code>RuntimeException</code>进行扩展的所有异常类，都可以通过编译器检查。运行时异常可在任何地方抛出，带或不带<code>throws</code>声明，有或没有 <code>try/catch</code> 代码块都无关紧要。编译器不会把精力放在，对某个方法声明他抛出了一个 <code>RuntimeException</code> ，或者调用者知晓可能在运行时收到异常的检查上。</p>
</blockquote>
<ul>
<li><strong>你这个含糊其辞的回答，让我更加迷糊了。到底为何编译器不会关注这些运行时异常呢？难道这些运行时异常不会让程序进入停止运行状态吗</strong>？</li>
</ul>
<blockquote>
<p>绝大多数运行时异常，都是由代码逻辑引起，而非那种在运行时编程者无法预测或防止的失效情形造成。编程者无法保证需要的文件就在那里，无法确保服务器是开机的。但却可以确保代码在对某个数组进行索引时，不会超出那个数组的边界（这正是 <code>.length</code> 属性的职责所在）。</p>
<p>在开发和测试阶段，确实允许运行时异常的存在。但肯定不希望在 <code>try/catch</code> 代码块中编写代码，比如这样就会带来额外开销，去捕获那些压根儿就不应该出现的异常。</p>
<p><code>try/catch</code> 是用来应对异常情况，而不是代码中的缺陷。在真的无法确保可以调用成功时，才去使用 <code>catch</code> 代码块，让程序从异常中恢复过来。或者至少可以打印出一条消息与栈踪迹的调试信息给用户，这样用户还可以找出到底发生了什么问题。</p>
</blockquote>
<h2 id="重点-1"><a class="header" href="#重点-1">重点</a></h2>
<ul>
<li>方法在运行时出现某些东西失效的情况下，可以抛出一个异常。</li>
<li>某个异常总是一个<code>Exception</code>类类型的对象。（也就是如同那些多态章中所讲的那样，所有异常都是源自某个可以在其继承树往上找到 <code>Exception</code> 类的子类，An exception is always an object of type Exception.(Which, as you remember from the polymorphism chapters means the object is from a class that has <code>Exception</code> somewhere up its inheritance tree)）。</li>
<li>编译器不会留意那些类型为 <code>RuntimeException</code> 的异常。不必对 <code>RuntimeException</code>进行声明，或将其包装在 <code>try/catch</code> 代码块中（不过这样做也是可以的，声明和/或放在 <code>try/catch</code> 代码块中都行）。</li>
<li>所有编译器关心的异常，叫做“受检查异常”，指的就是“编译器要检查的异常”。只有那些运行时异常会排除在编译器检查之外。依照此规则，那么除运行时异常外，其他所有异常都必须在代码中加以通告。</li>
<li>方法使用关键字 <code>throw</code>，并在其后带上一个新构造的异常对象，来抛出某个异常：</li>
</ul>
<pre><code class="language-java">throw new NoCaffeinException ();
</code></pre>
<ul>
<li>抛出了受检查异常的方法，<em><strong>必须</strong></em> 使用一条 <code>throws Exception</code> 声明进行宣告。</li>
<li>在代码调用了某个 “抛出受检查异常” 方法（a checking-exception-throwing method）时，就让编译器放心，已经对异常有所准备，并采取了预防措施。</li>
<li>在已准备好处理异常（受检查异常）时，就要把抛出异常的方法调用，放在 <code>try/catch</code> 代码块中，并把异常处理/恢复代码，放在 <code>catch</code> 代码块中。</li>
<li>在尚未准备好处理异常时，仍然可以通过正式 “躲开” 异常，来让编译器满意。在本章稍后，将对这种躲开异常进行说明。</li>
</ul>
<blockquote>
<p><strong>元认知技巧</strong></p>
<p>在要掌握某种新东西时，可以把学习新内容安排在睡前。那么一旦放下了这本书（假设可以离这本书远远的），就不要再干别的事了。大脑需要时间去处理阅读和学习的内容。或许这个过程需要数小时。如果再学习Java之余，还要做其他的事情，那么之前学到的Java技能，就不会那么牢固。</p>
<p>不过这对于掌握某项体育技能并没有效果。比如练习跆拳道就不会影响 Java 的学习。</p>
<p>要求得最好效果，最好是在睡觉前看这本书。</p>
</blockquote>
<h2 id="trycatch-代码块中的流程控制"><a class="header" href="#trycatch-代码块中的流程控制"><code>try/catch</code> 代码块中的流程控制</a></h2>
<p><strong>Flow control in <code>try/catch</code> blocks</strong></p>
<p>在对具风险的方法进行调用事，可能发生两种情况。风险方法要么成功，这时<code>try</code>代码块就会跑完，要么风险方法抛回一个异常给调用方法。</p>
<p><img src="images/Ch11_08.png" alt="try/catch 代码块中的流控：无异常抛出时" /></p>
<p><em>图 8 - <code>try/catch</code> 代码块中的流程控制：无异常抛出时</em></p>
<p><img src="images/Ch11_09.png" alt="try/catch 代码块中的流程控制：抛出异常时" /></p>
<p><em>图 9 - <code>try/catch</code> 代码块中的流程控制：抛出异常时</em></p>
<h2 id="finally不论何种情形都要执行的操作"><a class="header" href="#finally不论何种情形都要执行的操作"><code>finally</code>：不论何种情形，都要执行的操作</a></h2>
<p><strong>Finally: for the things you want to do no matter what</strong>.</p>
<p>在尝试煮饭时，总是要打开炉子的。</p>
<p>即使煮饭 <strong>失败</strong>，也总是要关上炉子的。</p>
<p>即便煮饭 <strong>成功</strong>，还是必须关上炉子。</p>
<p><em><strong>不论发生什么，都是要关上炉子</strong></em>!</p>
<p><strong><code>finally</code> 代码块就是放置那些与异常无关，必须要执行的代码的地方（A <code>finally</code> block is where you put code that must run regardless of an exception）</strong>。</p>
<pre><code class="language-java">try {
    turnOvenOn ();
    x.bake();
} catch (BakingException ex) {
    ex.printStackTrace();
} finally {
    turnOvenOff();
}
</code></pre>
<p>若没有这么一个 <code>finally</code> 关键字，就必须把 <code>turnOvenOff()</code> 方法同时放在 <code>try</code> 和 <code>catch</code> 代码块中，就是因为 <em><strong>不论何种情况，都必须关掉炉子</strong></em>。而有了这样一个 <code>finally</code> 的代码块，就可以把所以清理代码放在一处，而不是像下面这样重复：</p>
<pre><code class="language-java">try {
    turnOvenOn();
    x.bake();
    turnOvenOff();
} catch (BakingException ex) {
    ex.printStackTrace();
    turnOvenOff();
}
</code></pre>
<ul>
<li><strong>在 <code>try</code> 代码块失败（某个异常）时</strong>，程序流程控制会立即移动至 <code>catch</code> 代码块。随着 <code>catch</code> 代码块执行完毕，<code>finally</code> 代码块就会运行。在 <code>finally</code> 代码块执行完毕后，会继续运行调用方法中的其余代码；</li>
<li><strong>在 <code>try</code> 代码块成功（无异常）时</strong>，程序流程控制会跳过 <code>catch</code> 代码块并移动至 <code>finally</code> 代码块。在 <code>finally</code> 代码块执行完毕后，就继续运行调用方法的其余代码；</li>
<li><strong>即使 <code>try</code> 或 <code>catch</code> 代码块带有 <code>return</code> 语句，这里的 <code>finally</code> 代码块仍会运行</strong>！程序流程会跳往 <code>finally</code> 代码块，然后在跳回到 <code>return</code> 语句。</li>
</ul>
<pre><code class="language-java">package com.xfoss.learningJava;

class ScaryException extends Exception {};

public class TestExceptions {
    public static void main (String [] args) {
        String test = &quot;yes&quot;;

        try {
            System.out.println(&quot;开始尝试&quot;);
            doRisky(test);
            System.out.println(&quot;尝试结束&quot;);
        } catch (ScaryException ex) {
            System.out.println(&quot;可怕的异常&quot;);
            ex.printStackTrace();
        } finally {
            System.out.println(&quot;`finally` 代码块&quot;);
        }

        System.out.println(&quot;main方法的结束&quot;);
    }

    static void doRisky (String test) throws ScaryException {
        System.out.println(&quot;开始冒险&quot;);

        if (&quot;yes&quot;.equals(test)) {
            throw new ScaryException ();
        }

        System.out.println(&quot;冒险结束&quot;);
        return;
    }
}
</code></pre>
<p>上面的代码输出为：</p>
<pre><code class="language-console">开始尝试
开始冒险
可怕的异常
com.xfoss.learningJava.ScaryException
        at com.xfoss.learningJava.TestExceptions.doRisky(TestExceptions.java:27)
        at com.xfoss.learningJava.TestExceptions.main(TestExceptions.java:11)
`finally` 代码块
main方法的结束
</code></pre>
<p>在 <code>String test = &quot;no&quot;</code> 时，其输出为：</p>
<pre><code class="language-console">开始尝试
开始冒险
冒险结束
尝试结束
`finally` 代码块
main方法的结束
</code></pre>
<h2 id="多态的异常"><a class="header" href="#多态的异常">多态的异常</a></h2>
<p><strong>Exceptions are polymorphic</strong></p>
<p>记住，异常都是些对象。与其他对象相比，异常没有什么特别之处，除了可被 <em><strong>抛出</strong></em> 之外。那么与其他良好的对象一样，异常也可被多态地予以引用。比如对于某个 <code>LingerieException</code> 类型的对象，就可以赋值给某个 <code>ClothingException</code> 的引用变量。而一个 <code>PantsException</code>，也可以赋值给某个 <code>Exception</code> 类类型的引用变量。明白了吗？异常的多态特性，所带来的好处就是，方法不必显式地声明其可能抛出的所以可能的异常（The benefit for exceptions is that a method doesn't have to explicitly declare every possible exception it might throw）；他只需要声明这些可能异常的超类即可。对于 <code>catch</code> 代码块同样如此 -- 只要<code>catch</code>代码块能够处理全部抛出的异常，就不必编写针对各种可能异常的 <code>catch</code> 代码块（或多个代码块）。</p>
<p><img src="images/Ch11_10.png" alt="Exception 继承树" /></p>
<p><em>图 10 - <code>Exception</code> 继承树</em></p>
<ol>
<li>
<p><strong>可使用那些抛出异常的超类，来进行异常的声明</strong>。</p>
<pre><code class="language-java">public void doLaundry () throws ClothingException {
                                // 由于这里声明的是 ClothingException
                                // 那么就可以抛出 ClothingException 的任意子类类型的异常对象
                                // 就是说 doLaundry() 方法可抛出 PantsException、LingerieException
                                // TeeShirtException 以及 DressShirtException，而无需显示地
                                // 分别进行声明
</code></pre>
</li>
<li>
<p><strong>使用所抛出异常的超类，就可以 捕获 这些异常</strong>。</p>
<pre><code class="language-java">try {
    laundry.doLaundry();
} catch (ClothingException cex) { // 这就可以捕获到任意 ClothingException 的子类了
    // 恢复代码
}
</code></pre>
<pre><code class="language-java">try {
    laundry.doLaundry();
} catch (ShirtException sex) { // 这就只能捕获 TeeShirtException 与 DressShirtException
    // 恢复代码
}
</code></pre>
</li>
</ol>
<h3 id="虽然可以使用一个大的超级多态捕获来捕获全部异常但不表示应该这样做"><a class="header" href="#虽然可以使用一个大的超级多态捕获来捕获全部异常但不表示应该这样做">虽然可以使用一个大的超级多态捕获来捕获全部异常，但不表示应该这样做。</a></h3>
<p><strong>Just because you CAN catch everything with one big super polymorphic catch, doesn't always mean you SHOULD</strong>.</p>
<p>在编写异常处理代码时，可以在 <code>catch</code> 子语句处使用超级类型 <code>Exception</code>，从而仅用一个的 <code>catch</code> 代码块，就可以捕获到可能抛出的所有例外。</p>
<pre><code class="language-java">try {
    laundry.doLaundry ();
} catch (Exception ex) {
    // 恢复代码......
    // 问题是，要从哪里恢复呢？这个 catch 代码块将捕获
    // 所有全部的异常，那么就没法知道到底什么地方出错了。
}
</code></pre>
<h3 id="为需要专门处理的每个异常都编写不同的-catch-代码块"><a class="header" href="#为需要专门处理的每个异常都编写不同的-catch-代码块">为需要专门处理的每个异常，都编写不同的 <code>catch</code> 代码块。</a></h3>
<p><strong>Write a different catch block for each exception that you need to handle uniquely</strong>.</p>
<p>比如在代码处理 <code>TeeShirtException</code>不同于处理 <code>LingrieException</code>时，就要为他们分别编写 <code>catch</code> 代码块。而假如可以同样方式对待<code>ClothingException</code>的其他子类型，那么就可以加入一个 <code>ClothingException</code>的 <code>catch</code> 代码块，来处理其余的异常。</p>
<pre><code class="language-java">try {
    laundry.doLaundry();
} catch (TeeShirtException tex) {
    // 从 TeeShirtException 中恢复过来
} catch (LingrieException lex) {    // TeeShirtException 与 LingrieException 都需要
                                    // 不同的恢复代码，因此就要使用不同的捕获代码块
    // 从 LingrieException 中恢复过来
} catch (ClothingException cex) { // 在这里捕获索取其他的 ClothingException 异常
    // 从所有其他异常中恢复过来
}
</code></pre>
<h3 id="有多个-catch-代码块时必须以从小到大的顺序排序"><a class="header" href="#有多个-catch-代码块时必须以从小到大的顺序排序">有多个 <code>catch</code> 代码块时，必须以从小到大的顺序排序</a></h3>
<p><strong>Multiple catch blocks must be ordered from smallest to biggest</strong></p>
<p><img src="images/Ch11_11.png" alt="多个catch代码块的排序" /></p>
<p><em>图 11 - 多个<code>catch</code>代码块的排序</em></p>
<p>在<code>Exception</code>继承树越往上的类，他的捕获“筐子”就会越大。而沿继承树往下，到越来越精细的 <code>Exception</code> 类的时候，捕获“筐子”就会越来越小。这与先前的多态机制别无二致。</p>
<p><code>ShirtException</code>捕获对于接收 <code>TeeShirtException</code>或<code>DressShirtException</code>（以及将来的全部对<code>ShirtException</code>进行扩展的子类），是足够大的。而<code>ClothingException</code>则要更大（即使用类型<code>ClothingException</code>可对更多的东西进行引用）。除了接收<code>ClothingException</code>的异常之外，他还可以接收全部<code>ClothingException</code>的那些子类：<code>PantsException</code>、<code>UniformException</code>、<code>LingrieException</code>及<code>ShirtException</code>等等。随意 <code>catch</code> 捕获参数的始祖，就是 <strong><code>Exception</code></strong>；他会捕获所有异常，包括运行时（不受检查）异常，因此除了测试目的之外，多半是用不到这个最大的 <code>Exception</code>类类型的。</p>
<h3 id="不能把较大的筐子放在比他们小的筐子之上"><a class="header" href="#不能把较大的筐子放在比他们小的筐子之上">不能把较大的“筐子”放在比他们小的“筐子”之上</a></h3>
<p><strong>You can't put bigger baskets above smaller baskets</strong></p>
<p>当然可以这样做，只是这样做编译不了的。这些捕获块与挑选最匹配的过载方法不一样。对于多个的 <code>catch</code> 代码块，JVM只是简单地从第一个捕获块开始，一直往下运作，直到发现一个可以处理异常的、足够宽泛的（也就是在继承树上足够高）捕获为止。若第一个<code>catch</code>代码块的就是 <code>catch (Exception ex)</code>，那么编译器就已经知道，没有地方再添加其他捕获参数了 -- 所以永远不会走到后面的捕获代码块。</p>
<p><img src="images/Ch11_12.png" alt="不良的catch代码块顺序" /></p>
<p><em>图 12 - 不良的<code>catch</code>代码块顺序</em></p>
<blockquote>
<p>在有着多个 <code>catch</code> 代码块时，捕获参数的大写至关重要（Size matters when you have multiple catch blocks）。有着最大“筐子”的捕获参数，就必须放在底部。否则那些较小的“筐子”就变得无用了。</p>
<p><em><strong>（继承树上）同辈份异常类的顺序没什么讲究，因为他们不会捕获到归属对方的异常</strong></em>。</p>
<p>没人会介意把 <code>ShirtException</code> 放在 <code>LingrieException</code> 之上。因为尽管由于 <code>ShirtException</code> 可以捕获到其他一些类（他自己的那些子类）， 而相比于 <code>LingrieException</code> 是个更大（更宽泛）的类型，但 <code>ShirtException</code> 是捕获不到 <code>LingrieException</code> 的，因此就不存在问题。</p>
</blockquote>
<h2 id="在不打算处理异常时只需躲开即可"><a class="header" href="#在不打算处理异常时只需躲开即可">在不打算处理异常时，只需躲开即可</a></h2>
<p><strong>When you don't want to handle an exception... just duck it</strong></p>
<p><strong>在不打算对某个异常进行处理时，可通过 <em>声明</em> 这个异常，来 <em>躲开</em> 该异常</strong>。</p>
<p><strong>If you don't want ot handle an exception, you can <em>duck</em> it by <em>declaring</em> it</strong>.</p>
<blockquote>
<p>这是什么鬼？我可不会捕获这个鬼东西。我要闪人了 -- 就让后来者去处理吧。</p>
</blockquote>
<p>在对某个风险方法进行调用时，编译器需要明确调用者对此有所知悉。多数情况下，是通过把风险调用包装在 <code>try/catch</code> 中告知编译器的。但也有别的方式，那就是 <em>避开</em> 异常，而让那些对这个调用方法进行调用的方法去捕获该异常。</p>
<p>很简单 -- 只需要 <em>声明</em> 一下调用方法抛出异常即可。虽然在调用方法中声明了抛出异常，但抛出异常的却不是调用方法，这一点无关紧要。调用方法仍然是让异常直接通过的方法（It's easy -- all you have to do is <em>declare</em> that <em>you</em> throw the exceptions. Even though, technically, <em>you</em> aren't the one doing the throwing, it doesn't matter. You're still the one letting the exception whiz right on by）。</p>
<p>然而在避开异常时，就不会有 <code>try/catch</code> 语句了，那么在风险方法（<code>doLaunch()</code>）真的抛出了异常时，会怎么样呢？</p>
<p>在某个方法抛出异常时，则这个抛出异常的方法，就会立即被从栈上弹出，而异常就会被抛给栈上往下的第一个方法 -- 也就是那个 <em>调用者方法</em> （When a method throws an exception, that method is popped off the stack immediately， and the exception is thrown to the next method down the stack -- the <em>caller</em>）。但在调用者方法是个 <em>逃避者</em> 时，就没有这个异常的捕获了，因此调用者方法就立即从栈上弹出，而这个异常就被抛给栈上的下一个方法，如此这般......那么到哪里结束呢？后面就会看到。</p>
<pre><code class="language-java">// foo()这个调用者方法，并没有真的抛出这个异常，而因为
// 没有针对他调用的这个风险方法的 try/catch，所以 foo()
// 就成了“风险方法”。这是因为现在不过哪个方法要调用 foo()
// 都必须要对此异常进行处理。
public void foo() throws ReallyBadException {
    // 不带 try/catch 地调用某个风险方法
    laundry.doLaundry();
}
</code></pre>
<h3 id="通过声明异常的规避只是延后了必然"><a class="header" href="#通过声明异常的规避只是延后了必然">通过声明异常的规避，只是延后了必然</a></h3>
<p><strong>Ducking (by declaring) only delays the inevitable</strong></p>
<p><strong>迟早都要有人来处理异常。但要是 <code>main()</code> 方法规避了异常呢</strong>？</p>
<pre><code class="language-java">public class Washer {
    Laundry laundry = new Laundry();

    // 这里的 foo() 和 main() 两个方法都规避了那个异常
    // （通过声明他），那么就没有人去处理这个异常了！
    // 这对于编译来说毫无违和感。
    public void foo() throws ClothingException {
        laundry.doLaundry();
    }

    public static void main (String [] args) throws ClothingException {
        Washer a = new Washer ();
        a.foo();
    }
}
</code></pre>
<p><img src="images/Ch11_13.png" alt="main()方法抛出异常的特别情形" /></p>
<p><em>图 13 - <code>main()</code>方法抛出异常的特别情形</em></p>
<h3 id="要么处理要么声明这是铁律"><a class="header" href="#要么处理要么声明这是铁律">要么处理，要么声明。这是铁律。</a></h3>
<p><strong>Handle or Declare. It's the law</strong>.</p>
<p><strong>到这里，就见识过了在调用某个风险（有异常抛出）的方法时，满足编译器检查的两个方式</strong>。</p>
<ol>
<li>
<p><strong>对异常进行处理（HANDLE）</strong></p>
<p>将有风险的调用，放在某个 <code>try/catch</code> 中</p>
<pre><code class="language-java">try {
    laundry.doLaundry();
} catch (ClothingException cex) {
    // 这里的捕获参数，最好是一个可以捕获到 doLaundry() 所
    // 抛出的全部异常、足够大的异常类类型。不然编译器仍然
    // 会抱怨没有对所有异常进行捕获。
    // 
    // 恢复代码
}
</code></pre>
</li>
<li>
<p><strong>声明异常（规避异常, DECLARE(duck it)）</strong></p>
<p>声明调用方法会抛出与所调用的风险方法同样的异常（Declare the YOUR method throws the same exceptions as the risky method you're calling）。</p>
<pre><code class="language-java">// doLaundry()方法抛出了一个 ClothingException 类类型的异常
// 而作为其调用者的 foo() 方法，只需要通过声明该异常，就可以
// 避开这个异常。无需 try/catch
void foo() throws ClothingException {
    laundry.doLaundry();
}
</code></pre>
<p>不过现在就意味着那些 <code>foo()</code> 方法的调用者就必须要遵守这条 “处理抑或声明” 的法则了。在 <code>foo()</code> 方法规避了这个例外（通过对其进行声明），同时 <code>main()</code> 调用了 <code>foo()</code> 时，那么 <code>main()</code> 就必须对该例外进行处理。</p>
<pre><code class="language-java">public class Washer {
    Laundry laundry = new Laundry();

    public void foo () throws ClothingException {
        laundry.doLaundry();
    }

    public static void main (String [] args) {
        // 麻烦了！现在 main() 就不会编译了，同时
        // 会收到一个 “unreported exception” 的报错。
        // 编译器所关心的是，foo() 方法抛出了一个异常
        Washer a = new Washer ();
        // 因为 foo() 方法规避了由 doLaundry() 所抛出
        // 的 ClothingException 类类型的异常，那么
        // main() 就必须把 a.foo() 包装在一个 try/catch
        // 中，或必须也要对异常进行声明，throws ClothingException !
        a.foo();
    }
}
</code></pre>
</li>
</ol>
<h2 id="回到前面的-beatbox-app-的代码"><a class="header" href="#回到前面的-beatbox-app-的代码">回到前面的 <code>BeatBox</code> app 的代码</a></h2>
<p>现在是不是完全忘掉了，这一章开始的时候，初步涉及了一些 <code>JavaSound</code> 的代码。在那里已经创建了一个 <code>Sequencer</code> 的对象，而由于<code>Midi.getSequencer()</code>方法声明了一个受检查的异常（a checked exception, <code>MidiUnavailableException</code>），导致那段代码无法编译。现在就可以通过把对该方法的调用，包装在一个 <code>try/catch</code> 中，修复这个问题了。</p>
<pre><code class="language-java">package com.xfoss.BeatBox;

import javax.sound.midi.*;

public class MusicTest1 {
    public void play () {
        try {
            // 因为把对风险方法 MidiSystem.getSequencer() 包装
            // 在了 try/catch 代码块中，现在对该方法的调用就没有问题了
            Sequencer seq = MidiSystem.getSequencer();
            System.out.println(&quot;我们就得到了一个‘音序器（Sequencer）’&quot;);
        } catch (MidiUnavailableException ex) {
            // 这里的捕获参数必须是 “恰当” 的异常。若这里写
            // catch(FileNetFoundException f)，那么这段代码也不会编译
            // 因为从多态上讲，一个 MidiUnavailableException 并不适合
            // FileNotFoundException
            //
            // 请记住光是有 catch 代码块还不够，还必须捕获到抛出的异常！
            System.out.println(&quot;Bummer&quot;);
        }
    }

    public static void main(String [] args) {
        MusicTest1 mt = new MusicTest1 ();
        mt.play();
    }
}
</code></pre>
<h3 id="异常处理的四条规则"><a class="header" href="#异常处理的四条规则">异常处理的四条规则</a></h3>
<ol>
<li>
<p><strong>不能在没有 <code>try</code> 的情况下使用 <code>catch</code> 或 <code>finally</code>关键字</strong></p>
<p><strong>You cannot have a <code>catch</code> or <code>finally</code> without a <code>try</code></strong></p>
<pre><code class="language-java">void go () {
    Foo f = new Foo ();

    f.foo();

    // 非法！`try` 在哪里？
    catch (FooException ex) {}
}
</code></pre>
</li>
<li>
<p><strong>在 <code>try</code> 与 <code>catch</code> 直接不能再放置代码</strong></p>
<p><strong>You cannot put code between the <code>try</code> and the <code>catch</code></strong></p>
<pre><code class="language-java">try {
    x.doStuff();
}
// 非法！不能在 `try` 与 `catch` 之间放置代码
int y = 43;
catch (Exception ex) {}
</code></pre>
</li>
<li>
<p><strong><code>try</code>后面只能/且必须有 <code>catch</code> 或/及 <code>finally</code></strong></p>
<p><strong>A <code>try</code> MUST be followed by either a <code>catch</code> or a <code>finally</code></strong></p>
<pre><code class="language-java">try {
    x.doStuff();
} finally {
    // 合法。因为这里尽管没有 `catch`，但却有个 `finally`。
    // 但不能只有 `try` 一个
    // 
    // 清理工作
}
</code></pre>
</li>
<li>
<p><strong>在<code>try</code>后只有<code>finally</code>（不带<code>catch</code>）时，仍然必须对异常进行声明</strong>。</p>
<p><strong>A <code>try</code> with only a <code>finally</code>(no <code>catch</code>) must still declare the exception</strong>.</p>
<pre><code class="language-java">// 不带 `catch` 的 `try`，不满足 `handle/declare` 法则
void go() throws FooException {
    try {
        x.doStuff();
    } finally {}
}
</code></pre>
</li>
</ol>
<h2 id="代码厨房"><a class="header" href="#代码厨房">代码厨房</a></h2>
<blockquote>
<p>虽然后面的代码不需要自己去编写（可以在后面找到已经编写好的），然如果能够自己动手编写，就会有很多乐趣。</p>
<p>本章接下来的部分是可选的；可使用这个 音乐app 的全部已编写好的代码；</p>
<p>但如果要了解有关 <code>JavaSound</code> 声音子系统的更多细节，那么就应该继续看下去。</p>
</blockquote>
<h3 id="构造真实的声音"><a class="header" href="#构造真实的声音">构造真实的声音</a></h3>
<p><strong>Making actual sound</strong></p>
<p>还记得在本章开头的地方，我们在那里对 MIDI 数据如何保存那些，描述应该演奏些什么（以及该怎样演奏）的指令进行了审视，同时还提及了 MIDI 数据并没有真实地 <em>创建出我们所听到的任何声音</em>。要让声音从喇叭中发出来，就必须通过启动某种实体MIDI乐器，抑或“虚拟”乐器（软件合成器），把 MIDI数据交给一些接受 MIDI 指令，并将这些 MIDI 指令渲染出来的 MIDI 设备。这里只会用到软件装置，而下面就是 <code>JavaSound</code> 声音子系统中的运作方式：</p>
<p><strong>需要 <em>四个</em> 东西</strong>：</p>
<p><img src="images/Ch11_14.png" alt="JavaSound中演奏出声音的四个要件" /></p>
<p><em>图 14 - <code>JavaSound</code>中演奏出声音的四个要件</em></p>
<p><strong>同时需要五个步骤</strong>：</p>
<ol>
<li>
<p>获取到一个 <strong><code>Sequencer</code></strong> 对象并打开他</p>
<pre><code class="language-java">Sequencer player = MidiSystem.getSequencer();
player.open();
</code></pre>
</li>
<li>
<p>构造一个新的 <strong>序列（Sequence）</strong></p>
<pre><code class="language-java">Sequence seq = new Sequence(timing, 4);
</code></pre>
</li>
<li>
<p>从新构造的 <code>Sequence</code> 获取到一个新的 <strong>音轨（Track）</strong></p>
<pre><code class="language-java">Track t = seq.createTrack();
</code></pre>
</li>
<li>
<p>使用一系列的 **<code>MidiEvent</code>**s 来对音轨进行填充，然后把这个<code>Sequence</code>对象交给音序器</p>
<pre><code class="language-java">t.add(myMidiEvent);
player.setSetquence(seq);
</code></pre>
</li>
<li>
<p>按下播放按钮（ ▶  ）。必须要启动 <code>start()</code> 这个音序器才行</p>
<pre><code class="language-java">player.start();
</code></pre>
</li>
</ol>
<h3 id="一个非常早期的声音播放器-app"><a class="header" href="#一个非常早期的声音播放器-app">一个非常早期的声音播放器 app</a></h3>
<p><strong>Your very first sound player app</strong></p>
<p>编写下面的代码并运行。就会听到有人在演奏钢琴上的一个音符！（好吧，可能不是某 <em>人</em>，而是某 <em>物</em> 在演奏。）</p>
<pre><code class="language-java">package com.xfoss.BeatBox;

// 不要忘记导入 midi 包
import javax.sound.midi.*;

public class MiniMiniMusicApp {
    public static void main (String [] args){
        MiniMiniMusicApp mini = new MiniMiniMusicApp();
        mini.play();
    }

    public void play () {
        try {
            // 获取一个音序器 Sequencer 并把他打开（这样就可以对其进行使用......
            // 音序器不会一来就是打开的）
            Sequencer player = MidiSystem.getSequencer();
            player.open();

            // 不要急于了解这些音序 Sequence 构造器的参数。这里只需要拷贝下来
            // 就可以了（把他们当作已编写好的参数）
            Sequence seq = new Sequence(Sequence.PPQ, 4);

            // 从上面构造的 Sequence 实例请求一个音轨 Track。
            // 请记住音轨是存在于音序上的，同时 MIDI 数据又
            // 存在于音轨中
            Track track = seq.createTrack();

            // 把一些 MIDI 事件（MidiEvent）放入到音轨中。这部分就更是
            // 些已经编写好的代码了。需要留意的就是 setMessage() 方法的
            // 那些参数，还有 MidiEvent 构造器的那些参数。接下来就会看到
            // 这些参数。
            ShortMessage a = new ShortMessage();
            a.setMessage(144, 1, 44, 100);
            MidiEvent noteOn = new MidiEvent(a, 1);
            track.add(noteOn);

            ShortMessage b = new ShortMessage();
            b.setMessage(128, 1, 44, 100);
            MidiEvent noteOff = new MidiEvent(b, 16);
            track.add(noteOff);

            // 把这个音序交给音序器（就好比把光盘放入到光盘播放器）
            player.setSequence(seq);
            // 启动（start()）音序器，就好比按下 PLAY 按键
            player.start();
        } catch (Exception ex){
            ex.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="构造一个-midievent-乐曲数据"><a class="header" href="#构造一个-midievent-乐曲数据">构造一个 <code>MidiEvent</code> （乐曲数据）</a></h3>
<p><strong>Making a <code>MidiEvent</code> (song data)</strong></p>
<p>一个 <code>MidiEvent</code> 对象，就是构成乐曲组成部分的一条指令（A <code>MidiEvent</code> is an instruction for part of a song）。而一系列的 <code>MidiEvent</code> 对象，就像是乐谱一样，或者像是自动钢琴的卷轴。这里所关心的绝大部分<code>MidiEvent</code>，都是描述 <em><strong>要做的事</strong></em> 以及 <em><strong>做这事的时刻</strong></em>。时间部分的时刻尤其重要，因为对于音乐来说，时机就是全部（The moment in time part matters, since timing is everything in music）。音符接着一个音符。正是由于 <code>MidiEvent</code>如此详细，所以就必须要讲清楚，在什么时候 <em>开始</em> 演奏音符（即一个 <code>NOTE ON</code> 事件），还有在什么时候 <em>停止</em> 演奏这个音符（即 <code>NOTE OFF</code> 事件）。那么就可以联想到，在“开始演奏音符 G”（<code>NOTE ON</code>）消息之前，去发出“停止演奏音符 G”（<code>NOTE OFF</code> 消息），是不行的。</p>
<p>MIDI 指令实际上是放在 <code>Message</code> 类类型的对象中的；而 <code>MidiEvent</code> 则是结合 <code>Message</code>与发出这个<code>Message</code>的时间维度上的某个时刻，而的来的。也就是说，某个<code>Message</code>对象可能为 “开始演奏中音C调”，然后对应的<code>MidiEvent</code>对象可能说的是“在第4拍处出发这个消息”。</p>
<p>那么这样看来，总是需要（同时）一个 <code>Message</code> 与一个 <code>MidiEent</code>。</p>
<p><code>Message</code> 对象将的是要做 <em>什么</em>，而 <code>MidiEvent</code> 讲的是 <em>什么时候</em> 做这个事情。</p>
<blockquote>
<p><code>MidiEvent</code> 对象描述了要做 <strong>什么</strong> 以及 <strong>何时</strong> 做这个事情。</p>
<p>每条指令都必须包含用于该指令的时刻（Every instruction must include the <strong>timing</strong> for that instruction）。</p>
<p>也就是说，某个动作应该在 <strong>哪一</strong> 拍出现（In other words, at which <strong>beat</strong> that thing should happen）。</p>
</blockquote>
<ol>
<li>
<p>构造一个 <code>Message</code> 对象</p>
<pre><code class="language-java">ShortMessage a = new ShortMessage();
</code></pre>
</li>
<li>
<p>把 <strong>指令</strong> （<code>Instruction</code>） 放在 <code>Message</code> 对象里</p>
<pre><code class="language-java">// 此消息（报文，message）讲的是，“开始演奏 44 号音符”
// （在下面的内容中，将涉及其他 3 个数字说的是什么）
a.setMessage(144, 1, 44, 10);
</code></pre>
</li>
<li>
<p>使用这个 <code>Message</code> 对象，来构造出一个新的 <code>MidiEvent</code> 对象</p>
<pre><code class="language-java">// 所有指令都是在消息中，而 MidiEvent对象加入则是，应在何时
// 触发指令的、时间维度中的时刻。这个 MidiEvent 说的就是在
// 第一拍的时候，触发消息 'a'。
MidiEvent noteOn = new MidiEvent(a, 1);
</code></pre>
</li>
<li>
<p>把<code>MidiEvent</code>添加到 <strong>音轨<code>Track</code>上</strong></p>
<pre><code class="language-java">// 音轨（a Track） 保存了全部的 MidiEvent 对象。音序 Sequence 对象
// 是通过各个 MidiEvent 事件对象应在何时发生的方式，来组织这些
// MidiEvent 对象的，且随后的音序器 Sequencer 对象，便以这种顺序，把
// 这些 MidiEvent 对象回放出来。在时间维度上的某个精准的同一时刻，可以有
// 很多 MidiEvent 事件发出。比如，可能想要同时演奏两个音符，或者要两种
// 不同乐器在同一时间演奏不同的声音等等。
track.add(noteOn);
</code></pre>
</li>
</ol>
<h3 id="midi-消息报文midievent对象的核心所在"><a class="header" href="#midi-消息报文midievent对象的核心所在">MIDI 消息/报文：<code>MidiEvent</code>对象的核心所在</a></h3>
<p>MIDI 消息保存了 MIDI 事件中指出要做什么的部分。即要音序器干什么的具体指令。指令的第一个参数，总会是消息/报文的类型。而其他三个参数的取值，就依赖于报文的类型。比如，类型编号为 <code>144</code> 的报文，表示的是 <code>NOTE ON</code>类型。而音序器为了执行一个 <code>NOTE ON</code> 指令，就需要了解其他一些东西。可以设想音序器在讲，“好的，我将演奏一个音符，但是 <em>在哪个通道</em> 呢？也就是说，是要演奏一个鼓的音符，还是钢琴的音符？还有是 <em>哪个音符</em> 呢？ 是中音 C 调，还是 D 调高音？还有在演奏时，以 <em>什么样的速度</em> 来演奏这个音符呢？”</p>
<blockquote>
<p><code>Message</code>对象，讲了要做什么，<code>MidiEvent</code>对象讲的是何时来做这些（The <code>Message</code> says what to do, the <code>MidiEvent</code> says when to do it）。</p>
</blockquote>
<p>要构造一个 MIDI 报文，就要构造一个 <code>ShortMessage</code> 类的实例，并在运行其 <code>setMessage()</code> 方法时，传入报文的四个参数。但要记住，报文只讲了要做什么，因此还需要把报文“发出”的时间添加上，从而让报文成为一个事件（But remember, the message says only <em>what</em> to do, so you still need to stuff the message into an event that adds <em>when</em> that message should 'fire'）。</p>
<p><strong>报文剖析（Anatomy of a message）</strong></p>
<p><code>setMessage()</code> 方法的第一个参数，表示的是报文的 “类型（type）”，根据这个表示类型的参数的不同，其他三个参数就会表示不同的东西。</p>
<p><img src="images/Ch11_15.png" alt="MIDI 报文解析" /></p>
<p><em>图 15 - MIDI 报文解析</em></p>
<h3 id="修改报文"><a class="header" href="#修改报文">修改报文</a></h3>
<p><strong>Change a message</strong></p>
<p>既然知道了 MIDI 报文是什么，那么就可以开始实验了。可以对要演奏的音符、音符持续时间、添加更多音符等进行修改，甚至改变乐器。</p>
<p><img src="images/Ch11_16.png" alt="MIDI 报文实验" /></p>
<p><em>图 16 - MIDI 报文实验</em></p>
<h3 id="第二版使用命令行参数来进行声音实验"><a class="header" href="#第二版使用命令行参数来进行声音实验">第二版：使用命令行参数来进行声音实验</a></h3>
<p><strong>Version 2: Using command-line args to experiment with sounds</strong></p>
<p>这个版本仍指挥演奏单个音符，不过可以使用命令行参数来改变乐器与音符。实验是通过传入两个从 <code>0</code> 到 <code>127</code> 之间的整数值的方式进行的。第一个整数值对乐器进行设置，第二个设置要演奏的音符。</p>
<h2 id="codekitchens其余部分的分布"><a class="header" href="#codekitchens其余部分的分布"><code>CodeKitchens</code>其余部分的分布</a></h2>
<p><strong>Where we're headed with the rest of the <code>CodeKitchens</code></strong></p>
<p><strong>第15章：目标app</strong></p>
<p>在做完后，就会有个可用的 <code>BeatBox</code> app，同时也是一个 <code>Drum Chat</code>的客户端。那需要学习有关GUI（包括事件处理）、<code>I/O</code>、网络通信以及线程等知识。后面连续三章（12、13及14）将先后学习这些内容。</p>
<p><img src="images/Ch11_17.png" alt="完成后的 BeatBox app" /></p>
<p><em>图 17 - 完成后的 <code>BeatBox</code> app</em></p>
<hr />
<p><strong>第12章：MIDI 事件</strong></p>
<p>在第12章，会构建一个小型的、给MIDI 音乐的节拍绘制上随机矩形的 &quot;音乐视频（music video）&quot;（这样讲是有点牵强的，This CodeKitchen lets us build a little &quot;music video&quot;(bit of a stretch to call it that...) that draws random rectrangles to the beat of the MIDI music）。那里将学习到构建并演奏很多的MIDI事件（相比于这里的仅仅一两个事件而言）。</p>
<p><img src="images/Ch11_18.png" alt="第12章构建的 BeatBox app" /></p>
<p><em>图 18 - 第12章构建的 <code>BeatBox</code> app</em></p>
<p><strong>第13章：单机版的 <code>BeatBox</code></strong></p>
<p>在那里具体构建真实的 <code>BeatBox</code>，其 GUI 以及其他的全部。但那是有功能限制的 -- 在修改曲谱时，就会丢失先前的曲谱。因为还没有保存及恢复特性，同时无法与网络进行通信。（不过可以用这里的 <code>BeatBox</code> app 来练习编曲技能。）</p>
<p><img src="images/Ch11_19.png" alt="第13章构建的单机版BeatBox app" /></p>
<p><em>图 19 - 第13章构建的单机版<code>BeatBox</code> app</em></p>
<p><strong>第 14 章：保存与恢复特性</strong></p>
<p>在已经构造出良好曲谱后，这里就可以将其保存到文件了，且能够在需要再次演奏这个曲谱时，重新加载他。这样就为最终版本（第15章）做好了准备，第15章那儿就不再保存到文件，而是经由网络把曲谱发送到聊天服务器。</p>
<p><img src="images/Ch11_20.png" alt="第14章的BeatBox app：保存与恢复" /></p>
<p><em>图 20 - 第14章的<code>BeatBox</code> app：保存与恢复</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="获取gui一个甚为形象的故事"><a class="header" href="#获取gui一个甚为形象的故事">获取GUI，一个甚为形象的故事</a></h1>
<blockquote>
<p>我听说你前任只会做命令行的饭（I heard your ex-wife could only cook command-line meals）？</p>
<p>喔！这可真是棒极了。呈现真是至关重要啊（Wow! This looks great. I guess presentation really is everything）。</p>
</blockquote>
<p><strong>就承认了吧，你得构造 GUIs 的 App</strong>。在构建的 app 会被其他人用到时，那么就需要图形界面。在构建自己要用的App时，也会想要个图形界面。就算余生都将编写服务器端代码，客户端界面全是web页面，也会早晚会编写一些工具，那个时候也会用到图形界面。当然，命令行的 apps 是复古的，但却并不是一种良好的形式。命令行App功能很弱、不够灵活，还不友好。后续会用两章篇幅，来学习图形用户界面，并随之而了解包括 <strong>事件处理（Event Handling）</strong> 及 <strong>内联类（Inner Classes）</strong> 等 Java 语言的关键特性。这一章中，会将按钮放置在屏幕上，并在点击这个按钮时，让按钮完成一些事情。然后会在屏幕上进行绘制，显示一张 <code>jpeg</code> 的图片出来，甚至还会制作一些动画。</p>
<h2 id="全都是从一个视窗开始"><a class="header" href="#全都是从一个视窗开始">全都是从一个视窗开始</a></h2>
<p><strong>It all starts with a <code>windows</code></strong></p>
<blockquote>
<p><strong>如果再让我看到一个命令行的 app, 那么你就滚蛋吧</strong>。</p>
<p><strong>If I see one more commanl-line app, you're fired</strong>.</p>
</blockquote>
<p><code>JFrame</code> 是表示屏幕上视窗的对象。在那里就可以放上诸如按钮、复选框、文本字段等的用户界面元素。真的还可以有个用起来不错、带一些菜单项的菜单栏。不管在哪个平台，视窗都会有那些小小的视窗图标，用于视窗的最小化、最大化及关闭。</p>
<p>根据所在平台的不同，<code>JFrame</code>就会有不同的样子。下面是在 Mac OS X 上某个 <code>JFrame</code>的样子：</p>
<p><img src="images/Ch12_01.png" alt="带有一个菜单栏与两个“小部件”：一个按钮及一个单选按钮的 JFrame" /></p>
<p><em>图 1 - 带有一个菜单栏与两个“小部件”：一个按钮及一个单选按钮的 <code>JFrame</code></em></p>
<blockquote>
<p>A <code>JFrame</code> with a menu bar and two 'widgets' (a button and a radio button)</p>
</blockquote>
<h3 id="把小部件放进视窗中"><a class="header" href="#把小部件放进视窗中">把小部件放进视窗中</a></h3>
<p>在有了一个 <code>JFrame</code> 之后，通过把物件（小部件，“widgets”）添加到这个 <code>JFrame</code>，这样就把这些物件放进了这个<code>JFrame</code>所表示的视窗中了。可以添加到<code>JFrame</code>的 <code>Swing</code> 组件相当多；在 <code>javax.swing</code>包中可以找到他们。最常用部件包括 <code>JButton</code>、<code>JRadioButton</code>、<code>JCheckBox</code>、<code>JLabel</code>、<code>JList</code>、<code>JScrollPane</code>、<code>JSlider</code>、<code>JTextArea</code>、<code>JTextField</code>，以及<code>JTable</code>等。其中大部分使用起来都很简单，但有些（比如 <code>JTable</code>）用起来就有点复杂。</p>
<h3 id="构造一个gui不难"><a class="header" href="#构造一个gui不难">构造一个GUI不难：</a></h3>
<ol>
<li>
<p>构造一个视窗框（一个 <code>JFrame</code>）:</p>
<pre><code class="language-java">JFrame frame = new JFrame();
</code></pre>
</li>
<li>
<p>构造一个小部件（widget, 如按钮、文本字段等等）：</p>
<pre><code class="language-java">JButton button = new JButton(&quot;点我&quot;);
</code></pre>
</li>
<li>
<p>把这个小部件添加到窗框</p>
<pre><code class="language-java">// 并没有 直接 把物件添加到窗框。可把窗框当作是视窗周围的
// 窗框（the trim around the window），而把物件放在窗玻璃上的
frame.getContentPane().add(button);
</code></pre>
</li>
<li>
<p>显示这个窗框（给予其一个尺寸并令其可见）</p>
<pre><code class="language-java">frame.setSize(300, 300);
frame.setVisible(true);
</code></pre>
</li>
</ol>
<h3 id="第一个gui在窗框上的一个按钮"><a class="header" href="#第一个gui在窗框上的一个按钮">第一个GUI：在窗框上的一个按钮</a></h3>
<pre><code class="language-java">// 不要忘了导入这个 swing 包（这里的 ‘x’ 表示 'extension'）
import javax.swing.*;

public class SimpleGui1 {
    public static void main (String [] args) {
        // 构造一个窗框与按钮（可把希望在按钮上显示的文本，传递
        // 给按钮的构造器）
        JFrame frame = new JFrame();
        JButton button = new JButton(&quot;点击我&quot;);

        // 这行语句使得程序可在关闭视窗时，尽快退出（若没有
        // 这行语句，那么程序就会一直在屏幕上）
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // 将上面构造的按钮，添加到窗框的窗格
        frame.getContentPane().add(button);

        // 给予该窗框一个尺寸，是以像素为单位的
        frame.setSize(300, 300);

        // 最后，让该窗框可见！！！（若忘记这一步，那么在运行
        // 这段代码时什么也看不到。）
        frame.setVisible(true);
    }
}
</code></pre>
<h3 id="不过在点击这个按钮时什么也没发生"><a class="header" href="#不过在点击这个按钮时什么也没发生">不过在点击这个按钮时，什么也没发生......</a></h3>
<p>准确来说这样讲有点背离事实。在按下按钮时，按钮会展示“被按下”或“按进去”的样子（具体看起来怎样，跟平台的外观和感受有关，但不论在何种平台，在按钮被按下时，都会发生一些改变）。</p>
<p>然而真正的问题在于，“怎样才能让按钮在用户按下时，去执行某些特定操作（How do I get the button to do something specific when the user clicks it）?”。</p>
<p><strong>这里就需要两个东西</strong>：</p>
<ol>
<li>
<p>在用户点击时，要调用到的 <strong>方法</strong> （即作为按钮点击结果的、所想要的东西）。</p>
</li>
<li>
<p>一种 <strong>获悉</strong> 何时触发这个方法的机制。也就是说，一种获悉用户在什么时候点击了按钮的方式！</p>
<p><img src="images/Ch12_02.png" alt="GUI 编程关注点：小部件上的事件" /></p>
<p><em>图 2 - GUI 编程关注点：小部件上的事件</em></p>
</li>
</ol>
<h2 id="答疑-10"><a class="header" href="#答疑-10">答疑</a></h2>
<ul>
<li><strong>在Windows 上运行 Java GUI程序时，按钮看起来会像个 Windows 的按钮吗</strong>？</li>
</ul>
<blockquote>
<p>想要就可以。可从少数几种“外观及体验” -- 对应核心库中控制用户界面式样的几个类中加以选择。多数情况下，可以在至少两种外观之间加以选择：一种是被称作 <em><strong><code>Metal</code></strong></em> 的Java 标准的、同时也是平台的原生外观与体验；而这本书中使用的 Mac OS X 截屏，有的是 OS X 的 <em><strong><code>Aqua</code></strong></em> 主题，有的则是 <em><strong><code>Metal</code></strong></em> 外观与体验。</p>
</blockquote>
<ul>
<li><strong>可以构造一个总是 Aqua 主题的程序吗？即便是运行在Windows下也要一直是Aqua主题的</strong>。</li>
</ul>
<blockquote>
<p>注：Aqua 是苹果公司 MacOS 的主题外观。参见：<a href="https://zh.wikipedia.org/wiki/Aqua_(GUI)">Aqua(GUI)</a></p>
</blockquote>
<blockquote>
<p>不可以。并不是在每个平台上全部外观与体验都是可行的。为了保持安全，那么就应该把外观和体验都设置为 <em><strong><code>Metal</code></strong></em>，这样不管 app 运行在哪里，都能准确知道可以得到什么外观与体验，否则就干脆不指定外观与体验，而接受默认的样子。</p>
</blockquote>
<ul>
<li><strong>听说 <code>Swing</code> 慢如蜗牛，没有人用这玩意儿</strong>。</li>
</ul>
<blockquote>
<p>以前或许是这样，现在可不是这样了。在性能差的机器上，或许会感受到 <code>Swing</code> 的痛点。但只要是一台不那么老旧的机器，在使用 Java 版本1.3及以后的版本的情况下，甚至感受不到 <code>Swing</code> GUI 与原生GUI的有什么不同。时至今日，<code>Swing</code>在所有类别的app中都有重度使用。 </p>
</blockquote>
<h2 id="获取用户事件"><a class="header" href="#获取用户事件">获取用户事件</a></h2>
<p><strong>Getting a user event</strong></p>
<p>设想打算在用户按下按钮时，按钮上的文字由 <em>点击我</em> 改编为 <em>我已被点击</em>。首先可以编写一个修改按钮文本的方法（快速参考 API 文档就会发现修改按钮文本的方法<code>setText()</code>）:</p>
<pre><code class="language-java">public void changeIt () {
    button.setText(&quot;我已被点击&quot;);
}
</code></pre>
<p>然而接下来呢？怎么知道这个方法应该什么时候运行呢？<em>怎么知道按钮在什么时候被点击的呢</em>？</p>
<p>在 Java 中，用户事件的获取与处理的过程，叫做 <em>事件处理（event-handling）</em>。尽管Java中有许多不同的事件类型，但绝大部分都涉及到 GUI 下的用户操作。在用户点击了某个按钮时，那就是一个事件。一个讲说“用户希望该按钮相对应的动作发生”的事件。假如按钮是个“慢节奏”按钮，那么用户就希望出现一个慢节奏的操作（An event that says &quot;The user wants the action of this button to happen.&quot; If it's a &quot;Slow Tempo&quot; button, the user wants the slow-tempo action to occur）。又假如是个聊天客户端中的 “发送” 按钮，那么用户就希望出现一个“发送我的消息”的动作。因此最直接的事件就是，在用户点击按钮时，去表明他们是想要某个动作发生。</p>
<p>对于这些按钮，通常无需关心诸如 <code>button-is-being-pressed</code>及<code>button-is-being-released</code>这样的中间事件。想对按钮说的，实际上是“我不介意用户如何操作按钮，以及用户把鼠标悬停在按钮上多长时间，也不关心用户在按下按钮前改变了多少次注意和移开了多少次鼠标光标等等，<em><strong>只要告诉我什么时候用户拿定主意就行</strong></em>！也就是说，除了在用户点击按钮，表示他希望这个该死的按钮去干按钮要干的事情外，都不要说什么！”</p>
<p><strong>首先，按钮需要知道外界关心什么</strong></p>
<p><strong>First, the button needs to know what we care</strong>.</p>
<p><img src="images/Ch12_03.png" alt="Java中GUI事件处理" /></p>
<p><em>图 3 - Java中GUI事件处理</em></p>
<p><strong>其次，按钮（GUI组件）需要某种在按钮点击事件发生时，呼回我们的方式（Second, the button needs a way to call us back when a button-clicked event occurs）</strong>。</p>
<h3 id="脑力大挑战"><a class="header" href="#脑力大挑战">脑力大挑战</a></h3>
<ol>
<li>
<p>到底怎样去通知某个按钮对象，你对其事件的关注？表明你是一个攸关的（事件）收听方（How could you tell a button object that you care about its events? That you're a concerned listener）？</p>
</li>
<li>
<p>假设没有路径可以告知按钮那个独特方法名字（即<code>changeIt()</code>）的情况下，按钮又是在事件发生后怎样呼回的？那么还可以运用什么其他的东西来告知按钮，在事件发生时可以调用我们的特定方法吗？【提示：想想 <code>Pet</code> 类】（How will the button call you back? Assume that there's no way for you to tell the button the name of your unique method(<code>changeIt()</code>). So what else can we use to reassure the button that we have a specific method it can call when the event happens? [hint: think <code>Pet</code>]）</p>
</li>
</ol>
<p><strong>在关心那个按钮的事件时，就去 <em>实现一个<code>interface</code></em>（<code>JButton</code>类的），以表明 “正在收听你的事件”</strong></p>
<blockquote>
<p>注：可以看着是注册一个 GUI 组件的事件收听者。</p>
</blockquote>
<p><strong>收听者 <code>interface</code></strong> 是 <strong>收听者（<code>listener</code>）</strong> （你）与 <strong>事件源（event source）</strong> （按钮） 之间的桥梁。</p>
<p><code>Swing</code> GUI 的那些组件，都属于是事件源。在 Java 词汇表中，事件源指的是可将用户动作（鼠标点击、键盘按键及关闭视窗等），转换为事件的对象（In Java terms, an event source is an object that can turn user actions(click a mouse, type a key, close a window) into events）。与Java中所有其他东西一样，事件本身也是以对象表示的。称之为某事件类的一个对象。通读 API 文档中的 <code>java.awt.event</code> 包就会发现，那里有着一大堆的事件类（很容易区分出来 -- 他们的名字中都有 <code>Event</code>）。将发现 <code>MouseEvent</code>、<code>KeyEvent</code>、<code>WindowEvent</code>、<code>ActionEvent</code>及其他好几种。</p>
<blockquote>
<p>注：<code>java.awt.event</code> 中的 <code>awt</code> 表示：抽象视窗工具集，abstract window toolkit。</p>
</blockquote>
<p>事件 <em>源</em>（比如一个按钮）在用户执行某些重要的操作时（比如 <em>点击</em> 按钮），就会创建处一个 <em>事件对象（event object）</em>。我们所要编写的大部分代码（以及这里的全部代码），都将 <em>接收</em> 事件，而不会 <em>创建</em> 事件。也就是说，编程生涯中花的大部分时间，都是作为事件的 <em>收听者</em>，而不是作为事件 <em>源</em>。</p>
<p>每种事件类型（即每个事件类），都有着一个相匹配的收听者 <code>interface</code>。在希望收听到那些 <code>MouseEvent</code> 事件时，就要去实现 <code>MouseLister</code> <code>interface</code>。要收听那些 <code>WindowEvent</code> 事件，就去实现 <code>WindowLister</code>。明白了吧。还有记住这些 <code>interface</code> 的规则 -- 要实现某个 <code>interface</code>，就要 <em>声明</em> 实现了他（<code>class Dog implement Pet</code>），这意味着必须那个 <code>interface</code> 中全部方法的具体实现代码。</p>
<p>因为事件本身有着各种区别，造成有些 <code>interface</code> 有着不止一个的方法。比如在实现 <code>MouseListener</code>时，就会收到 <code>mousePressed</code>、<code>mouseReleased</code>、<code>mouseMoved</code>等等不同事件。尽管这些不同鼠标事件都叫做<code>MouseEvent</code>，他们在 <code>interface</code> 中却都有单独方法。在实现 <code>MouseListener</code>时，在用户（猜测到的）按下鼠标时，就会调用到 <code>mousePressed()</code>方法。而在用户放开手指时，就会调用到<code>mouseReleased()</code>方法。那么对于这些鼠标事件，就只有一个事件 <em>对象</em>，那就是 <code>MouseEvent</code>，但却有多个不同的事件 <em>方法</em>，用以表示鼠标事件的不同 <em>类别</em>。</p>
<blockquote>
<p>在实现收听者 <code>interface</code> 时，就是在赋予给按钮某种呼回的方式。而这个 <code>interface</code>，正是这个呼回方法声明的地方。</p>
<p>When you implement a listener interface, you give the button a way to call you back. The interface is where the call-back method is declared.</p>
</blockquote>
<p><img src="images/Ch12_04.png" alt="各种不同的收听者 interface" /></p>
<p><em>图 4 - 各种不同的收听者 <code>interface</code></em></p>
<h3 id="收听者与事件源之间通信的方式"><a class="header" href="#收听者与事件源之间通信的方式">收听者与事件源之间通信的方式</a></h3>
<p><strong>How the listener and source communicate</strong>：</p>
<p><img src="images/Ch12_05.png" alt="Java GUI 事件处理：事件源与收听者" /></p>
<p><em>图 5 - Java GUI 事件处理：事件源与收听者</em></p>
<p><strong>事件收听者</strong></p>
<p>若所编写的类希望获知某个按钮的那些 <code>ActionEvent</code> 事件，这个类就要实现 <code>ActionListener</code> 的 <code>interface</code>。那个按钮需要知道这个类对他的事件感兴趣，因此就要通过调用其<code>addActionListener(this)</code>方法，以及将一个<code>ActionListener</code> 类型的引用变量传递给<code>addActionListener()</code> 方法（在这个示例中，收听者就是所编写的类，因此传递了 <code>this</code>），从而注册到这个按钮。按钮需要一种在事件发生时呼回的方式，因此他会调用收听者<code>interface</code>中的方法。而作为一名收听者，所编写的类就 <em>必须</em> 实现那个接口中的唯一一个方法，<code>actionPerformed()</code>。整个过程中，编译器参与进来，确保没有差错。</p>
<p><strong>事件源</strong></p>
<p>按钮就是 <code>ActionEvent</code> 事件源，因此他必须知悉哪些对象是感兴趣的收听者。按钮有个<code>addActionListener()</code>方法，这样那些感兴趣对象（收听者）就有一种告诉按钮，他们对按钮的<code>ActionEvent</code>事件感兴趣的方式。</p>
<p>由于某个潜在的收听者的运行，<code>addActionListener()</code>就运行起来了，此时按钮就取得整个方法的参数（到收听者对象的引用变量），并存储在他的一个清单中。在用户点击按钮时，按钮就会“启动”通过调用 <code>actionPerformed()</code>方法，在清单中的各个收听者上，“启动” 该事件。</p>
<h3 id="获取按钮的-actionevent"><a class="header" href="#获取按钮的-actionevent">获取按钮的 <code>ActionEvent</code></a></h3>
<ol>
<li>
<p>实现 <code>ActionListener</code> 的 <code>interface</code></p>
</li>
<li>
<p>在按钮上进行注册（告诉按钮所编写的类想要收听按钮的事件）</p>
</li>
<li>
<p>定义一个事件处理方法（对 <code>ActionListener</code>接口的 <code>actionPerformed()</code> 方法加以实现）</p>
</li>
</ol>
<pre><code class="language-java">package com.xfoss.learningJava;

import javax.swing.*;
// 一条新的、对 ActionListener 和 ActionEvent 所在包
// 进行导入的导入语句
import java.awt.event.*;


// 1) 实现这个接口。这一行讲的是，“SimpleGui 的实例 IS-A
// ActionListener”。
// （按钮只会把事件，交给那些 ActionListener 的实现者们）
public class SimpleGui implements ActionListener {
	JButton b;
	
	public static void main (String[] args) {
		try {
		SimpleGui gui = new SimpleGui();
		gui.go();
		} catch (HeadlessException e) {
			System.out.format(&quot;没有显示器，无法运行本程序。\n&quot;
					+ &quot;错误代码\n&quot;
					+ &quot;------------------------------\n%s\n&quot;, e);			
		}
	}
	
	public void go () {
        JFrame f = new JFrame ();
        b = new JButton (&quot;点我&quot;);
		
        // 2) 在按钮上注册对按钮事件感兴趣。这行对按钮讲，“把我
        // 添加到你的收听者清单”。
        // 这里传递的参数，必须 是某个实现了 ActionListener 接口
        // 的类的对象！！！
        b.addActionListener(this);
        
        f.getContentPane().add(b);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        f.setSize(300, 300);
        f.setVisible(true);
	}
	
    // 3) 对 ActionListener 接口的 actionPerformed() 方法进行实现......
    // 这就是那个具体的事件处理方法!
    // 
    // 按钮调用他的这个方法，来让用户知道某个事件发生了。此方法会将一个
    // ActionEvent 对象，作为参数发送给收听者，不过这里并不需要这个
    // 参数。这里知道事件发生了就足够了。
    public void actionPerformed (ActionEvent ev) {
        // 可以这样写：
        // JButton x = (JButton) ev.getSource();
        // x.setText(&quot;我已经被点击了!&quot;);
        //
        b.setText(&quot;我已经被点击了!&quot;);
        System.out.format(&quot;按钮 “%s” 被点击\n&quot;, ev.getActionCommand());
    }
}
</code></pre>
<h2 id="收听者事件源与事件"><a class="header" href="#收听者事件源与事件">收听者、事件源与事件</a></h2>
<p><strong>Listeners，Sources，and Events</strong></p>
<p>对于今后闪亮的Java职业生涯而言，咱们自己多半不会成为事件 <em>源</em>。</p>
<p>（不管在你的社交圈子中有多么的优秀）。</p>
<p>要习惯这一点。<em>作为Java程序员，做好事件收听者就够了</em>。</p>
<p>（实际上在社交生活中，做好一名默默的听别人讲话的听众，也是有利于社交技能的。）</p>
<p><img src="images/Ch12_06.png" alt="Java GUI 事件处理：事件收听者、源与事件对象" /></p>
<p><em>图 6 - Java GUI 事件处理：事件收听者、源与事件对象</em></p>
<h2 id="答疑-11"><a class="header" href="#答疑-11">答疑</a></h2>
<ul>
<li><strong>为什么编写的类自己不能成为事件源（Why can't I be a source of events）</strong>？</li>
</ul>
<blockquote>
<p>这是可以的。上面说的只是多数时候我们是事件接收者（至少在Java编程生涯的早期阶段是这样）。我们所可能关注的绝大部分事件，都是由 Java API 中的类“启动”的，这样所有要做的，就是做好这些事件的收听者。当然也会遇到设计的程序需要某种定制事件的情形，比如一个股市盯盘 app 发现发生了 app 认为重要的事情时，就会抛出一个 <code>StockMarketEvent</code>的事件出来。这时就要把 <code>StockWatcher</code> 对象造成一个事件源，不仅如此，还要完成与按钮（或其他事件源）所完成的那些一样的事情 -- 为定制事件构造收听者<code>interface</code>，提供到事件注册方法（<code>addStockListener()</code>），以及在有人调用到<code>StockWatcher</code>对象时，将调用者（某个收听者）添加到他自己的收听者清单。完成这些之后，那么当出现某个股市事件时，<code>StockWatcher</code>对象，就会实例化出一个 <code>StockEvent</code>（另一个需要编写的类） 对象，并通过调用那些收听者的 <code>stockChanged(StockEvent ev)</code>方法，把这个对象发送给那些收听者。还有不要忘记，对于每种 <em>事件类型</em>，都必须要有一个 <em>相应的收听者接口（a matching listener interface）</em>（那么就需要创建一个带有 <code>stockChanged()</code> 方法的 <code>StockListener</code> 接口出来）。</p>
</blockquote>
<ul>
<li><strong>在上面的代码实例中，并未见识到传递给事件回调方法参数的重要性（the importance of the event object that's passed to the event call-back methods）。在有人调用了我的 <code>mousePressed</code> 方法时，我还需要其他的什么信息吗</strong>？</li>
</ul>
<blockquote>
<p>很多时候，对于大部分设计来说，都不需要事件对象本身。事件对象除了作为一个数据承载者，用于发送事件的更多信息外，也没什么其他用途。不过在有的时候，就可能需要从事件对象查询一些事件的具体细节。比如在<code>mousePressed()</code>方法被调用到时，就知道有鼠标按键被按下。但是若需要准确知道鼠标在何处被按下呢？也就是说，若需要知道鼠标到底是在屏幕上的哪个X与Y坐标处被按下的时候。</p>
<p>也会有同一个收听者被注册到 <em>多个</em> 事件源对象的情况。比如有这么一个屏上计算器 app（an onscreen calculator），他有着10个数字按键且都会做同样的事情，这样就不大可能为每个按键都构造一个单独的收听者。那么就会把单个收听者同时注册到这10个按键上，那么在接收到某个事件时（由于收听者的回调方法被调用到），就可以调用事件对象上的某个方法，来找出事件的真实事件源来。也就是找出是哪个按键发出的这个事件。</p>
</blockquote>
<ul>
<li><strong>我该怎样知道某个对象是不是事件源</strong>？</li>
</ul>
<blockquote>
<p>去翻翻 API 文档。</p>
</blockquote>
<ul>
<li><strong>好吧，那要去找什么呢</strong>？</li>
</ul>
<blockquote>
<p>就是那些以 <code>add</code> 开头、<code>Listener</code>结束，且还会接收一个收听者<code>interface</code>参数的方法。比如在看到了：</p>
</blockquote>
<pre><code class="language-java">addKeyListener(KeyListener k)
</code></pre>
<blockquote>
<p>就应该知道，带有此方法的那个类，就是一个 <code>KeyEvent</code> 事件的事件源。显然在这点上有着某种命名范式。</p>
</blockquote>
<h2 id="回到图形"><a class="header" href="#回到图形">回到图形......</a></h2>
<p><strong>Getting back to graphics......</strong></p>
<p>既然现在已对事件运行机制有了基本掌握（后续会学到更多有关事件的内容），那么就让我们回到往屏幕上放物件吧。在再次回到事件处理上去之前，先来花点时间来玩一下，看看几种获得图形的好玩方式。</p>
<p><strong>往GUI上放物件有三种方式</strong>：</p>
<ol>
<li>
<p><strong>在窗框上放置小部件（Put widgets on a frame）</strong></p>
<p>此方式可以把按钮、菜单、单选按钮等小部件放上去。</p>
<pre><code class="language-java">frame.getContentPane().add(myButton);
</code></pre>
<p><code>javax.swing</code>包有着十多种小部件类型。</p>
<p><img src="images/Ch12_07.png" alt="往GUI上放东西之一：把javax.swing中的小部件放在窗框上" /></p>
<p><em>图 7 - 往GUI上放东西之一：把<code>javax.swing</code>中的小部件放在窗框上</em></p>
</li>
<li>
<p><strong>在小部件上绘制 2D 图形</strong></p>
<p>运用图形对象，来绘制形状。</p>
<pre><code class="language-java">graphics.fillOval(70, 70, 100, 100);
</code></pre>
<p>除了方块和圆形之外，还可以绘制很多很多的形状；<code>Java2D</code> API 充满了有趣、复杂的图形方法。</p>
<p><img src="images/Ch12_08.png" alt="往GUI上放东西之二：运用 Java2D API 在小部件上绘制图形" /></p>
</li>
<li>
<p><strong>把 JPEG 图片放在小部件上</strong></p>
<p>可将自己的图像放在某个小部件上。</p>
<pre><code class="language-java">graphics.drawImage(myPic, 10, 10, this);
</code></pre>
<p><img src="images/Ch12_09.png" alt="往GUI上放东西之三：将图像放在小部件上" /></p>
</li>
</ol>
<h2 id="构造自己的绘制小部件"><a class="header" href="#构造自己的绘制小部件">构造自己的绘制小部件</a></h2>
<p><strong>Make your own drawing widget</strong></p>
<p>在打算把自己的图形放到屏幕上时，最好是构造自己的可绘制小部件。随后把自己构造的可绘制小部件，就像按钮或所有其他小部件一样，丢到窗框上即可，不同之处在于，可在自己构造的小部件上，显示出自己的图像来。此外甚至还可以令到这些图像以动画的形式动起来，或者制作出伴随鼠标点击，而改变屏幕上颜色的效果。</p>
<p>在 Java GUI 种实现这些特效，就是小菜一碟的事情（It's a piece of cake）。</p>
<p>只需 <strong>构造一个 <code>JPanel</code> 的子类，并重写 <code>JPanel</code> 中的一个方法 <code>paintComponent()</code></strong> 即可。</p>
<blockquote>
<p>注意：这里的 <code>JPanel</code> 与上面出现的 <code>pane</code>，一字之差，<code>JPanel</code> 是面板小部件，可直接绘制，而 <code>pane</code> 是视窗格，有区别。</p>
</blockquote>
<p>把自己的有关图形的全部代码，都放在 <code>paintComponent()</code> 方法中。可把 <code>paintComponent()</code>方法，当作由系统调用的方法，他讲到，“你好呀，小部件，现在要给你绘图了。” 而比如在想要绘制一个圆圈时，<code>paintComponent()</code>方法中就应该放入画圆圈的代码。就在那个驻留着正在绘制的视窗窗格的视窗框，显示出来的时候，就会调用到<code>paintComponent()</code>方法，从而所画的圆圈就会呈现出来。在用户最小化而把视窗隐藏起来时，JVM 就知道，这个窗框需要在其重新显示的时候“加以修复”，那么 JVM 就会再次调用 <code>paintComponent()</code>。而后只要JVM认为显示内容需要刷新，他都会对我们编写的 <code>paintComponent()</code>方法进行调用。</p>
<p>此外，<em>这个方法绝不会由代码编写者自己去调用</em>！该方法的参数（一个 <code>Graphics</code> 对象），就是那个真正的、贴到 <em>真实</em> 显示器上的绘制画布（the actual drawing canvas that gets slapped onto the <em>real</em> display）。代码编写者是无法自己获取到这个 <code>Graphics</code> 对象的；而只能由系统交到代码编写者手上。这一点在后面就能看到，不过 <em>可以</em> 请求系统刷新显示屏（即<code>repaint()</code>方法），这种刷新最终也是导致 <code>paintComponent()</code> 方法的调用。</p>
<pre><code class="language-java">// 同时需要下面的两个包
import java.awt.*;
import javax.swing.*;

// 构造一个 JPanel 的子类，即一个可像其他小部件一样，添加
// 到视窗框的小部件。不过这样的小部件是自己定制的而已。
class MyDrawPanel extends JPanel {

    // 这可是终极图形方法（This is the Big Important 
    // Graphics method）。代码编写者绝不会自己调用到这个
    // 方法的。系统会调用这个方法，并说，“这里有个类型为 Graphics 
    // 现在就可以在上面绘画的、很好的绘制平面。”
    public void paintComponent (Graphics g) {

        // 可把 'g' 想象为一台绘画机器。我们就在告诉
        // 他用哪种颜色绘画，以及要绘制什么形状（以坐标
        // 表示这个形状在哪里以及又多大）
        g.setColor(Color.orange);
        g.fillRect(20, 50, 100, 100);
    }
}
</code></pre>
<p><img src="images/Ch12_10.png" alt="Java GUI 中编写自己的小部件示例：绘制一个橙色的矩形" /></p>
<p><em>图 10 - Java GUI 中编写自己的小部件示例：绘制一个橙色的矩形</em></p>
<h2 id="在-paintcomponent-方法中干些有趣的事情"><a class="header" href="#在-paintcomponent-方法中干些有趣的事情">在 <code>paintComponent()</code> 方法中干些有趣的事情</a></h2>
<p><strong>Fun things to do in <code>paintComponent()</code></strong></p>
<p>下面来看看在 <code>paintComponent()</code> 中可以干点别的什么事。最好玩的，就在自己开始体验的时候了。开始是以一些数字来操纵这个方法，然后检查类 <code>Graphics</code> 的API文档（后面还会发现，可以类 <code>Graphics</code> 本身的那些东西之外，还可以有更多玩法）。</p>
<h3 id="显示一张-jpeg-图片"><a class="header" href="#显示一张-jpeg-图片">显示一张 <code>JPEG</code> 图片</a></h3>
<pre><code class="language-java">package com.xfoss.learningJava;

import java.awt.*;
import javax.swing.*;

public class CustomWidgetTestDrive {
    public static void main (String[] args) {
        try {
            CustomDrawPanel p = new CustomDrawPanel();
            JFrame f = new JFrame ();
            f.add(p);

            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            f.setSize(1024, 768);
            f.setVisible(true);
        } catch (HeadlessException e) {
            System.out.format(&quot;没有显示器，无法运行本程序。\n&quot;
                    + &quot;错误代码\n&quot;
                    + &quot;------------------------------\n%s\n&quot;, e);			
        }
    }
}

class CustomDrawPanel extends JPanel {
    public void paintComponent (Graphics g) {
        // 图像文件名放在这一行中。注意：在使用某种IDE而
        // 有困难时，可尝试使用下面的代码：
        Image image = new ImageIcon(getClass().getResource(&quot;Defautl.jpeg&quot;)).getImage();
        // Image image = new ImageIcon(&quot;Default.jpeg&quot;).getImage();
        //
        // 这里的 '3, 4' x/y 坐标，表示图片的左上角应该在
        // 的位置。意思是“离窗格左边缘 3 个像素，离窗格
        // 上边缘 4 个像素”。这些数字，都是相对于小部件
        // 的（此示例中，就是这里的 JPanel 的子类），而
        // 不是整个的视窗框
        g.drawImage(image, 3, 4, this);
    }
}
</code></pre>
<p><img src="images/Ch12_11.png" alt="Java GUI构造自己的小部件：显示一个图片" /></p>
<p><em>图 11 - Java GUI构造自己的小部件：显示一个图片</em></p>
<h3 id="在黑背景上绘制一个随机颜色的圆圈"><a class="header" href="#在黑背景上绘制一个随机颜色的圆圈">在黑背景上绘制一个随机颜色的圆圈</a></h3>
<pre><code class="language-java">public void paintComponent (Graphics g) {
    // 用黑色（默认颜色）填充整个窗格
    //
    // 前两个参数，定义了绘制开始的地方，也就是窗格左上角的
    // 相对于整个窗格的（x, y）坐标，因此 （0，0）就表示
    // “从离左边缘 0 像素及从上边缘的 0 像素开始”。另外两个
    // 参数说，“让该矩形的宽度为窗格的宽度（this.width()）
    // 且让其高度与窗格的高度（this.height()）一样高”
    g.fillRect(0, 0, this.getWidth(), this.getHeight());

    int red = (int) (Math.random() * 256);
    int green = (int) (Math.random() * 256);
    int blue = (int) (Math.random() * 256);

    // 可通过传入 3 个表示 RGB 数值的整数，来构造某种颜色。
    Color randomColor = new Color(red, green, blue);
    g.setColor(randomColor);
    // 从离左边缘 70 像素，离顶部 70 像素的地方
    // 开始，让其宽度为 100 像素，高度为 100 像素
    g.fillOval(70, 70, 100, 100);
}
</code></pre>
<h3 id="本质在每个优良的-grphics-引用变量后面都有一个-graphics2d-对象"><a class="header" href="#本质在每个优良的-grphics-引用变量后面都有一个-graphics2d-对象">本质：在每个优良的 <code>Grphics</code> 引用变量后面，都有一个 <code>Graphics2D</code> 对象</a></h3>
<p><strong>Behind every good <code>Graphics</code> reference is a <code>Graphics2D</code> object</strong></p>
<p><code>paintComponent()</code>的参数，被声明为类型 <code>Graphics</code> （<code>java.awt.Graphics</code>）。</p>
<pre><code class="language-java">public void paintComponent(Graphics g) {}
</code></pre>
<p>那么这个参数 <code>g</code> IS-A <code>Graphics</code> 对象。这就意味着他 <em>可以</em> 是 <code>Graphics</code> 的 <em>子类</em> （因为多态机制）。实际上他 <em>就是</em>。</p>
<p><strong><em>参数 <code>g</code> 所指向的对象，实际上是类</em> <code>Graphics2D</code> 的一个实例</strong>。</p>
<p>为什么要留意这个呢？因为用 <code>Graphics2D</code> 能够办到的很多事，是 <code>Graphics</code> 类类型的引用变量所无法做到的。<code>Graphics2D</code>对象可以完成比 <code>Graphics</code> 对象更多的事情，而实际上在这个 <code>Graphics</code> 引用变量背后，就是 <code>Graphics2D</code> 对象在发力。</p>
<p>请牢记多态机制。编译器是基于引用变量类型，而不是对象本身类型，来确定可以调用到哪些方法。比如某个 <code>Dog</code>类类型的对象，被一个 <code>Animal</code> 类型的引用变量所引用时：</p>
<pre><code class="language-java">Animal a = new Dog();
</code></pre>
<p>那就不能这样写：</p>
<pre><code class="language-java">a.bark();
</code></pre>
<p>就算我们知道那里确实是个 <code>Dog</code> 对象。编译器盯住的是 <code>a</code>，他所见到的 <code>a</code> 就是一个 <code>Animal</code> 类型，进而发现在 <code>Animal</code> 类上并没有 <code>bark()</code> 的遥控器。不过还是可以通过下面这样，把这个对象变为他本来 <em>就是</em> 的<code>Dog</code>类型：</p>
<pre><code class="language-java">Dog d = (Dog) a;
d.bark();
</code></pre>
<blockquote>
<p>注：这实际上是 Java 的 <code>cast</code> 运算符。</p>
</blockquote>
<p>那么接下来的这行带有 <code>Graphics</code> 对象的代码，是这个意思：</p>
<p><strong>在需要使用<code>Graphics2D</code>上的某个方法时，无法从<code>paintComponent()</code> 方法参数 <code>g</code> 直接调用到那个方法。不过可以使用一个新的 <code>Graphics2D</code> 变量，来对 <code>g</code> 进行 <em><code>cast</code></em> 操作</strong>。</p>
<pre><code class="language-java">Graphics2D g2d = (Graphics2D) g;
</code></pre>
<ul>
<li>
<p><strong>在 <code>Graphics</code> 类型引用变量上可以调用的方法</strong>：</p>
<ul>
<li><code>drawImage()</code></li>
<li><code>drawLine()</code></li>
<li><code>drawPolygon()</code></li>
<li><code>drawRect()</code></li>
<li><code>drawOval()</code></li>
<li><code>fillRect()</code></li>
<li><code>fillRoundRect()</code></li>
<li><code>setColor()</code></li>
</ul>
</li>
<li>
<p><strong>把实际上的 <code>Graphics2D</code> 对象，进行 <code>cast</code> 操作而得到一个 <code>Graphics2D</code> 的引用变量</strong>：</p>
</li>
</ul>
<pre><code class="language-java">Graphics2D g2d = (Graphics2D) g;
</code></pre>
<ul>
<li>
<p><strong>在 <code>Graphics2D</code> 类型引用变量上可以调用的方法</strong>：</p>
<ul>
<li><code>fill3DRect()</code></li>
<li><code>draw3DRect()</code></li>
<li><code>rotate()</code></li>
<li><code>scale()</code></li>
<li><code>shear()</code></li>
<li><code>transform()</code></li>
<li><code>setRenderingHints()</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>注：（这并不是完整的方法清单，可查阅 API 文档了解其他方法）。</p>
</blockquote>
<h3 id="既然有渐变色来绘制圆圈那么就不要浪费时间去绘制纯色的了"><a class="header" href="#既然有渐变色来绘制圆圈那么就不要浪费时间去绘制纯色的了">既然有渐变色来绘制圆圈，那么就不要浪费时间去绘制纯色的了</a></h3>
<p><strong>Because life's too short to paint the circle a solid color when there's a gradient blend waiting for you</strong>.</p>
<pre><code class="language-java">// 这里的 'g' 实际上是个 Graphics2D 对象，这里只不过
// 伪装成了一个 Graphics 对象。
public void paintComponent (Graphics g) {
    // 对 'g' 进行 cast 操作，从而就可以调用 Graphics2D
    // 上有，Graphics 上所没有的其余方法
    Graphics2D g2d = (Graphics2D) g;

    // 这里的 (70, 70, Color.blue, 150, 150, Color.orange) 分别是：
    // 开始点（70, 70）、开始的颜色（Color.blue）、结束点（150, 150）和结束颜色
    GradientPaint gradient = new GradientPaint(70, 70, Color.blue, 150, 150, Color.orange);

    // 这行代码将系统的虚拟笔刷，设置为渐变，而不是某种固定颜色
    g2d.setPaint(gradient);
    // fillOval() 方法的本来意思“以系统加载的笔刷（也就是这里的渐变），来填满这个椭圆”
    g2d.fillOval(70, 70, 100, 100);
}
</code></pre>
<p><img src="images/Ch12_13.png" alt="Java GUI定制小部件：经由Graphics2D 绘制渐变色填充的圆形" /></p>
<p><em>图 13 - Java GUI定制小部件：经由<code>Graphics2D</code> 绘制渐变色填充的圆形</em></p>
<hr />
<pre><code class="language-java">// 这段代码与上面的很像，不过这里为渐变笔刷的开始与
// 结束颜色，构造了随机颜色。可以尝试一下！
public void paintComponent (Graphics g) {
    Graphics2D g2d = (Graphics2D) g;

    int red = (int) (Math.random() * 256);
    int green = (int) (Math.random() * 256);
    int blue = (int) (Math.random() * 256);
    Color startColor = new Color(red, green, blue);

    red = (int) (Math.random() * 256);
    green = (int) (Math.random() * 256);
    blue = (int) (Math.random() * 256);
    Color endColor = new Color(red, green, blue);

    GradientPaint gradient = new GradientPaint(70, 70, startColor, 150, 150, endColor);
    g2d.setPaint(gradient);
    g2d.fillOval(70, 70, 100, 70);
}
</code></pre>
<h2 id="重点-2"><a class="header" href="#重点-2">重点</a></h2>
<h3 id="关于-java-gui-的事件"><a class="header" href="#关于-java-gui-的事件">关于 Java GUI 的事件</a></h3>
<ul>
<li>以一个视窗，通常为 <code>JFrame</code> 开始构造 GUI</li>
</ul>
<pre><code class="language-java">JFrame frame = new JFrame();
</code></pre>
<ul>
<li>使用下面这样的代码，可将各种小部件（按钮、文本字段等等）添加到 <code>JFrame</code>：</li>
</ul>
<pre><code class="language-java">frame.getContentPane().add(button);
</code></pre>
<ul>
<li><code>JFrame</code> 与其他大多数组件不同，<code>JFrame</code> 不允许直接添加小部件，而必须将小部件添加到 <code>JFrame</code> 的内容窗格</li>
<li>为了让视窗（<code>JFrame</code>）显示出来，就必须给他一个大小，并让其可见：</li>
</ul>
<pre><code class="language-java">frame.setSize(640, 480);
frame.setVisible(true);
</code></pre>
<ul>
<li>为了获知何时用户点击了某个按钮（或在用户界面上进行的其他操作），就需要对GUI事件进行监听</li>
<li>必须在事件源上注册为事件的攸关方，才能收听到那个事件。所谓事件源，指的是在用户操作基础上，“启动”某个事件的物件（按钮、勾选框等等）</li>
<li>由于事件收听者 <code>interface</code>定义了在事件出现后事件源所调用的方法，从而给到一种事件源对收听者进行回调的方式</li>
<li>通过调用事件源的注册方法，在事件源上对事件源的事件进行注册。把收听者的事件处理代码，放在收听者的回调方法中。比如对于 <code>ActionEvent</code> 事件，该方法就是：</li>
</ul>
<pre><code class="language-java">public void actionPerformed (ActionEvent ev) {
    button.setText(&quot;你已点击！&quot;);
}
</code></pre>
<ul>
<li>传入到事件处理器方法的事件对象，承载了包括事件源本身等事件有关的信息。</li>
</ul>
<h3 id="关于-java-gui-中的图形"><a class="header" href="#关于-java-gui-中的图形">关于 Java GUI 中的图形</a></h3>
<ul>
<li>可在小部件上直接绘制 2D 图形；</li>
<li>可在小部件上直接绘制 <code>.gif</code> 或 <code>.jpeg</code>；</li>
<li>而要绘制自己的图形（包括 <code>.gif</code> 或 <code>.jpeg</code>），就要构造一个 <code>JPanel</code> 的子类，并重写 <code>paintComponent()</code> 方法；</li>
<li><code>paintComponent()</code> 方法是由 GUI 系统调用的。<strong>绝不会自己调用到这个方法</strong>。<code>paintComponent()</code>的参数，是提供最终在屏幕上显示出来的绘制表面的一个 <code>Graphics</code> 对象。此对象不能由代码编写者自己构建；</li>
<li>在 <code>Graphics</code> 对象上调用到的典型方法有：</li>
</ul>
<pre><code class="language-java">g.setColor(Color.blue);
g.fillRect(20, 50, 100, 120);
</code></pre>
<ul>
<li>使用下面的代码，来构建一个 <code>Image</code>，进而绘制出某个 <code>.jpg</code>来：</li>
</ul>
<pre><code class="language-java">Image image = new ImageIcon(&quot;Default.jpg&quot;).getImage();
</code></pre>
<p>并使用下面的语句绘制出该图像：</p>
<pre><code class="language-java">g.drawImage(image, 3, 4, this);
</code></pre>
<ul>
<li><code>paintComponent()</code> 方法的 <code>Graphics</code> 参数所指向的对象，实际上是 <code>Graphics2D</code> 类的一个实例。<code>Graphics2D</code>类有着多种方法，包括下面这些：</li>
</ul>
<pre><code class="language-console">fill3DRect(), draw3DRect(), rotate(), scale(), shear(), transform().......
</code></pre>
<ul>
<li>必须将 <code>paintComponent()</code> 方法的<code>Graphics</code>参数，进行 <code>cast</code> 操作得到 <code>Graphics2D</code>对象引用变量，才能运行<code>Graphics2D</code>中的那些方法：</li>
</ul>
<pre><code class="language-java">Graphics2D g2d = (Graphics2D) g;
</code></pre>
<h2 id="既然能获取到事件也可以绘制图形了那能不能在获取到事件的时候绘制图形呢"><a class="header" href="#既然能获取到事件也可以绘制图形了那能不能在获取到事件的时候绘制图形呢">既然能获取到事件，也可以绘制图形了，那能不能在获取到事件的时候，绘制图形呢？</a></h2>
<p><strong>We can get an event</strong>.
<strong>We can paint graphics</strong>.
<strong>But can we paint graphics <em>when</em> we get an event</strong>?</p>
<p>下面就来把事件与绘制面板上的变化连接起来（Let's hook up an event to a change in our drawing panel）。这里将在每次点击那个“改变颜色”按钮时，令到圆圈的颜色改变。以下就是这个程序运行的流程：</p>
<p><img src="images/Ch12_14.png" alt="Java GUI 之：事件驱动的图形绘制" /></p>
<p><em>图 14 - Java GUI 之：事件驱动的图形绘制</em></p>
<h2 id="gui布局在一个视窗框上放置多个小部件"><a class="header" href="#gui布局在一个视窗框上放置多个小部件">GUI布局：在一个视窗框上放置多个小部件</a></h2>
<p><strong>GUI layouts: putting more than one widget on a frame</strong></p>
<blockquote>
<p>等一下......怎样才能把两个 <strong>物件</strong> 放在一个视窗框？</p>
</blockquote>
<p>虽然下一章才会涵盖有关 GUI 布局的详细内容，但这里还是要稍微讲一下，方便实现上一小节提出的事件与绘制联动的问题。默认情况下，视窗框有五个可以添加小部件的区域。对于视窗框的这五个区域中的每一个，都只能添加 <em>一个</em> 物件，但不要惊慌！因为放在每个区域的物件，可能是可以驻留另外三个其他物件，包括又一个可以放入两个物件的面板的面板......明白了吧（You can add only <em>one</em> this to each region of a frame, but don't panic! That one thing might be a panel that holds three other things including a panel that holds three other things including a panel that holds two more things and... you get the idea）。实际上之前在把按钮添加到视窗框时，刷了个“诡计”：</p>
<pre><code class="language-java">// 真正意义上说，并不应该这样写（使用这种单个参数的添加
// 方式，This isn't really the way you're supposed to do it(the 
// one-arg method)）。
frame.getContentPane().add(button);
</code></pre>
<pre><code class="language-java">// 这里调用的是带有两个参数的 add() 方法，其中第一个
// 取的是区域（使用了GUI系统的一个常量），另一个就是
// 要添加到那个区域的小部件。
//
// 要把物件添加到视窗框的默认内容窗格，这样写就更好（且通常
// 是强制要求的）。就是全都要指定把小部件放到 哪里 （那个
// 区域）。
frame.getContentPane().add(BorderLayout.CENTER, button);
</code></pre>
<p><img src="images/Ch12_15.png" alt="Java GUI layout: 视窗框分区及单个参数的 add() 方法下的默认分区" /></p>
<p><em>图 15 - Java GUI layout: 视窗框分区及单个参数的 <code>add()</code> 方法下的默认区域</em></p>
<h3 id="每次点击按钮圆圈的颜色都会改变"><a class="header" href="#每次点击按钮圆圈的颜色都会改变">每次点击按钮，圆圈的颜色都会改变。</a></h3>
<p><strong>The circle changes color each time you click the button</strong>.</p>
<pre><code class="language-java">package com.xfoss.learningJava;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleGui3C implements ActionListener {
    JFrame frame;
    public static void main (String[] args) {
        SimpleGui3C gui = new SimpleGui3C();
        gui.go();
    }

    public void go () {
        frame = new JFrame(&quot;事件与绘制图形联动：点击按钮改变圆圈填充颜色实例&quot;);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton button = new JButton(&quot;改变颜色&quot;);
        // 把事件收听者（this），添加到按钮。
        button.addActionListener(this);

        CustomDrawPanel drawPanel = new CustomDrawPanel();
        
        // 把这两个小部件（按钮与绘制面板），分别添加到
        // 视窗框的两个区域
        frame.getContentPane().add(BorderLayout.SOUTH, button);
        frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
        frame.setSize(640, 480);
        frame.setVisible(true);
    }
    public void actionPerformed (ActionEvent ev) {
        // 在用户点击时，就让视窗框去 repaint() 他
        // 自己。而那就意味着视窗框中的所有小部件中的
        // paintComponent() 方法，都会被调用到。
        frame.repaint();
    }
}
</code></pre>
<p><img src="images/Ch12_16.png" alt="Java GUI 实例：事件与绘制图形关联" /></p>
<p><em>图 16 - Java GUI 实例：事件与绘制图形关联</em></p>
<blockquote>
<p>定制的绘制面板小部件（即 <code>CustomDrawPanel</code> 实例），现在位于视窗框的 <code>CENTER</code> 区域。</p>
<p>按钮则是在视窗框的 <code>SOUTH</code> 区域。</p>
</blockquote>
<blockquote>
<p>现在定制绘制面板（<code>CustomDrawPanel</code> 类）的 <code>paintComponent()</code> 方法，在每次用户点击时都会被调用到。</p>
</blockquote>
<h2 id="试试两个按钮"><a class="header" href="#试试两个按钮">试试两个按钮</a></h2>
<p><strong>Let's try it with TWO buttons</strong></p>
<p>南方的按钮，仍将以目前的方式行事，就是调用视窗框上的 <code>repaint()</code>。而新增的第二个按钮（会固定在东方区域）将改变那个标签上的文字。（所谓标签，就是屏幕上的文字，A lable is just text on the screen.）</p>
<h3 id="那么现在就有了四个小部件了"><a class="header" href="#那么现在就有了四个小部件了">那么现在就有了四个小部件了</a></h3>
<p><img src="images/Ch12_17.png" alt="Java GUI 之：小部件布局" /></p>
<p><em>图 17 - Java GUI 之：小部件布局</em></p>
<h3 id="同时还需要-两个-事件"><a class="header" href="#同时还需要-两个-事件">同时还需要 <em>两个</em> 事件</a></h3>
<p><strong>And we need to get TWO events</strong></p>
<p>呜哦。</p>
<p>这样可行吗？在只有一个 <code>actionPerformed()</code>方法的时候，怎样才能获取到 <em>两个</em> 事件呢？</p>
<p><img src="images/Ch12_18.png" alt="Java GUI 示例：获取两个事件之小部件布局" /></p>
<p><em>图 18 - Java GUI 示例：获取两个事件效果展示</em></p>
<h3 id="在两个按钮需要完成不同事情时该怎样获取到两个不同按钮的动作事件呢"><a class="header" href="#在两个按钮需要完成不同事情时该怎样获取到两个不同按钮的动作事件呢">在两个按钮需要完成不同事情时，该怎样获取到两个不同按钮的动作事件呢？</a></h3>
<p><strong>How do you get action events for two different buttons, when each button needs to do something different</strong>?</p>
<ol>
<li>
<p>选项一</p>
<p><strong>实现两个 <code>actionPerformed()</code> 方法</strong></p>
<pre><code class="language-java">class MyGui implements ActionListener {
    // 很多代码过后：
    public void actionPerformed(ActionEvent ev) {
        frame.repaint();
    }

    // 然而这样写是行不通的！（回顾一下方法过载就知道）
    public void actionPerformed(ActionEvent ev) {
        label.setText(&quot;那真痛！&quot;);
    }
}
</code></pre>
<p><strong>缺点是：做不到</strong>！在Java类中不能实现同一个方法两次。这样不会编译的。并且就是 <em>可以</em>，那么事件源又怎样知道应该调用两个方法中的哪一个呢？</p>
</li>
</ol>
<p>2）选项二</p>
<pre><code>**把同一事件收听者，同时注册到两个按钮上**。

```java
class MyGui implements ActionListener {
    // 在这里声明一堆实例

    public void go {
        // 构建 GUI
        colorButton = new JButton(&quot;改变圆圈&quot;);
        labelButton = new JButton(&quot;修改标签&quot;);
        colorButton.addActionListener(this);
        labelButton.addActionListener(this);
        // 这里有更多的 GUI 代码 ......
    }

    public void actionPerformed(ActionEvent ev) {
        if(ev.getSource() == colorButton) frame.repaint();
        else label.setText(&quot;那真痛！&quot;);
    }
}
```

**缺点：这样写确实能行，但这多半不是那么的面向对象不是。** 单个的事件处理器去做许多不同的事情，就意味着让单个方法去完成许多不同的事情。那么在需要修改要处理的某个 *事件源* 的时候，就必定会去动那个 *所有事件源* 的事件处理器。这样的写法有时 *确实是* 一个好办法，但通常这样写会破坏可维护性及扩展性。
</code></pre>
<ol start="3">
<li>
<p>选项三</p>
<p><strong>构造两个单独的 <code>ActionListener</code> 类</strong></p>
<pre><code class="language-java">class MyGui {
    JFrame frame;
    JLabel label;

    void gui () {
        // 用于初始化出两个事件收听者，并把其一注册到修改圆圈
        // 按钮，另一个注册到修改标签按钮的代码
    }
} // 类结束
</code></pre>
<hr />
<pre><code class="language-java">class ColorButtonListener implements ActionListener {
    public void actionPerformed (ActionEvent ev) {
        // 这里不会运作！因为这个类中没有到 'MyGui' 类中
        // 变量 'frame' 的引用
        frame.repaint();
    }
}
</code></pre>
<hr />
<pre><code class="language-java">class ColorButtonListener implements ActionListener {
    public void actionPerformed (ActionEvent ev) {
        // 有问题！因为这个类中没有到变量 'label' 的引用
        label.setText(&quot;那真痛！&quot;);
    }
}
</code></pre>
<p><strong>缺点：这些事件收听者类，不会具有到他们需要进行操作的那些变量 -- <code>frame</code>及<code>label</code> 的访问</strong>。这一点是可以修复的，但就不得不给到这两个事件收听者类，到GUI主类 <code>MyGui</code> 的引用变量，这样才能在 <code>actionPerformed()</code> 方法内部，使用上 GUI 类 <code>MyGui</code> 的引用变量，从而访问到 GUI 主类 <code>MyGui</code> 的变量 <code>frame</code>与<code>label</code>。然而那样做就破坏了封装，因此可能就需要构造各个 GUI 小部件的获取器方法（getter methods, 比如<code>getFrame()</code>、<code>getLabel</code> 等等）。并且还可能需要给这两个事件收听者类编写构造器，从而可将GUI主类的引用变量，在这些事件收听者对象实例化时，传递给这些事件收听者。好吧，这就变得更加乱糟糟，还更复杂了。</p>
</li>
</ol>
<p><em><strong>必须要有别的办法才行</strong></em>！</p>
<blockquote>
<p>若既可以有两个不同的事件收听者类，同时这两个类还能够访问到 GUI 主类中的实例变量，也就是这两个事件收听者类，看起来会属于那个GUI 主类，这要是能做到可就太好了。这样就可以鱼与熊掌二者兼得了（Then you'd have the best of both worlds）。好吧，这可能只是个美梦罢了。不过这只是脑洞大一点而已......</p>
</blockquote>
<h2 id="内部类来拯救"><a class="header" href="#内部类来拯救"><a id="inner_class_rescue"></a>内部类来拯救！</a></h2>
<p><strong>Inner class to the rescue</strong>!</p>
<blockquote>
<p>注：听起来是不是很熟悉？哈哈，这里的内部类，就跟之前的 <a href="Ch08_Interfaces_and_Abstract_Classes.html#interface_rescue"><code>interface</code> 拯救了死亡钻石问题</a>（the Dead Diamon of Death）一样，解决了GUI中多个事件处理器的问题。</p>
</blockquote>
<p><em>可</em> 将一个类嵌套在另一个类中。很简单吧。只需要确保内部类的定义，位于外层类的花括弧内部即可。</p>
<blockquote>
<p><strong>内部类可使用其外层类的全部方法及实例变量，<em>就是私有的也可以</em></strong>。
<strong>An inner class can use all the methods and variables of the outer class, <em>even the private ones</em></strong>.</p>
<p><strong>内部类在使用这些变量与方法时，就好像这些方法与变量是在他自己里声明的一样</strong>。
<strong>The inner class gets to use those variables and methods just as if the methods and variables were declared within the inner class</strong>。</p>
</blockquote>
<p><strong>一个简单的内部类</strong>：</p>
<pre><code class="language-java">class OuterClass {
    // 内部类是整个被外层类包裹起来的
    class InnerClass {
        void go () {}
    }
}
</code></pre>
<p>内部类有着运用其外层类物件的特权（An inner class gets a special pass to use the outer class's stuff）。<em>甚至外层类私有的方法与变量都可以使用</em>。并且内部类在运用这些外层类的私有变量及方法时，就像这些变量与成员是在他自己中定义的一样。那么内部类就很好用了 -- 他们除了有着普通类的绝大部分益处，还有着特别的访问权限。</p>
<p><strong>内部类对外层类变量的运用</strong>：</p>
<pre><code class="language-java">class OuterClass {
    private int x;

    class InnerClass {
        void go () {
            // 这里对 'x' 的使用方式，就
            // 如同 'x' 是在内部类中定义的一样！
            x = 42;
        }
    } // 内部类结束
} // 外层类结束
</code></pre>
<h3 id="内部类实例必须与其外层类实例绑在一起"><a class="header" href="#内部类实例必须与其外层类实例绑在一起">内部类实例必须与其外层类实例绑在一起。</a></h3>
<p><strong>An inner class instance must be tied to an outer class instance</strong>.</p>
<blockquote>
<p>有个十分异常情形下的例外 -- 定义了静态方法的内部类。但这里不会涉及到整个问题，同时贯穿整个Java编程生涯，估计也不会遇到这种情况。</p>
</blockquote>
<p>请记住，在提及某个内部 <em>类</em> 访问其外层类的某个东西时，是真说的是内部类的某个实例，在访问其外层类某个实例中的某个东西。然而到底是 <em>哪个实例</em> 呢？</p>
<p>是任意的内部类实例都可以访问外层类全部实例的变量与方法吗？显然 <strong>不是</strong>！（Can <em>any</em> arbitary instance of the inner class access the methods and variables of <em>any</em> instance of the outer class? <strong>No</strong>!）</p>
<blockquote>
<p><strong>内部对象与其外层对象，有着特殊关系 ♥（An inner object shares a special bond with an outer object）</strong>。</p>
</blockquote>
<p><em>在内存堆上，<strong>内部</strong> 对象必须与指定的 <strong>外层</strong> 对象绑在一起</em>（<em>An <strong>inner</strong> object must be tied to a specific <strong>outer</strong> object on the heap</em>）。</p>
<blockquote>
<p>注：这实际上与对象关系模型（Oject Relational Model, ORM） 中的内连接（inner join）类似。</p>
</blockquote>
<p><img src="images/Ch12_19.png" alt="外层对象与内部对象的构造过程" /></p>
<p><em>图 19 - 外层对象与内部对象的构造过程</em></p>
<p><img src="images/Ch12_20.png" alt="畅销书：找寻你自己的内部类" /></p>
<p><em>图 20 - 畅销书：找寻你自己的内部类</em></p>
<h2 id="怎样构造一个内部类的实例"><a class="header" href="#怎样构造一个内部类的实例">怎样构造一个内部类的实例</a></h2>
<p>在从外层类的代码处实例化内部类时，那么外层类的实例就是，就是内部对象所要 “绑定” 的外层对象。比如在某个方法中的代码实例化内部类时，那么内部对象就会绑定到那个运行此方法的外部实例上（If you instantiate an inner class from code <em>within</em> an outer class, the instance of the outer class is the one that the inner object will 'bond' with. For example, if code within a method instantiates the inner class, the inner object will bond to the instance whose method is running）。</p>
<p>外层类中的代码，可以与实例化其他类完全一样的方式，对其自身的内部类进行实例化，即 <code>new InnerClass();</code>。</p>
<pre><code class="language-java">class OuterClass {
    // 外层类有一个私有实例变量 'x'
    private int x;

    // 构造一个内部类的实例
    InnerClass inner = new InnerClass();
    
    public void doStuff () {
        // 调用内部对象上的方法
        inner.go();
    }

    class InnerClass {
        void go () {
            x = 42;
        }
    } // 内部类结束
} // 外层类结束
</code></pre>
<p><img src="images/Ch12_21.png" alt="外层与内部对象的构造" /></p>
<p><em>图 21 - 外层与内部对象的构造</em></p>
<blockquote>
<p>附加题（Side bar）</p>
<p>运行在外层类外部的代码，也可以对该外层类的内部类进行实例化，但必须使用特殊语法。这种从外部构造内部对象的情况极少，很多人一辈子都不会碰到，写在这里只是为了满足好奇心而已......</p>
</blockquote>
<pre><code class="language-java">class Foo {
    public static void main (String[] args) {
        OuterClass outerObj = new OuterClass();
        OuterClass.InnerClass innerObj = outerObj.new InnerClass();
    }
}
</code></pre>
<h3 id="现在就可以让之前提出的双按钮代码运行起来了"><a class="header" href="#现在就可以让之前提出的双按钮代码运行起来了">现在就可以让之前提出的双按钮代码运行起来了</a></h3>
<p><strong>Now we can get the two-button code working</strong></p>
<pre><code class="language-java">package com.xfoss.learningJava;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

// 现在的 GUI 主类，就不再实现 ActionListener 了
public class MultiWidgetsAndEvents {
    JFrame frame;
    JLabel label;

    public static void main (String[] args) {
        MultiWidgetsAndEvents gui = new MultiWidgetsAndEvents();
        gui.go();
    }

    public void go () {
        frame = new JFrame(&quot;事件与绘制图形联动：多个事件源（小部件）与处理器&quot;);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton btnChangeCircle = new JButton(&quot;改变圆圈&quot;);
        // 这里不再传递 this 给按钮的事件收听者注册方法，而是传递
        // 各自的事件收听者对象。
        btnChangeCircle.addActionListener(new CircleBtnListener());

        JButton btnChangeLabel = new JButton(&quot;改变标签&quot;);
        // 同上。
        btnChangeLabel.addActionListener(new LabelBtnListener());

        CustomDrawPanel drawPanel = new CustomDrawPanel();
        label = new JLabel(&quot;这是一个标签&quot;);

        frame.getContentPane().add(BorderLayout.SOUTH, btnChangeCircle);
        frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
        frame.getContentPane().add(BorderLayout.EAST, btnChangeLabel);
        frame.getContentPane().add(BorderLayout.WEST, label);

        frame.setSize(640, 480);
        frame.setVisible(true);
    }

    // 现在有了两个都是单独类中的 ActionListener 事件收听者了
    class CircleBtnListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            // 内部类就可以使用到实例变量 ‘frame’了，且无需
            // 显式的那个指向外层类对象的引用变量。
            frame.repaint();
        }
    }

    class LabelBtnListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            // 内部类是了解 'label' 变量的。
            label.setText(&quot;那真痛！&quot;);
        }
    }
}
</code></pre>
<p><img src="images/Ch12_22.png" alt="Java GUI 之：运用内部类特性，解决多个小部件与多个事件处理器的问题" /></p>
<p><em>图 22 - Java GUI 之：运用内部类特性，解决多个小部件与多个事件处理器的问题</em></p>
<p><img src="images/Ch12_23.png" alt="Java GUI之：点击“改变标签”按钮后的效果" /></p>
<p><em>图 23 - Java GUI之：点击“改变标签”按钮后的效果</em></p>
<h2 id="java-大曝光----本周采访内部类的实例"><a class="header" href="#java-大曝光----本周采访内部类的实例">Java 大曝光 -- 本周采访：内部类的实例</a></h2>
<p><strong>Java Exposed -- this weeks interview: Instance of an Inner Class</strong></p>
<ul>
<li><strong>HeadFirst(HF)</strong>: 内部类为何重要？</li>
<li><strong>内部对象（Inner object, Io）</strong>: 我要从哪里说起呢，正是我们给到了在类中多次实现 <code>interface</code> 的机会，对吧。请记住，在正常Java类中，无法多次实现接口方法。然而使用 <em>内部</em> 类的话，每个内部类都可以对 <em>同一</em> <code>interface</code> 进行实现，那么就可以有着这些高度一致的接口方法的全部 <em>不同</em> 实现（But using <em>inner</em> classes, each inner class can implement the <em>same</em> interface, so you can have all these <em>different</em> implementations of the very same interface methods）。</li>
<li><strong>HF</strong>: 然而究竟为什么要对同一方法实现两次呢？</li>
<li><strong>Io</strong>：回顾一下 GUI 的事件处理器吧。设想一下......在想要三个分别具有不同事件行为的按钮，并使用三个都实现了 <code>ActionListener</code> 接口的内部类时，那就意味着这每个内部类，都实现了他自己的 <code>actionPerformed()</code> 方法。</li>
<li><strong>HF</strong>：所以说事件处理器是采用内部类的唯一理由吗？</li>
<li><strong>Io</strong>：天哪，绝不是的。事件处理器只是一个明显的例子。任何在需要单独类，但还需要那个类表现得他好像 <em>另一个</em> 类的某个部分时，那么内部类就是最佳 -- 且某些时候唯一 -- 的完成方式（Anytime you need a sperate class, but still want that class to behave as if it were part of <em>another</em> class, an inner class is the best--and sometimes <em>only</em>--way to do it）。</li>
<li><strong>HF</strong>: 这里我还是犯迷糊。若希望内部类以属于外层类一部分的方式 <em>行事</em>，那为何首先考虑的是一个单独类？为何不首先考虑把内部类的代码，就放在外层类中呢？</li>
<li><strong>Io</strong>：上面就才 <em>给出</em> 一个，需要多次对某个接口加以实现的场景吗。即便不是在使用接口，仍然是需要两个不同的类，因为这些类表示了两种不同的 <em>事物</em>。这便是良好的面向对象。</li>
<li><strong>HF</strong>: 喔。这里打住。我原以为面向对象设计很大程度上是关于重用与可维护性呢。你应该知道，关键在于有两个单独类的时候，就可以对他们分别加以修改和使用，这正好与把所有东西都放在一个类中相反，Blah, blah, blah。然而在使用 <em>内部</em> 类时，还是最终与一个 <em>真正的</em> 类打交道，不是吗？最后可重用且对其他人来讲作为单独类的，也只是那个封闭类（the enclosing class） 而已。准确地说，内部类并不是可重用的。事实上，我听说这些内部类被叫做 “毫无重用性 -- 永远没用（Reuseless--useless over and over again）”</li>
<li><strong>Io</strong>: 说内部类不可重用没错，事实上有的时候内部类真是完全无法重用的，这是由于内部类被紧密地与外层类的实例变量与方法绑在一起。然而--</li>
<li><strong>HF</strong>：那正好说明我的看法没错！若他们不可重用，为何还要在单独类上花心思呢（If they're not reusable, why bother with a speparate class）？我的意思是说，与其说是解决了接口的问题，不如说这是一种权宜之计。</li>
<li><strong>Io</strong>: 正如我前面说过的，你需要考虑一下 <code>IS-A</code> 与多态机制的问题。</li>
<li><strong>HF</strong>：好呀。现在我就在考虑这方面的问题，因为......</li>
<li><strong>Io</strong>: 因为外层类与内部类，可能要通过 <em>不同</em> 的 <code>IS-A</code> 测试！还是以这个多态的 GUI 事件收听者的例子开始。按钮的事件收听者注册方法中，参数类型被声明为什么了？也就是说，对照API文档，必须传递给 <code>addActionListener()</code>方法何种 <em>物件</em> （即什么样的类或接口类型）？</li>
<li><strong>HF</strong>：当然必须传递一个事件接受者了。也就是某个实现了特定收听者接口，在这个示例中也就是<code>ActionListener</code>接口的东西。时把，我们对这个还是了解的。你问这些，到底是要说什么呢？</li>
<li><strong>Io</strong>：我说的是，从多态上讲，一个方法就只会接收一种特定 <em>类型</em>。也就是某种通过 <code>ActionListener</code> 接口的 <code>IS-A</code>测试的类型。然而 -- 同时也是重点 -- 在类需要作为 <code>IS-A</code> 某个 <em>类</em> 类型，而不是某个接口类型时，会怎样呢（My point is that polymorphically, you have a method that takes only one particular <em>type</em>. Something that passes the <code>IS-A</code> test for <code>ActionListener</code>. But--and here's the big thing--what if your class needs to be an <code>IS-A</code> of something that'a <em>class</em> type rather than an interface）？</li>
<li><strong>HF</strong>：难道不可以让单独类仅仅去 <em>扩展</em> 那个要成为其一部分的类吗？那不就是子类化运作的要义所在吗？在 <code>B</code> 是 <code>A</code> 的一个子类时，那么在那些期望获得 <code>A</code> 的地方，就可以使用 <code>B</code>。这就是“在声明了<code>Animal</code>类型的地方传递一个<code>Dog</code>”的样子（Wouldn't you have your class just <em>extend</em> the class you need to be part of? Isn't that the whole point of how subclassing works? If <code>B</code> is a subclass of <code>A</code>, then anywhere an <code>A</code> is expected a <code>B</code> can be used. The whole pass-a-<code>Dog</code>-where-an-<code>Animal</code>-is-the-declared-type thing）。</li>
<li><strong>Io</strong>: 是的！那就对了！那么在需要通过针对两个不同类的<code>IS-A</code>测试时会怎样呢？并且这两个类还不在同一个继承树上呢。</li>
<li><strong>HF</strong>：哦，你说的是......嗯。我想我明白了。我们总是可以 <em>实现</em> 多个接口，但只能对 <em>一个</em> 类 <em>进行扩展</em>。在进行<code>IS-A</code>测试时，若碰到 <em>类</em> 类型，那么就只能通过一种类的 <code>IS-A</code>测试（You can always <em>implement</em> more than one interface, but you can <em>extend</em> only <em>one</em> class. You can only be one kind of <code>IS-A</code> when it comes to <em>class</em> types）。</li>
<li><strong>Io</strong>: 就是这样！是的，不能同时是 <code>Dog</code> 和 <code>Button</code>。但是若一个 <code>Dog</code> 在某些时候需要成为一个 <code>Button</code>（为了把这个<code>Dog</code>传递给那些取 <code>Button</code> 类类型参数的方法），这时这个<code>Dog</code>类（由于扩展了<code>Animal</code>而不能再对<code>Button</code>进行扩展）就可以通过对<code>Button</code>进行扩展，而再有一个代表<code>Dog</code>的、像<code>Button</code>那样行事的 <em>内部</em> 类，这样，<code>Dog</code>就可以把他的内部类，而不是他本身，传递给那些要求是<code>Button</code>的地方。就比如，与其是<code>x.takeButton(this)</code>，在运用Java内部类特性后，<code>Dog</code>对象就会调用<code>x.takeButton(new MyInnerButton())</code>（Well done! Yes, you can't be both a <code>Dog</code> and a <code>Button</code>. But if you're a <code>Dog</code> that needs to sometimes be a <code>Button</code>(in order to pass yourself to methods that take a <code>Button</code>), the <code>Dog</code> class(which extends <code>Animal</code> so it can't extend <code>Button</code> again) can have an <em>inner</em> class that acts on the <code>Dog</code>'s behalf as a <code>Button</code>, by extending <code>Button</code>, and thus wherever a <code>Button</code> is required the <code>Dog</code> can pass his inner <code>Button</code> instead of himeself. In other words, instead of saying <code>x.takeButton(this)</code>, the <code>Dog</code> object calls <code>x.takeButton(new MyInnerButton())</code>）。</li>
<li><strong>HF</strong>: 可以给我一个明确的例子吗？</li>
<li><strong>Io</strong>：还记得上面用到的那个绘制面板，那里我们构造了自己定制的<code>JPanel</code>子类吧？那么现在，那个类就是个单独的、不带内部类的类。当然这是没问题的，因为这个类并不需要对主GUI类的实例有什么特别访问。然而假如他真的要对GUI主类的实例进行访问呢？比如需要在那个定制面板小部件上完成动画，进而需要从主应用获取他自己的坐标（即基于用户在GUI中的操作），会怎样呢？那样的话，如果可以给这个定制绘制面板构造一个内部类，那么这个绘制面板就仍然是 <code>JPanel</code>的子类，同时他作为外层类，还可以是其他一些类的子类（Right now, that class is a separate, non-inner, class. And that's fine, because the class doesn't need special access to the instance variables of the main GUI. But what if it did? What if we're doing an animation on that panel, and it's getting is coordinates from the main application(say, based on something the use does elsewhere in the GUI). In that case, if we make the drawing panel an inner class, the drawing panel class gets to be a subclass of <code>JPanel</code>, while the outer class is still free to be a subclass of something else）。</li>
<li><strong>HF</strong>: 我算是搞明白了！而且那个绘制面板本来作为一个单独类就不怎么够得上是可重用，因为这种具体的绘制，就是针对这一个GUI应用的（Yes I see! And the drawing panel isn't reusable enough to be a separate class anyway, since what it's actually painting is specific to this one GUI application）。</li>
<li><strong>Io</strong>: 对呀！你可算搞明白了！</li>
<li><strong>HF</strong>：好。现在就可以继续聊聊内部对象（内部类实例）与外层实例之间 <em>关系</em> 本质了。</li>
<li><strong>Io</strong>：你们这些人类是怎么了？是觉得像多态机制这样严肃的话题的绯闻不够多吗（What is it with you people? Not enough sordid gossip in a serious topic like polymorphism）?</li>
<li><strong>HF</strong>: 你可是对那些无脑公众一点也不了解，他们可是舍得为这些小道消息买单。如此说来，有人把你们内部对象创建出来，然后就立即与外层对象绑在一起，对吗？</li>
<li><strong>Io</strong>：对的。同时也有人把这比作是一场包办婚姻。不过并没有那种内部对象绑定到哪个对象的说法（Yes that's right. And yes, some have compared it to an arranged marriage. We don't have a say in which object we're bonded to）。</li>
<li><strong>HF</strong>: 那么好吧，我会沿用这个婚姻的比喻。内部对象与外层对象，你们可以 <em>离婚</em> 然后 <em>还可以</em> 与其他对象再婚吗？</li>
<li><strong>Io</strong>：不行，这种密切关系是终身的。</li>
<li><strong>HF</strong>：谁的终身？你们的终身吗？还是外层对象的终身？抑或你们二者的终身？</li>
<li><strong>Io</strong>：是作为内部对象我的终身啦。内部对象是再也无法与其他外层对象有关系了。内部对象的唯一归宿，就是垃圾回收了。</li>
<li><strong>HF</strong>：那外层对象会怎样呢？他还可以和其他的内部对象发生关系吗？</li>
<li><strong>Io</strong>：哦哦，总算说到这个话题了。这大概是你真正 <em>想要</em> 的吧。是的，是的。我那称之为“老公”的混蛋，确实可以想要多少内部对象就要多少个。</li>
<li><strong>HF</strong>：这就好比连续性一夫一妻（serial monogamy）吗？还是可以同时拥有全部的内部对象呢？</li>
<li><strong>Io</strong>：同时拥有所有内部对象的。就算这样。满意了吧？</li>
<li><strong>HF</strong>：好吧，这就说得通了。不过还请不要忘了，正是你内部对象对“同一接口的多重实现”赞赏有佳（And let's not forget, it was <em>you</em> extolling the virtues of &quot;mulitple implementations of the same interface&quot;）。那对于这种外层类有着三个按钮，就需要三个不同的内部类（并因此有三个不同内部对象）来处理那些事件的情况，就说的通了。非常感谢。给你一张面巾纸。</li>
</ul>
<p><img src="images/Ch12_24.png" alt="内部对象与外层对象的恩怨情仇" /></p>
<p><em>图 24 - 内部对象与外层对象的恩怨情仇</em></p>
<h2 id="运用内部类实现动画"><a class="header" href="#运用内部类实现动画">运用内部类实现动画</a></h2>
<p><strong>Using an inner class for animation</strong></p>
<p>前面已经见识到了对于事件收听者来讲，内部类是多么的便利，这正是因为有了内部类，才能够多次对同一个事件处理方法加以实现。不过现在是要看看，把内部类用作某个外层类未进行扩展的类的子类时，会多么的有用（But now we'll look at how useful an inner class is when used as a subclass of something the outer class doesn't extend）。也就是，外层类与内部类，是在不同的继承树上！</p>
<p>目标是构造一个简单的动画，其中的圆圈将从左上部移动到右下部。</p>
<p><img src="images/Ch12_25.png" alt="Java GUI 动画：效果" /></p>
<p><em>图 25 - Java GUI 动画：效果</em></p>
<p><strong>简单动画的工作原理</strong></p>
<ol>
<li>
<p>在特定 <code>x</code> 与 <code>y</code> 坐标绘制一个物体</p>
<pre><code class="language-java">// 里左边 20 像素，离顶部 50 像素
g.fillOval(20, 50, 100, 100);
</code></pre>
</li>
<li>
<p>在不同的 <code>x</code> 与 <code>y</code> 坐标重绘</p>
<pre><code class="language-java">// 离左边 25 像素，离顶部 55 像素
// （该物体就往下和往右移动了一点点）
g.fillOval(25, 55, 100, 100);
</code></pre>
</li>
<li>
<p>以不断变化的 x 与 y 值，继续重复之前的步骤，直到应该停下来为止。</p>
</li>
</ol>
<h3 id="答疑-12"><a class="header" href="#答疑-12">答疑</a></h3>
<ul>
<li><strong>这里为什么要了解动画呢？是不是要构造一个游戏啊</strong>？</li>
</ul>
<blockquote>
<p>不会去构造游戏的，不过可能会创建一些对物体随着时间而改变的过程进行模拟，进而对此过程的结果加以展示，这样的一些模拟程序。或者会构建一个可视化工具，比如对图形进行更新，从而展示出某个程序当前所使用的内存数量，或者对经过负载均衡服务器的流量情况加以展示等等。那些需要取得持续变化数字集，且需要把这些数字翻译成，可从单纯的数字获取到有用信息的其他形式的应用，都可以用这样的程序来实现（You might not be making games, but you might be creating simulations, where things change over time to show the results of a process. Or you might be building a visualization tool that, for example, updates a graphic to show how much memeory a program is using, or to show you how much traffic is coming through your load-balance server. Anything that needs to take a set fo continuous-changing numbers and translate them into something useful for getting information out the numbers）。</p>
<p>上面讲到的那些应用情形，是不是听起来都是业务类的app啊？当然那只是“官方措辞”而已。这里之所以要涉及到动画，真正原因，就只是因为这个示例可以简单地验证内部类的另一种用法。（还因为这里只是喜欢动画，后面的一本书 <code>Head First J2EE</code>中，就直到把动画放在那里不合适，Doesn't that all sound business-like? That's just the &quot;offical justification&quot;, of course. The real reason we're covering it here is just because it's a simple way to demonstrate another use of inner class. (And because we just <em>like</em> animation, and our next Head First book is about J2EE and we <em>know</em> we can't get animation in that one.)）</p>
</blockquote>
<h3 id="这里真正需要的是"><a class="header" href="#这里真正需要的是">这里真正需要的是......</a></h3>
<pre><code class="language-java">class MyDrawPanel extends JPanel {
    public void paintComponent(Graphics g) {
        g.setColor(Color.orange);
        // 在每次调用到 paintComponent() 方法时，这个椭圆
        // 会在不同地点绘制出来
        g.fillOval(x, y, 100, 100);
    }
}
</code></pre>
<h3 id="小练习"><a class="header" href="#小练习">小练习</a></h3>
<p><strong>然而到底在哪里获取到新的 <code>x</code> 与 <code>y</code> 坐标呢</strong>？</p>
<p><strong>又该由谁来调用 <code>repaint()</code> 方法呢</strong>？</p>
<p>看看自己能不能 <strong>设计一个简单解决方案</strong>，来令到那个小球球从绘制面板的左上角，向下运动到右下角去。答案就在下面，所以在完成这个练习前不要往下偷看！</p>
<p>给一个大大的提示：把绘制面板，构造在内部内中。
另一个提示：在 <code>paintComponent()</code>方法中，不要放入仍和类别的重复循环。</p>
<p><strong>请将你的想法（或者代码）写下来</strong>：</p>
<h3 id="完整的简单动画代码"><a class="header" href="#完整的简单动画代码">完整的简单动画代码</a></h3>
<pre><code class="language-java">package com.xfoss.learningJava;

import javax.swing.*;
import java.awt.*;

public class SimpleAnimation {
    // 在GUI主类中构造两个实例变量，表示圆圈
    // 的 x 与 y 坐标
    int x = 20;
    int y = 20;

    public static void main (String[] args) {
        SimpleAnimation gui = new SimpleAnimation ();
        gui.go();
    }

    public void go () {
        // 这些都沿用以前的代码。构造小部件，然后
        // 把这些小部件放到视窗框中
        JFrame f = new JFrame(&quot;Java GUI简单动画示例：内部类的用法&quot; +
                &quot;之二，内部类与外层类不在同一继承树&quot;);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        DrawingPanel p = new DrawingPanel();
        f.getContentPane().add(BorderLayout.CENTER, p);

        f.setSize(640, 480);
        f.setVisible(true);

        // 这里就是运动发生的地方了！
        //
        // 重复了 260 次
        for (int i = 0; i &lt; 260; i++) {
            // 让 x 与 y 坐标逐次递增
            x += 2;
            y++;

            // 告诉绘制面板对自己进行重绘（因此就可以在
            // 新的位置看到那个圆圈）
            p.repaint();

            // 这里的代码让运动慢下来（否则圆圈就会移动过快，甚至看不出
            // 他是在移动了）。关于这里的 Thread 对象，并没有要求对其有
            // 了解，所以不必焦虑。在后面的第 15 章会学到有关线程的内容。
            try {
                Thread.sleep(50);
            } catch (Exception ex){}
        }
    }

    // 现在这就是个内部类了。
    class DrawingPanel extends JPanel {
        public void paintComponent(Graphics g) {
            g.setColor(Color.green);
            // 这里使用了外层类中持续更新的 x 与 y 坐标。
            g.fillOval(x, y, 40, 40);
        }
    }
}
</code></pre>
<p><img src="images/SimpleAnimation.gif" alt="SimpleAnimation GUI app 的运行效果" /></p>
<p><em>图 26 - <code>SimpleAnimation</code> GUI app 的运行效果</em></p>
<h3 id="喔那可不是在移动那是在涂抹"><a class="header" href="#喔那可不是在移动那是在涂抹">喔。那可不是在移动......那是在涂抹。</a></h3>
<p><strong>Uh-oh. It didn't move...it smeared</strong>.</p>
<p>到底在哪里搞错了呢？</p>
<p>这是因为在 <code>paintComponent()</code> 方法中有瑕疵的原因（There's one little flaw in the <code>paintComponent()</code> method）。</p>
<p><strong>上面的代码忘记了 <em>擦除</em> 已经有的圆圈了！因此看到的就是这些痕迹</strong>。</p>
<p>要修复这个问题，就必须使用背景颜色来填充整个面板。下面的代码在 <code>paintComponent()</code> 方法的开头加入了两行：一行把颜色设置为白色（绘制面板的背景色），同时另一行用那个颜色来填充整个面板。说人话就是，下面的代码讲了“从 <code>x</code> 与 <code>y</code> 坐标为 <code>0</code> （离左边 <code>0</code> 像素及离顶部 <code>0</code> 像素）开始填充一个矩形，并让这个矩形与当前面板同样宽同样高”。</p>
<pre><code class="language-java">public void paintComponent(Graphics g ) {
    g.setColor(Color.white);
    // 这里的 getWidth() 和 getHeight() 方法，是从 JPanel
    // 那里继承来的。
    g.fillRect(0, 0, this.getWidth(), this.getHeight());

    g.setColor(Color.green);
    g.fillOval(x, y, 20, 20);
}
</code></pre>
<p><img src="images/SimpleAnimation-beta.gif" alt="改进版的 SimpleAnimation: 消除涂抹的动画" /></p>
<p><em>图 27 - 改进版的 <code>SimpleAnimation</code>: 消除涂抹的动画</em></p>
<h2 id="代码厨房-1"><a class="header" href="#代码厨房-1">代码厨房</a></h2>
<p><strong>Code Kitchen</strong></p>
<p><img src="images/Ch12_27.png" alt="构造一个音乐视频的app" /></p>
<p><em>图 27 - 构造一个音乐视频的app</em></p>
<blockquote>
<p><strong>接下来会构造一个音乐视频的app。其中会运用到 Java 生成、与音乐节拍同步的随机图形</strong>。</p>
<p><strong>期间会注册（并收听）一种新类别的、由音乐自身所触发的非 GUI 事件（Along the way we'll register (and listen for) a new kind of non-GUI event, triggered by the music itself）</strong>。</p>
</blockquote>
<blockquote>
<p>请记住，这整个部分都是可选读的。不过这里认为过目一下对掌握 Java 颇有好处。并且会喜欢上整个部分的。可以用这里的 app 去打动别人。</p>
<p>（好吧，必然的，这个简单的app也就只能对那些容易被打动的人有效果，不过还是要......）</p>
</blockquote>
<h3 id="收听非gui事件"><a class="header" href="#收听非gui事件">收听非GUI事件</a></h3>
<p><strong>Listening for non-GUI event</strong></p>
<p>好吧，这或许并不是个音乐视频，不过这里将构造一个在屏幕上随着音乐节奏而绘制随机图形的程序。简而言之，程序将监听音乐的节拍，并在每一拍时绘制一个随机的矩形图形出来。</p>
<p>这种需求就带来了一些新问题。到目前为止，我们监听的都仅仅是GUI的事件，而现在就要监听一种特殊的MIDI事件了。结果证明，监听非 GUI 事件就跟监听GUI事件一样：无非是实现一个监听者接口，把这个监听者注册到某个事件源上，然后就静静等待事件源对你的事件处理器方法（就是在收听者接口中定义的方法）进行调用即可。</p>
<p>监听音乐节拍的最简单方式，差不多就是对具体MIDI事件进行注册和监听，这样的话无论音序器在什么时候获取到事件，代码都将同时获取到，进而就可以绘制图形。然而......仍然有个问题。实际上是个程序漏洞，这个漏洞不会让我们去监听那些 <em>正在构造</em> 的MIDI事件（就是那些 <code>NOTE ON</code> 的 MIDI事件，The simplest way to listen for the beat of the music would be to register and listen for the actual MIDI events, so that whenever the sequencer gets the event, our code will get it too and can draw the grphic. But... there's a problem. A bug, actually, that won't let us listen for the MIDI events <em>we're</em> making(the ones for <code>NOTE ON</code>)）。</p>
<p>因此这里就必须做一些折衷。仍有其他一些可以监听的 MIDI 事件，也就是 <code>ControllerEvent</code>。这里的解决办法就是对这些 <code>ControllerEvent</code> 事件进行注册，并随后确保对于每个 <code>NOTE ON</code>事件，都有一个与之匹配的 <code>ControllerEvent</code> 在同一 ‘拍’ 处发出。是怎样确保在同一时间有 <code>ControllerEvent</code> 事件发出的呢？这里是将 <code>ControllerEvent</code> 与其他事件一样，加入到音轨上的！也就是说，这里的音乐序列将会像下面这样：</p>
<pre><code class="language-console">BEAT 1 - NOTE ON, CONTROLLER EVENT
BEAT 2 - NOTE OFF
BEAT 3 - NOTE ON, CONTROLLER EVENT
BEAT 4 - NOTE OFF
</code></pre>
<p>如此等等。</p>
<p>在全部投入到完整程序之前，还是要想办法让程序构造起来容易一些，同时由于在这个程序中，将构造大量的 MIDI 报文/事件，因此要把有关 MIDI报文/事件的背景知识加入进来。</p>
<p><strong>这个音乐艺术程序需要做些什么</strong>：</p>
<ol>
<li>
<p>构造一系列在钢琴（或其他所选乐器）上演奏随机音符的 MIDI报文/事件；</p>
</li>
<li>
<p>为这些事件构造一个收听者；</p>
</li>
<li>
<p>启动音序器的播放；</p>
</li>
<li>
<p>在每次事件收听者的事件处理器方法被调用到时，在绘制面板上绘制一个随机的矩形，并调用 <code>repaint()</code> 方法。</p>
</li>
</ol>
<p><strong>这里将在三次迭代中构建出这个app</strong>：</p>
<ol>
<li>
<p>版本一：由于会构造大量的 MIDI事件出来，因此首先要编写用于简化构造和添加MIDI事件的代码；</p>
</li>
<li>
<p>版本二：对这些事件进行注册和监听，不过这个时候还没有图形。而是在命令行上打印出每个节拍的一条消息；</p>
</li>
<li>
<p>版本三：就是我们所要的app。给版本二加上图形。</p>
</li>
</ol>
<h2 id="构造报文事件的较容易方式"><a class="header" href="#构造报文事件的较容易方式">构造报文/事件的较容易方式</a></h2>
<p>此刻，MIDI 报文及事件的构造与添加到音轨，就变得索然无味了。对于每条MIDI报文，都不得不构造报文实例（在此示例中，也就是<code>ShortMessage</code>），接着调用 <code>setMessage()</code>，接着又要为这条报文构造一个 <code>MidiEvent</code>，并还要把这个事件添加到音轨上。在前一章的代码中，就曾贯穿了每条报文的这些步骤。那意味着仅仅一个音符的演奏和停止演奏，就需要多达八行的代码！其中四行用于添加 <code>NOTE ON</code> 事件，另外四行用于添加<code>NOTE OFF</code>事件。</p>
<pre><code class="language-java">ShortMessage a = new ShortMessage();
a.setMessage(144, 1, note, 100);
MidiEvent noteOn = new MidiEvent(a, 1);
track.add(noteOn);

ShortMessage b = new ShortMessage();
a.setMessage(128, 1, note, 100);
MidiEvent noteOff = new MidiEvent(b, 16);
track.add(noteOff);
</code></pre>
<p><strong>对于每个MIDI事件，都必须完成的事情</strong>：</p>
<ol>
<li>
<p>构造一个报文示例：</p>
<pre><code class="language-java">ShortMessage first = new ShortMessage();
</code></pre>
</li>
<li>
<p>以各种MIDI指令来调用 <code>setMessage()</code> 方法（Call <code>setMessage()</code> with the instructions）</p>
<pre><code class="language-java">first.setMessage(192, 1, instrument, 0);
</code></pre>
</li>
<li>
<p>给此报文构造一个 <code>MidiEvent</code> 事件</p>
<pre><code class="language-java">MidiEvent noteOn = new MidiEvent(first, 1);
</code></pre>
</li>
<li>
<p>将该事件添加到音轨上</p>
<pre><code class="language-java">track.add(notOn);
</code></pre>
</li>
</ol>
<p><strong>下面就来构建一个构造报文并返回一个 <code>MidiEvent</code> 对象的静态工具方法（Let's build a static utility method that makes a message and returns a <code>MidiEvent</code>）</strong></p>
<pre><code class="language-java">// 前四个参数用于报文
//
// 最后一个事件的 'tick' 表示报文应在什么时候出现
//
// 噢！有五个参数的方法呢。
public static MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
    MidiEvent event = null;

    try {
        // 这些语句使用方法的参数，构造出报文和事件
        ShortMessage a = new ShortMessage();
        a.setMessage(comd, chan, one, two);
        event = new MidiEvent(a, tick);
    } catch (Exception ex){}

    // 返回这个事件（一个已经加载好报文的 `MidiEvent` 对象）
    return event;
}
</code></pre>
<h3 id="示例如何使用这个新的静态-makeevent-方法"><a class="header" href="#示例如何使用这个新的静态-makeevent-方法">示例：如何使用这个新的静态 <code>makeEvent()</code> 方法</a></h3>
<p><strong>Example: how to use the new static <code>makeEvent()</code> method</strong></p>
<p>现在还不涉及到事件处理或图形，而仅有15个音符的规模。下面这段代码的要点，就是简单学习一下怎样运用这个新的 <code>makeEvent()</code> 方法。正是有了这个工具方法，后两版的代码才可以较小较简单。</p>
<pre><code class="language-java">package com.xfoss.learningJava;

// 不用忘了这个导入
import javax.sound.midi.*;

public class MiniMusicPlayer1 {
    public static void main (String[] args) {
        try {
            // 构造（并打开）一个音序器
            Sequencer s = MidiSystem.getSequencer();
            s.open();

            // 构造一个音序和音轨
            Sequence seq = new Sequence(Sequence.PPQ, 4);
            Track t = seq.createTrack();

            // 构造一堆产生一些持续升高音符（从钢琴的 5 号音符
            // 一直到 61 号音符）的事件
            for (int i = 5; i &lt; 61; i+=4){
                // 这里调用新的 makeEvent() 方法来构造MIDI报文
                // 与事件，并将结果（从 makeEvent() 方法返回
                // 的 MidiEvent 对象）添加到音轨上。这些都是
                // NOTE ON（144）和 NOTE OFF（128）事件对
                t.add(makeEvent(144, 1, i, 100, i));
                t.add(makeEvent(128, 1, i, 100, i + 2));
            } // 循环结束

            // 启动这个音序的运行
            s.setSequence(seq);
            s.setTempoInBPM(220);
            s.start();
        } catch (Exception ex){ex.printStackTrace();}
    } // main 函数结束

    public static MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {
        MidiEvent ev = null;

        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            ev = new MidiEvent(a, tick);
        } catch (Exception ex) {}

        return ev;
    }
} // 主类结束
</code></pre>
<h3 id="版本二对controllerevent事件进行注册与获取"><a class="header" href="#版本二对controllerevent事件进行注册与获取">版本二：对<code>ControllerEvent</code>事件进行注册与获取</a></h3>
<p><strong>Version Two: registering and getting <code>ControllerEvent</code>s</strong></p>
<pre><code class="language-java">package com.xfoss.learningJava;

import javax.sound.midi.*;

// 这里需要收听 ControllerEvent 事件，因此就要实现这个事件收听
// 者的接口
public class MiniMusicPlayer2 implements ControllerEventListener {
    public static void main (String[] args) {
        MiniMusicPlayer2 mini = new MiniMusicPlayer2();
        mini.go();
    }

    public void go () {
        try {
            Sequencer s = MidiSystem.getSequencer();
            s.open();

            // 对音序器上的这些事件进行注册。这个事件注册方法
            // 会取得事件收听者 以及 一个表示需要的 ControllerEvent
            // 事件代码清单。这里想要的只是编号 127 
            // 的 ControllerEvent
            int [] eventsIWant = {127};
            s.addControllerEventListener(this, eventsIWant);

            Sequence seq = new Sequence(Sequence.PPQ, 4);
            Track t = seq.createTrack();

            for (int i = 5; i &lt; 60; i+=4) {
                t.add(makeEvent(144, 1, i, 100, i));
                // 这里就是拾取节拍的方式 -- 以一个事件编号127 的参数，插入
                // 了 自己的 ControllerEvent
                // （代码 176 说的是事件类型为 ControllerEvent）。该事件
                // 什么也不会做！把这个事件放进去就 只是 为了在
                // 每次演奏一个音符时，可以获取到一个事件。也就是说，插入
                // 事件的唯一目的，就是发出一个可被监听到的事件（这里
                // 是无法监听到 NOTE ON/OFF 事件的）。请注意这里构造的这个
                // 事件，是和MIDI事件 NOTE ON 发生在同一节拍中的。因此在
                // NOTE ON 事件发生时，代码就能获悉到，因为这里插入的事件
                // 会在同样时间发生。
                t.add(makeEvent(176, 1, 127, 0, i));
                t.add(makeEvent(128, 1, i, 100, i + 2));
            } // 循环结束

            s.setSequence(seq);
            s.setTempoInBPM(220);
            s.start();
        } catch (Exception ex) {ex.printStackTrace();}
    } // main 方法结束

    // 这是事件处理器方法（来自 ControllerEvent 事件收听者接口）。在每次
    // 获取到上面的事件时，就会打印一个 ‘la’ 到命令行。
    public void controlChange (ShortMessage ev) {System.out.println(&quot;la&quot;);}

    public MidiEvent makeEvent (int comd, int chan, int one, int two, int tick) {
        MidiEvent ev = null;
        
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            ev = new MidiEvent(a, tick);
        } catch (Exception e) {}

        return ev;
    }
} // 主类结束
</code></pre>
<blockquote>
<p>请留意这段代码与前一版不同的地方。</p>
</blockquote>
<h3 id="第三版随音乐而绘制图形"><a class="header" href="#第三版随音乐而绘制图形">第三版：随音乐而绘制图形</a></h3>
<p><strong>Version Three: drawing graphics in time with the music</strong></p>
<p>该最终版本是在版本二的基础上，通过加入图形部分构建起来的。这里要构建一个视窗框，随后往视窗框添加一个绘制面板，从而在每次获取到一个事件时，就绘制一个新的矩形并重绘屏幕。此外的其他修改，就只是这里会随机地演奏音符，而不在是版本二中简单的升高音调。</p>
<p>代码中最重要的修改（除开构建要给简单的GUI外），就是这里要让绘制面板来实现 <code>ControllerEventListener</code> 接口，而不再是GUI主程序本身了。那么在绘制面板（一个内部类）获取到事件时，他就直到怎样通过绘制矩形，来管好自己。</p>
<p>此版本的完整代码在稍后一些。</p>
<p><strong>关于绘制面板这个内部类</strong>：</p>
<pre><code class="language-java">// 后面的 implements ControllerEventListener 表明该面板是个事件收听者
class DrawingPanel extends JPanel implements ControllerEventListener {
    // 这里设置了一个为 false 的标志，在收到一个事件时，就
    // 会把这个标志设置为 true
    boolean msg = false;

    public void controlChange(ShortMessage ev) {
        // 这里就收到了一个事件，因此就要把之前的标志
        // 设置为 true, 并调用 repaint() 方法
        msg = true;
        repaint();
    }

    public void paintComponent(Graphics g) {
        // 
        // 这里必须要使用一个标志变量，因为 别的 一些东西也可能会触发
        // repaint()，而这里只希望在有 ControllerEvent 才进行绘制
        //
        if (msg) {
            // 这些代码产生一种随机颜色，并绘制出一个一半大小的随机
            // 矩形
            Grahpics2D g2 = (Graphics2D) g;

            int r = (int) (Math.random() * 250);
            int gr = (int) (Math.random() * 250);
            int b = (int) (Math.random() * 250);

            g.setColor(new Color(r, gr, b));
            
            int ht = (int)(Math.random() * 120 + 10);
            int width = (int) (Math.random() * 120 + 10);
            int x = (int) (Math.random() * 40 + 10);
            int y = (int) (Math.random() * 40 + 10);
            
            g.fillRect(x, y, width, ht);
            msg = false;
        } // if 结束
    } // paintComponent() 方法结束
} // 内部类 DrawingPanel 结束
</code></pre>
<h3 id="小练习-1"><a class="header" href="#小练习-1">小练习</a></h3>
<blockquote>
<p>下面是版本三的全部代码。版本三是从版本二之上直接构建得来。现在可以试着不参考之前的注释，自己来添加注释。</p>
</blockquote>
<pre><code class="language-java">package com.xfoss.learningJava;

import javax.sound.midi.*;
import java.io.*;
import javax.swing.*;
import java.awt.*;

public class MiniMusicPlayer3 {
    static JFrame f = new JFrame(&quot;Java GUI示例: 内部类与监听非 GUI 事件&quot;);
    static DrawingPanel p;
    static int fWidth = 640;
    static int fHeight = 480;

    public static void main (String[] args) {
        MiniMusicPlayer3 mini = new MiniMusicPlayer3();
        mini.go();
    }

    public void setUpGui () {
        p = new DrawingPanel();
        f.setContentPane(p);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        f.setBounds(30, 30, fWidth, fHeight);
        f.setVisible(true);
    }

    public void go () {
        setUpGui();

        try {
            Sequencer s = MidiSystem.getSequencer();
            s.open();

            s.addControllerEventListener(p, new int[] {127});

            Sequence seq = new Sequence(Sequence.PPQ, 4);
            Track t = seq.createTrack();

            int r = 0;
            for (int i = 0; i &lt; 360; i+=4) {
                r = (int) (Math.random() * 50 + 1);

                t.add(makeEvent(144, 1, r, 100, i));
                t.add(makeEvent(176, 1, 127, 0, i));
                t.add(makeEvent(128, 1, r, 100, i + 2));
            }

            s.setSequence(seq);
            s.setTempoInBPM(220);
            s.start();
        } catch (Exception ex){ex.printStackTrace();}
    }

    public MidiEvent makeEvent (int comd, int chan, int one, int two, int tick) {
        MidiEvent ev = null;
        
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            ev = new MidiEvent(a, tick);
        } catch (Exception e) {}

        return ev;
    }

    class DrawingPanel extends JPanel implements ControllerEventListener {
        boolean msg = false;

        public void controlChange(ShortMessage ev) {
            msg = true;
            repaint();
        }

        public void paintComponent(Graphics g) {
            if (msg) {
                g.setColor(Color.white);
                g.fillRect(0, 0, this.getWidth(), this.getHeight());

                Graphics2D g2 = (Graphics2D) g;

                int r = (int) (Math.random() * 250);
                int gr = (int) (Math.random() * 250);
                int b = (int) (Math.random() * 250);

                g.setColor(new Color(r, gr, b));
                 
                int x = (int) (Math.random() * 40 + 10);
                int y = (int) (Math.random() * 40 + 10);
               
                int ht = (int)(Math.random() * fHeight / 2 + 10);
                int width = (int) (Math.random() * fWidth / 2 + 10);
                
                g.fillRect(x, y, width, ht);
                msg = false;
            }
        }
    }
}
</code></pre>
<p><img src="images/MiniMusicPlayer.gif" alt="Java GUI 内部类与非 GUI 事件的监听：MiniMusicPlayer 完成效果" /></p>
<p><em>图 28 - Java GUI 内部类与非 GUI 事件的监听：<code>MiniMusicPlayer</code> 完成效果</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运用-swing-在-swing-上工作"><a class="header" href="#运用-swing-在-swing-上工作">运用 <code>Swing</code>: 在 <code>Swing</code> 上工作</a></h1>
<p><strong>Using <code>Swing</code>: Work on Your <code>Swing</code></strong></p>
<p><img src="images/Ch13_01.png" alt="运用 Swing: 在 Swing 上做事：题图" /></p>
<p><em>图 1 - 运用 <code>Swing</code>: 在 <code>Swing</code> 上做事：题图</em></p>
<p><strong><code>Swing</code> 很简单</strong>。除非真的关心物件最终在屏幕上所处位置（<strong><code>Swing</code> is easy</strong>. Unless you actually <em>care</em> where things end up on the screen）。<code>Swing</code> 代码 <em>看起来</em> 不难，但在对其进行编译、运行，最后看到其效果时，就会想，“嘿，那东西可不应该在那儿呀。” 正是那些让 <code>Swing</code> 代码写起来容易的因素，使得<code>Swing</code>难于掌控 -- 那就是<strong>布局管理器（Layout Manager）</strong>。布局管理器的那些对象，控制着 Java GUI 中众多小部件的大小与位置。布局管理器替我们干了许许多多的事情，然而结果却并不会总是让我们满意。在想要两同样大小的按钮时，得到的两个按钮并不一样大。在希望文本字段的长度为三英寸时，会得到九英寸长的文本字段。要不就只有一英寸长。希望这个文本字段在标签部件旁边，得到的却是在便签部件下边。但只需稍加努力，就可以让布局管理器服从咱们的意愿。在这一章中，就要在 <code>Swing</code> 上下功夫，且除了布局管理器外，还会学到更多的 GUI 小部件。这里会构造处他们，让后把他们显示出来（在选定的区域），进而在程序中运用他们。</p>
<h2 id="关于swing-的那些组件"><a class="header" href="#关于swing-的那些组件">关于<code>Swing</code> 的那些组件</a></h2>
<p><strong><code>Swing</code> components</strong></p>
<p>对于先前一直讲的小部件（<em>widget</em>），其实更准确的叫法应该是<em><strong>组件（Component）</strong></em>。就是那些放到GUI中的 <em>物件（things）</em>。也即是 <em>用户所见到并与之交互的那些东西</em>。文本字段、按钮、滚动清单、单选按钮等等，这些全都是组件。事实上他们都扩展了 <code>javax.swing.JComponent</code>类。</p>
<blockquote>
<p><strong>小部件从技术上讲就是 <code>Swing</code> 组件。几乎所有可吸附在 GUI 中的东西，都扩展自 <code>javax.swing.JComponent</code> 类</strong>。</p>
</blockquote>
<h3 id="组件可以嵌套"><a class="header" href="#组件可以嵌套">组件可以嵌套</a></h3>
<p><strong>Components can be nested</strong></p>
<p>在 <code>Swing</code> 中，差不多 <em>所有</em> 组件都具备驻留其他组件的能力（In <code>Swing</code>, virtually <em>all</em> components are capable of holding other components）。也就是说，<em>几近能够把任意组件都吸附到其他任意组件中</em>。然而在大多数时候，都只会把 <em>用户界面</em> 的那些组件，比如按钮与清单，添加到一些 <em>背景</em> 组件，比如视窗框及面板等中去。不过将比如面板放到按钮中，也是 <em>有可能</em> 的，这只是有些奇怪，同时也不会带来任何可用性上的增强。</p>
<p>除开 <code>JFrame</code> 这个例外，其他的 <em>交互性（interactive）</em> 组件与 <em>背景（background）</em>  组件之间的区别，就是有意为之的了。而比如说对于 <code>JPanel</code>，则常常被用作目的为组织其他组件的背景，但即便是 <code>JPanel</code>，仍然可以是交互性的。就跟其他组件一样，也可以对<code>JPanel</code>的那些事件，比如鼠标点击和键盘按键等进行注册。</p>
<p><strong>构造GUI的四个步骤（复习）</strong>：</p>
<ol>
<li>
<p>构造一个视窗（一个 <code>JFrame</code>）</p>
<pre><code class="language-java">JFrame frame = new JFrame(&quot;新视窗&quot;);
</code></pre>
</li>
<li>
<p>构造一个组件（按钮、文本字段等等）</p>
<pre><code class="language-java">JButton button = new JButton(&quot;点我&quot;);
</code></pre>
</li>
<li>
<p>将这个组件添加到这个视窗框</p>
<pre><code class="language-java">frame.getContentPane().add(BorderLayout.EAST, button);
</code></pre>
</li>
<li>
<p>把他显示出来（给到视窗框一个大小，并令其可见）</p>
<pre><code class="language-java">frame.setSize(300, 300);
frame.setVisible(true);
</code></pre>
<p><img src="images/Ch13_02.png" alt="构造Java GUI 的步骤" /></p>
<p><em>图 2 - 构造Java GUI 的步骤</em></p>
</li>
</ol>
<h2 id="关于布局管理器"><a class="header" href="#关于布局管理器">关于布局管理器</a></h2>
<p><strong>Layout Managers</strong></p>
<p>布局管理器是与几乎总是 <em>背景</em> 组件的特定组件，联系在一起的Java 对象。布局管理器控制着包含在与其联系在一起组件中的那些组件（A layout manager is a Java object associated with a particular component, almost always a <em>background</em> component. The layout manager controls the components contained <em>within</em> the component the layout manager is associated with）。也就是说，在某个视窗框驻留了一个面板，同时那个面板又驻留着一个按钮时，那么面板的布局管理器就控制着按钮的大小和放置方式，而视窗框的布局管理器，则控制着面板的大小与放置方式。而这里的按钮，则与视窗框和面板不同，就不需要布局管理器，因为他并没有驻留其他组件。</p>
<p><img src="images/Ch13_04.png" alt="关于布局管理器" /></p>
<p><em>图 4 - 关于布局管理器</em></p>
<p>在某个面板驻留了五个物件时，即便这五个物件都有着他们各自的布局管理器，这五个物件的大小与位置，仍是由这个面板的布局管理器控制的。在面板的五个物件依次又包含 <em>其他</em> 物件时，那么这些 <em>其他</em> 物件，就会根据驻留他们的物件布局管理器，来摆放。</p>
<p>在提及 <em>驻留</em>（<em>hold</em>） 时，其实就是 <em>添加</em>（<em>add</em>） 的意思，就比如“由于使用了下面的语句，从而某个按钮被添加到了某个面板，因此就说某个面板 <em>驻留</em> 着一个按钮”：</p>
<pre><code class="language-java">myPanel.add(button);
</code></pre>
<p>布局管理器有着数种样式，同时各个背景组件可以有着各自的布局管理器。在构建某种布局时，布局管理器有着他们各自要遵循的策略（Layout managers come in several flavors, and each background component can have its own layout manager. Layout managers have their own policies to follow when building a layout）。比如，一直布局管理器就会坚持让面板中的各个组件保持大小一致，并以网格方式进行排布；而另一种则会让这些面板中的各个组件选择他自己的大小，却是纵向堆叠起来的。下面就是一个嵌套式布局的示例：</p>
<pre><code class="language-java">JPanel panelA = new JPanel();
JPanel panelB = new JPanel();

panelB.add(new JButton(&quot;按钮1&quot;));
panelB.add(new JButton(&quot;按钮2&quot;));
panelB.add(new JButton(&quot;按钮3&quot;));

panelA.add(panelB);
</code></pre>
<p><img src="images/Ch13_03.png" alt="组件嵌套及其布局管理器作用范围" /></p>
<p><em>图 3 - 组件嵌套及其布局管理器作用范围</em></p>
<h2 id="布局管理器的决策依据"><a class="header" href="#布局管理器的决策依据">布局管理器的决策依据</a></h2>
<p><strong>How does the layout manager decide</strong>?</p>
<p>不同布局管理器有着不同的排布组件策略（比如以网格形式排布、令到各个组件大小相同，或者纵向堆叠等等）。不过这些正被排布的组件，在排布策略上，也是有着一些小小的发言权的。一般来讲，对某个背景组件的布局过程，差不多就是下面这样的：</p>
<p><strong>一个布局场景</strong>：</p>
<ol>
<li>
<p>构造一个面板并把三个按钮添加给他；</p>
</li>
<li>
<p>面板的布局管理器询问各个按钮，他们各自想要多大（The panel's layout manager asks each button how big that button prefers to be）；</p>
</li>
<li>
<p>面板的布局管理器运用其策略来判定是否需要全部、部分还是完全不依照这些按钮的诉求；</p>
</li>
<li>
<p>把面板添加到视窗框；</p>
</li>
<li>
<p>视窗框的布局管理器询问面板想要多大；</p>
</li>
<li>
<p>视窗框的布局管理器运用他的布局策略，来判定是否需要全部、部分还是完全不依照面板的诉求。</p>
</li>
</ol>
<p><img src="images/Ch13_05.png" alt="布局管理器的运作方式" /></p>
<p><em>图 5 - 布局管理器的运作方式</em></p>
<h3 id="不同布局管理器有着不同策略"><a class="header" href="#不同布局管理器有着不同策略">不同布局管理器有着不同策略</a></h3>
<p><strong>Different layout managers have different policies</strong></p>
<p>一些布局管理器会依照所布局组件想要的大小。比如有按钮想要 30 像素 x 50 像素大小，那么这就是布局管理器分配给他的大小。另一些布局管理器则只会部分依照所布局组件的首选大小。比如有按钮想要 30 像素 x 50 像素时，该按钮将会是 30 像素高，而宽度则会与其背景 <em>面板</em> 的宽度相同。还有其他一些布局管理器，只会参考所布局组件中 <em>最大的</em> 那个，并令到面板中的其余组件与最大的那个同样大小。某些情况下，布局管理器的工作会变得极度复杂，而大多数时候，只有在了解了布局管理器的策略时，才能搞清楚那个布局管理器将做些什么（In some cases, the work of the layout manager can get very complex, but most of the time you can figure out what the layout manager will probably do, once you get to know that layout manager's policies）。</p>
<h2 id="三大布局管理器边框流与盒子"><a class="header" href="#三大布局管理器边框流与盒子">三大布局管理器：边框、流与盒子</a></h2>
<p><strong>The Big Three layout managers: border, flow and box</strong></p>
<h3 id="borderlayout"><a class="header" href="#borderlayout"><code>BorderLayout</code></a></h3>
<p><code>BorderLayout</code> 管理器将背景组件划分为五个区域。对于每个区域，仅可添加一个组件到由一个<code>BorderLayer</code>管理器控制的背景。由此管理器排布的组件，通常不会有他们所选的大小。<strong><code>BorderLayout</code> 是视窗框默认的布局管理器</strong>！（A <code>BorderLayout</code> manager divides a background component into five regions. You can add only one component per region to a background controlled by a <code>BorderLayout</code> manager. Components laid out by this manager usually don't get to have their prefered size. <strong><code>BorderLayout</code> is the default layout manager for a frame</strong>!）</p>
<p><img src="images/Ch13_06.png" alt="BorderLayout 布局管理器图示" /></p>
<p><em>图 6 - <code>BorderLayout</code> 布局管理器图示</em></p>
<h3 id="flowlayout"><a class="header" href="#flowlayout"><code>FlowLayout</code></a></h3>
<p><code>FlowLayout</code> 管理器的行事方式，就好比文字处理器，不同之处就在于他处理的是组件，而不是文字处理器中的单词。每个组件都有他想要的大小，同时这些组件按照添加的先后顺序，从左到右排列起来，期间还开启了“自动换行”。因此在出现放不下某个组件的情况时，这个组件就会自动落到布局的下一“行”去。<strong><code>FlowLayout</code>是面板的默认布局管理器</strong>！</p>
<p><img src="images/Ch13_07.png" alt="FlowLayout布局管理器的图示" /></p>
<p><em>图 7 - <code>FlowLayout</code>布局管理器的图示</em></p>
<h3 id="boxlayout"><a class="header" href="#boxlayout"><code>BoxLayout</code></a></h3>
<p><code>BoxLayout</code> 管理器与 <code>FlowLayout</code> 类似的地方在于，各个组件都会获得自己想要的大小，组件按照添加的先后顺序放置。与 <code>FlowLayout</code> 的不同之处在于，<code>BoxLayout</code>管理器可将所布局的组件，进行竖直方向上的堆叠（或水平方向，不过通常只关心竖直方向）。<code>BoxLayout</code>与<code>FlowLayout</code>相似，不过与 <code>FlowLayout</code>的自动&quot;组件换行&quot;不同，可以插入某种程度上称之为“组件回车键”的东西，然后 <strong>强制</strong> 组件开启新行（It's like a <code>FlowLayout</code> but instead of having automatic 'component wrapping', you can insert a sort of 'component return key' and <strong>force</strong> the components to start a new line）。</p>
<p><img src="images/Ch13_08.png" alt="BoxLayout 布局管理器图示" /></p>
<p><em>图 8 - <code>BoxLayout</code> 布局管理器图示</em></p>
<h3 id="borderlayout关注五个区域东西南北中"><a class="header" href="#borderlayout关注五个区域东西南北中"><code>BorderLayout</code>关注五个区域：东西南北中</a></h3>
<p><strong><code>BorderLayout</code> cares about five regions: east, west, north, south, and center</strong></p>
<p><strong>下面把一个按钮添加到东部区域</strong>：</p>
<pre><code class="language-java">package com.xfoss.learningJava;

import javax.swing.*;
// BorderLayout 是在 java.awt 包里头的
import java.awt.*;

public class Button1 {
    public static void main (String[] args) {
        Button1 gui = new Button1 ();
        gui.go();
    }

    public void go () {
        JFrame f = new JFrame (&quot;BorderLayout 示例：一个放在东部区域的按钮&quot;);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        JButton btn = new JButton (&quot;点我&quot;);

        // 这行语句就指定了放置区域
        f.getContentPane().add(BorderLayout.EAST, btn);
        f.setSize(640, 480);
        f.setVisible(true);
    }
}
</code></pre>
<p><img src="images/Ch13_09.png" alt="BorderLayout 示例一：把一个按钮放在东部区域" /></p>
<p><em>图 9 - <code>BorderLayout</code> 示例一：把一个按钮放在东部区域</em></p>
<h3 id="脑力锻炼-1"><a class="header" href="#脑力锻炼-1">脑力锻炼</a></h3>
<ul>
<li>
<p><code>BorderLayout</code> 管理器是怎样判定按钮的大小的（How did the <code>BorderLayout</code> manager come up with this size for the button）?</p>
</li>
<li>
<p>此布局管理器考虑了哪些因素（What are the factors the layout manager has to consider）？</p>
</li>
<li>
<p>这个按钮为什么没有更宽或更高（Why isn't it wider or taller）？</p>
</li>
</ul>
<h3 id="观察一下在给到按钮更多字符时会发生什么"><a class="header" href="#观察一下在给到按钮更多字符时会发生什么">观察一下在给到按钮更多字符时会发生什么......</a></h3>
<p><strong>Watch what happens when we give the button more characters...</strong></p>
<pre><code class="language-java">public void go () {
    JFrame f = new JFrame (&quot;BorderLayout 示例：一个放在东部区域的按钮&quot;);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    // 这里只修改了按钮上的文本
    JButton btn = new JButton (&quot;因为你愿意所以点我，表示确定你真的要点我&quot;);

    f.getContentPane().add(BorderLayout.EAST, btn);
    f.setSize(640, 480);
    f.setVisible(true);
}
</code></pre>
<p><img src="images/Ch13_10.png" alt="BorderLayout 管理器判定所布局组件大小影响因素测试" /></p>
<p><em>图 10 - <code>BorderLayout</code> 管理器判定所布局组件大小影响因素测试</em></p>
<ul>
<li><strong><code>BorderLayout</code> manager</strong>: 首先，我会询问按钮他自己喜好的大小。</li>
<li><strong><code>Button</code> 对象</strong>：现在我有了很多个字，那么我就倾向于要60像素宽，25像素高。</li>
<li><strong><code>BorderLayout</code> manager</strong>: 由于按钮是在边框布局的东部区域，那么我就会依照他所选的宽度。但是我不会关心他有多高；这个按钮将会与视窗框一样高，因为这是我的策略。</li>
<li><strong><code>Button</code> 对象</strong>：<code>：（</code> 下次就就要和 <code>FlowLayout</code> 在一起，那样的话我就会得到想要的一切了。</li>
</ul>
<p><strong>再试试把按钮放在北部区域</strong>：</p>
<p><strong>Let's try a button in the NORTH region</strong></p>
<pre><code class="language-java">public void go () {
    JFrame f = new JFrame (&quot;BorderLayout 示例：放在北部区域的按钮&quot;);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    JButton btn = new JButton (&quot;因为你愿意所以点我，表示确定你真的要点我&quot;);

    // 注意这里的 NORTH
    f.getContentPane().add(BorderLayout.NORTH, btn);
    f.setSize(640, 480);
    f.setVisible(true);
}
</code></pre>
<p><img src="images/Ch13_11.png" alt="BorderLayout 布局：把按钮放在北部区域" /></p>
<p><em>图 11 - <code>BorderLayout</code> 布局：把按钮放在北部区域</em></p>
<p><strong>现在让按钮去请求要 <em>更高一些</em></strong></p>
<p><strong>Now let's make the button ask to be <em>taller</em></strong></p>
<blockquote>
<p>该怎样实现呢？按钮已经尽可能的宽了 -- 跟视窗框一样宽。不过还是可以通过给与他内部文字更大的字体，来令到按钮更高一些。</p>
</blockquote>
<pre><code class="language-java">public void go () {
    JFrame f = new JFrame (&quot;BorderLayout 示例：通过Button类的setFont()，让按钮变得更高&quot;);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    JButton btn = new JButton (&quot;因为你愿意所以点我，表示确定你真的要点我&quot;);
    // 较大的字体，就会强制视窗框给按钮高度分配更多空间
    Font bigFont = new Font(&quot;STXingkai&quot;, Font.BOLD, 32);
    btn.setFont(bigFont);

    f.getContentPane().add(BorderLayout.NORTH, btn);
    f.setSize(640, 480);
    f.setVisible(true);
}
</code></pre>
<p><img src="images/Ch13_12.png" alt="BorderLayout管理器：通过运用Button类的setFont()方法，让按钮变得更高" /></p>
<p><em>图 12 - <code>BorderLayout</code>管理器：通过运用<code>Button</code>类的<code>setFont()</code>方法，让按钮变得更高</em></p>
<blockquote>
<p>宽度仍保持不变，但现在的按钮更高了。北部的那个区域被拉伸，以适配按钮新的优先高度（The north region stretched to accomodate the button's new preferred height）。</p>
</blockquote>
<p><img src="images/Ch13_13.png" alt="BorderLayout 管理器" /></p>
<p><em>图 13 - <code>BorderLayout</code> 管理器</em></p>
<p><strong>中部区域得到了剩下的空间</strong>！</p>
<p>（除了一种稍后会看到的特殊情况）</p>
<p><strong>The center region gets whatever's left</strong>!</p>
<p>(except in one special case we'll look later)</p>
<pre><code class="language-java">public void go () {
    JFrame f = new JFrame (&quot;BorderLayout 示例：关于中部区域&quot;);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    JButton btnEast = new JButton (&quot;东部&quot;);
    JButton btnWest = new JButton (&quot;西部&quot;);
    JButton btnNorth = new JButton (&quot;北部&quot;);
    JButton btnSouth = new JButton (&quot;南部&quot;);
    JButton btnCenter = new JButton (&quot;中央&quot;);

    f.getContentPane().add(BorderLayout.EAST, btnEast);
    f.getContentPane().add(BorderLayout.WEST, btnWest);
    f.getContentPane().add(BorderLayout.NORTH, btnNorth);
    f.getContentPane().add(BorderLayout.SOUTH, btnSouth);
    f.getContentPane().add(BorderLayout.CENTER, btnCenter);

    f.setSize(640, 480);
    f.setVisible(true);
}
</code></pre>
<p><img src="images/Ch13_14.png" alt="BorderLayout 管理器：关于中央区域" /></p>
<p><em>图 14 - <code>BorderLayout</code> 管理器：关于中央区域（Windows 10）</em></p>
<p><img src="images/Ch13_15.png" alt="上面的代码运行在 Ubuntu 20.04 LTS中的输出" /></p>
<p><em>图 15 - <code>BorderLayout</code> 管理器：关于中央区域（Ubuntu 20.04 LTS）</em></p>
<blockquote>
<p>在把物件放入到北部或南部区域时，物件就会占据整个视窗框的宽度，这样的话东部和西部的物件，就不会有原来北部和南部区域空着的时候那么高了。</p>
<p>基于视窗框大小（这段代码就是 300 x 300 像素点），中央区域中的那些组件，获得剩下的那些空间。</p>
<p>东部与西部区域的那些组件，将得到他们所选的宽度。</p>
<p>北部与南部区域的组件，得到他们选定的高度。</p>
</blockquote>
<h3 id="flowlayout-关心的是组件流自左往右自上往下以组件添加的顺序一一排布"><a class="header" href="#flowlayout-关心的是组件流自左往右自上往下以组件添加的顺序一一排布"><code>FlowLayout</code> 关心的是组件流：自左往右、自上往下，以组件添加的顺序一一排布</a></h3>
<p><strong><code>FlowLayout</code> cares about the flow of the components: left to right, top to bottom, in the order they were added</strong>.</p>
<p><strong>将一个面板添加到东部区域</strong>：</p>
<p><code>JPanel</code>的布局管理器默认是 <code>FlowLayout</code>。在将面板添加到视窗框时，面板的大小和放置方式，仍然受 <code>BorderLayout</code> 管理的控制。不过 <em>面板内部</em> 的所有东西（也就是通过调用 <code>panel.add(aComponent)</code>添加到面板的那些组件），则是受 <code>FlowLayout</code> 管理器的控制了。这里将从放入一个面板到视窗框东部区域中开始，后面就会把物件添加到面板。</p>
<pre><code class="language-java">package com.xfoss.learningJava;

import javax.swing.*;
import java.awt.*;

public class Panel1 {
    public static void main (String[] args) {
        Panel1 gui = new Panel1();
        gui.go();
    }

    public void go () {
        JFrame f = new JFrame(&quot;FlowLayout 管理器：从添加一个面板到视窗框的东部区域开始&quot;);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JPanel p = new JPanel();
        // 这里把面板做成灰色，从而可以看到面板在视窗框的哪里
        p.setBackground(Color.darkGray);
        
        f.getContentPane().add(BorderLayout.EAST, p);
        f.setSize(640, 480);
        f.setVisible(true);
    }
}
</code></pre>
<p><img src="images/Ch13_16.png" alt="FlowLayout 管理器：从把一个面板添加到视窗框的东部区域开始" /></p>
<p><em>图 16 - <code>FlowLayout</code> 管理器：从把一个面板添加到视窗框的东部区域开始</em></p>
<p><strong>把一个按钮添加到面板</strong>：</p>
<pre><code class="language-java">public void go () {
    JFrame f = new JFrame(&quot;FlowLayout 管理器：添加一个按钮到面板&quot;);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    JPanel p = new JPanel();
    p.setBackground(Color.darkGray);

    JButton btn = new JButton(&quot;吓我一跳！&quot;);
    
    // 把按钮添加到面板，并把面板添加到视窗框。面板的布局
    // 管理器（FlowLayout）控制着按钮，而视窗框的布局管理
    // 器（BorderLayout）控制着面板。
    p.add(btn);
    f.getContentPane().add(BorderLayout.EAST, p);

    f.setSize(640, 480);
    f.setVisible(true);
}
</code></pre>
<p><img src="images/Ch13_17.png" alt="FlowLayout 管理器：再添加一个按钮到面板里" /></p>
<p><em>图 17 - <code>FlowLayout</code> 管理器：再添加一个按钮到面板里</em></p>
<blockquote>
<p>这时面板变宽了！而由于面板使用的流布局，从而按钮同时得到了他的宽度与高度，还有按钮是面板（而非视窗框）的组成部分。</p>
</blockquote>
<p><img src="images/Ch13_18.png" alt="BorderLayout 与 FlowLayout" /></p>
<p><em>图 18 - <code>BorderLayout</code> 与 <code>FlowLayout</code></em></p>
<p><strong>把两个按钮添加到面板，会怎样呢？</strong></p>
<pre><code class="language-java">public void go () {
    JFrame f = new JFrame(&quot;FlowLayout 管理器：添加两个按钮到面板&quot;);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    JPanel p = new JPanel();
    p.setBackground(Color.darkGray);

    // 这里构造两个按钮
    JButton btn = new JButton(&quot;吓我一跳！&quot;);
    JButton btnTwo = new JButton(&quot;祈福&quot;);
    //把这两个按钮都添加到面板
    p.add(btn);
    p.add(btnTwo);
    
    f.getContentPane().add(BorderLayout.EAST, p);
    f.setSize(640, 480);
    f.setVisible(true);
}
</code></pre>
<p><img src="images/Ch13_19.png" alt="FlowLayout 管理器：添加两个按钮" /></p>
<p><em>图 19 - <code>FlowLayout</code> 管理器：添加两个按钮</em></p>
<blockquote>
<p>这里想要的是这两个按钮堆叠起来。</p>
<p>然而面板为适应这两个并排起来，而再次变宽了。</p>
<p>注意这里的“祈福”按钮要比“吓我一跳！”按钮要小一些......那就是流式布局运作的方式了。按钮只会获得他所需的大小（而没有多余的空间）。</p>
</blockquote>
<h3 id="小练习-2"><a class="header" href="#小练习-2">小练习</a></h3>
<p>在把上面的代码修改为：</p>
<pre><code class="language-java">public void go () {
    JFrame f = new JFrame(&quot;FlowLayout 管理器：添加两个按钮到面板&quot;);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    JPanel p = new JPanel();
    p.setBackground(Color.darkGray);

    JButton btn = new JButton(&quot;吓我一跳！&quot;);
    JButton btnTwo = new JButton(&quot;祈福&quot;);
    JButton btnThree = new JButton(&quot;哈？！&quot;);
    p.add(btn);
    p.add(btnTwo);
    p.add(btnThree);
    
    f.getContentPane().add(BorderLayout.EAST, p);
    f.setSize(640, 480);
    f.setVisible(true);
}
</code></pre>
<p>后，得到的窗口如下所示：</p>
<p><img src="images/Ch13_20.png" alt="三个按钮的情形" /></p>
<p><em>图 20 - 三个按钮的情形</em></p>
<p><strong>添加 50 个按钮到面板的情况</strong>：</p>
<pre><code class="language-java">public void go () {
    JFrame f = new JFrame(&quot;FlowLayout 管理器：添加 50 个按钮到面板&quot;);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    JPanel p = new JPanel();
    p.setBackground(Color.darkGray);

    for (int t = 0; t &lt; 50; t++) {
        JButton btn = new JButton(String.format(&quot;按钮 - %s&quot;, t));
        p.add(btn);
    }
    
    f.getContentPane().add(BorderLayout.EAST, p);
    f.setSize(640, 480);
    f.setVisible(true);
}
</code></pre>
<p><img src="images/Ch13_21.png" alt="添加 50 个按钮到面板" /></p>
<p><em>图 21 - 添加 50 个按钮到面板</em></p>
<blockquote>
<p>注：这个例子可以看出，<code>FlowLayout</code> 只是单纯的从左往右一一排布他所布局的组件。暂时并未“自动换行”。</p>
</blockquote>
<p>但若把 <code>f.getContentPane().add(BorderLayout.EAST, p)</code> 改为 <code>f.getContentPane().add(BorderLayout.CENTER, p)</code>，就会得到：</p>
<p><img src="images/Ch13_21-1.png" alt="FlowLayout 管理器下的自动换行" /></p>
<p><em>图 21-1 <code>FlowLayout</code> 管理器下的自动换行</em></p>
<h3 id="boxlayout来补救"><a class="header" href="#boxlayout来补救"><code>BoxLayout</code>来补救！</a></h3>
<p><strong>就是有空间来让他所布局的那些组件挨着一一放置，<code>BoxLayout</code>仍会让这些组件堆叠起来</strong>。</p>
<p><strong><code>BoxLayout</code> to the rescue</strong>!</p>
<p><strong>It keeps components stacked, event if there's room to put them side by side</strong>.</p>
<p><strong>与 <code>FlowLayout</code> 不同，就算仍有空间来在水平方向上摆放组件，<code>BoxLayout</code> 仍可强制一个 &quot;新行&quot;， 来令到组件换到下一行去</strong>。</p>
<p><strong>Unlike <code>FlowLayout</code>, <code>BoxLayout</code> can force a 'new line' to make the components wrap to the next line, even if there's room for them to fit horizontally</strong>.</p>
<p>不过现在就必须把面板的布局管理器从 <code>FlowLayout</code> 修改为 <code>BoxLayout</code>。</p>
<pre><code class="language-java">public void go () {
    JFrame f = new JFrame(&quot;BoxLayout 管理器：把面板的布局管理器从默认的 FlowLayout 修改为 BoxLayout&quot;);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    JPanel p = new JPanel();
    p.setBackground(Color.darkGray);
    
    // 把布局管理器修改为 BoxLayout 的一个新实例
    //
    // BoxLayout 的构造器，需要知道他要布局的组件（即这个面板）
    // 以及使用哪个轴（这里使用垂直堆叠的 Y_AXIS ）
    p.setLayout(new BoxLayout(p, BoxLayout.Y_AXIS));

    JButton btn = new JButton (&quot;吓我一跳！&quot;);
    JButton btnTwo = new JButton (&quot;祈福&quot;);
    p.add(btn);
    p.add(btnTwo);
    
    f.getContentPane().add(BorderLayout.EAST, p);
    f.setSize(640, 480);
    f.setVisible(true);
}
</code></pre>
<p><img src="images/Ch13_22.png" alt="BoxLayout管理器：修改面板的布局管理器为 BoxLayout" /></p>
<p><em>图 22 - <code>BoxLayout</code>管理器：修改面板的布局管理器为 <code>BoxLayout</code></em></p>
<blockquote>
<p>请留意因为面板现在不需要去适应水平方向上并排的两个按钮，所以他又变窄了。那么面板就告诉视窗框，他只需要那个最大的“吓我一跳！”按钮大小的空间。</p>
</blockquote>
<h2 id="答疑-13"><a class="header" href="#答疑-13">答疑</a></h2>
<ul>
<li><strong>怎么不直接把交互性组件（比如这里的按钮），像添加到面板上那样，直接添加到视窗框呢</strong>？</li>
</ul>
<blockquote>
<p>由于在将物件呈现在屏幕上的过程中，到<code>JFrame</code>这里，属于至关重要的节点，因此 <code>JFrame</code> 具有特殊性。与所有<code>Swing</code>组件都是纯 Java 代码不同之处在于，为了访问到显示器，<code>JFrame</code>就必须要去与底层 OS 系统连接起来。可把内容窗格当作一个处于 <code>JFrame</code> 之上的 100% 纯 Java 层。或者在把 <code>JFrame</code> 当作窗框的时候，把内容窗格当作......窗户玻璃。知道窗户的窗格把。还甚至可以用 <code>JPanel</code> 去与内容窗格互换，来将自己的 <code>JPanel</code> 作为视窗框的内容窗格，这样写就可以（A <code>JFrame</code> is special because it's where the rubber meets the road in making something appear on the screen. While all your <code>Swing</code> components are pure Java, a <code>JFrame</code> has to connect to the underlying OS in order to access the display. Think of the content pane as a 100% pure Java layer that sits on <em>top</em> of the <code>JFrame</code>. Or think of it as though <code>JFrame</code> is the window frame and the content pane is the...glass. You know, the window <em>pane</em>. And you can even swap the content pane with your own <code>JPanel</code>, to make your <code>JPanel</code> the frame's content pane）：</p>
</blockquote>
<pre><code class="language-java">myFrame.setContentPane(myPanel);
</code></pre>
<ul>
<li><strong>可以修改视窗框的布局管理器吗？我想要在视窗框上使用流式布局，而不是默认的边框布局，会怎样呢</strong>？</li>
</ul>
<blockquote>
<p>要实现这些，最简单的办法，就是构造一个面板，在这个面板中按照想要的样子去构建GUI，然后运用上一个答案中的方法，把这个面板设置为视窗框的内容窗格（就不会用到视窗框的默认内容窗格了）。</p>
</blockquote>
<ul>
<li><strong>对于这些添加到布局组件（视窗框、面板）上的交互性组件，若需要不同的所选大小，该怎样做呢？交互性组件有 <code>setSize()</code>方法吗</strong>？</li>
</ul>
<blockquote>
<p>是的，交互性小部件是有这个 <code>setSize()</code> 方法的，然而布局管理器只会忽视之。组件的 <em>优先大小（preferred size）</em> 与我们想要的大小，二者之间是有差异的。优先大小（preferred size）基于组件实际 <em>所需</em> 的大小（由组件自己决断）。布局管理器调用的是组件的 <code>getPreferredSize()</code> 方法，而这个方法并不会去理会那个先前在组件上调用的 <code>setSize()</code>方法。</p>
</blockquote>
<ul>
<li><strong>就不能把物件放在自己想要地方吗？可以把布局管理器关掉吗</strong>？</li>
</ul>
<blockquote>
<p>当然可以。基于单个的布局组件，是可以调用 <code>setLayout(null)</code> 方法的，随后就由自己去把确切的屏幕位置坐标进行硬编码吧。长远来看，还是使用布局管理器更容易一点（Yep. On a component by component basis, you can call <code>setLayout(null)</code> and then it's up to you to hard-code the excat screen locations and dimensions. In the long run, though, it's almost always easier to use layout managers）。</p>
</blockquote>
<h2 id="重点-3"><a class="header" href="#重点-3">重点</a></h2>
<ul>
<li>布局管理器控制着嵌套在其他组件中的那些组件的大小及位置（Layout managers control the size and location of components nested within other components）;</li>
<li>在将组件添加到另一组件（这样的组件有时被成为 <em>背景</em> 组件，不过那并不是技术上的区别）时，被添加的这些组件，是受那个背景组件的布局管理器控制的；</li>
<li>布局管理器在做出布局决定之前，会询问他所布局的那些组件的优先大小。依据自己的策略，他可能会依照全部、部分，或不依照所布局组件的期望；</li>
<li><code>BorderLayout</code> 管理器运行把组件添加到他的五个区域之一。在添加组件时，必须使用下面的语法，对区域进行指定：</li>
</ul>
<pre><code class="language-java">add(BorderLayout.EAST, panel);
</code></pre>
<ul>
<li>在 <code>BorderLayout</code> 管理器控制下，位处北部与南部两个区域的组件，会得到他们自己优先高度，但得不到宽度。而在东部与西部的组件，则得到他们自己优先的宽度，而得不到高度。在中央区域的组件，将获得其他部分剩下了的空间（除非使用了 <code>pack()</code> 方法）。</li>
<li><code>pack()</code> 方法就如同那些组件的热缩膜；他用到中央组件的完整优先大小，然后将中心用作起点，来确定视窗框的大小，并基于其他区域中的东西，来构建出其余部分（The <code>pack()</code> method is like shrink-wrap for the components; it uses the full preferred size of the center component, then determines the size of the frame using the center as a starting point, building the rest based on what's in the other regions）；</li>
<li><code>FlowLayout</code> 会把他所布局的组件，从做往右、自顶向下，以这些组件添加的顺序进行放置，并只在这些组件无法水平排布时，开启新行（<code>FlowLayout</code> places components left to right, top to bottom, in the order they were added, wrapping to a new line of components only when the components won't fit horizontally）；</li>
<li><code>FlowLayout</code> 给到组件长和宽两个维度上组件自己的优先大小；</li>
<li>即使所布局的组件可以一一并排，<code>BoxLayout</code> 也允许将组件纵向堆叠起来。与 <code>FlowLayout</code> 类似，<code>BoxLayout</code>也使用所布局组件的长和宽两个维度的优先大小；</li>
<li>视窗框的默认布局管理器是<code>BorderLayout</code>；面板的默认布局管理器是 <code>FlowLayout</code>；</li>
<li>在想要面板使用有别于流式布局之外的其他布局管理器时，就必须调用面板上的 <code>setLayout()</code> 方法。</li>
</ul>
<h2 id="运用-swing-的那些组件"><a class="header" href="#运用-swing-的那些组件">运用 <code>Swing</code> 的那些组件</a></h2>
<p><strong>Play with <code>Swing</code> components</strong></p>
<p>在依据了解了布局管理器的基础后，就可以尝试几个最常用的组件了：文本字段、滚动式文本区、勾选框和清单等。这里并不会给出这些组件的完整API文档，而只提到几个入门所需的方法。</p>
<h3 id="jtextfield"><a class="header" href="#jtextfield"><code>JTextField</code></a></h3>
<pre><code class="language-java">package com.xfoss.learningJava;

import javax.swing.*;
import java.awt.*;

public class SwingComponentsDemo {
    public static void main (String[] args) {
        SwingComponentsDemo gui = new SwingComponentsDemo ();
        gui.go();
    }

    public void go () {
        JFrame f = new JFrame (&quot;Swing 常用组件演示：JLabel 与 JTextField&quot;);
        f.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);

        JPanel p = new JPanel ();
        f.setContentPane(p);

        JLabel l = new JLabel (&quot;你的姓名&quot;);
        p.add(l);
        JTextField txtField = new JTextField(20);
        p.add(txtField);

        f.setSize(640, 480);
        f.setVisible(true);
    }
}
</code></pre>
<p><img src="images/Ch13_24.png" alt="Swing 常用组件演示：JLabel 与 JTextField" /></p>
<p><em>图 24 - <code>Swing</code> 常用组件演示：<code>JLabel</code> 与 <code>JTextField</code></em></p>
<p><strong>构造器</strong></p>
<pre><code class="language-java">// JTextField 组件的构造器显然是有多个过载方法的
//
// 传入数字时，表示文本字段有多少个字符宽，而非多少个像素宽
// 这定义了文本字段的优先宽度
// 
// 传入一个字符串时，就是文本字段的默认文本
//
// 两个都传入时（此时必须字符串在前，数字在后），分别表示各自的意义
JTextField field = new JTextField(20);
JTextField field = new JTextField(&quot;你的姓名&quot;);
JTextField field = new JTextField(&quot;你的姓名&quot;, 20);
</code></pre>
<p><strong>使用方法</strong>：</p>
<ol>
<li>
<p>从 <code>JTextField</code> 实例获取文本</p>
<pre><code class="language-java">System.out.println(field.getText());
</code></pre>
</li>
<li>
<p>放入文本</p>
<pre><code class="language-java">field.setText(&quot;内容&quot;);
// 这行语句清空该字段
field.setText(&quot;&quot;);
</code></pre>
</li>
<li>
<p>在用户按下回车时获取到一个 <code>ActionEvent</code></p>
<pre><code class="language-java">// 若真的想要在用户每次按键时听到，那还可以对按键事件进行注册
field.addActionListener(myActionListener);
</code></pre>
</li>
<li>
<p>选择/高亮字段中的文本</p>
<pre><code class="language-java">field.selectAll();
</code></pre>
</li>
<li>
<p>将光标放回到该文本字段（这样用户才可以开始输入）</p>
<pre><code class="language-java">filed.requestFocus();
</code></pre>
</li>
</ol>
<h3 id="jtextarea"><a class="header" href="#jtextarea"><code>JTextArea</code></a></h3>
<p>与 <code>JTextField</code> 不同之处在于，<code>JTextArea</code>可以有多行文本。由于<code>JTextArea</code>在开箱即用的情况下并不带有滚动条或自动换行，因此构造一个 <code>JTextArea</code> 需要一点配置。要让某个<code>JTextArea</code>滚动，那么就要把他附着在一个 <code>ScrollPane</code>中。<code>ScrollPane</code>是个真正喜欢滚动的对象，还会照顾到文本区的滚动需求。</p>
<p><strong>构造器</strong></p>
<pre><code class="language-java">// 显然 JTextArea 的构造器也是过载了的
// 
// 这里的 10 表示 10 行（设置了优先的高度）
// 20 表示 20 列（对优先宽度进行设置）
JTextArea text = new JTextArea(10, 20);
JTextArea text = new JTextArea(&quot;关于你......&quot;, 10, 20);
</code></pre>
<p><strong>用法</strong>：</p>
<ol>
<li>
<p>令其只有纵向的滚动条</p>
<pre><code class="language-java">// 构造一个 JScrollPane 并给到那个要滚动的文本区
JScrollPane scroller = new JScrollPane(text);
// 开启自动换行
text.setLineWrap(true);

// 告诉滚动窗格仅使用一个纵向的滚动条
scroller.setVerticalScollBarPolicy(ScrollPaneConstants.VERICAL_SCROLLBAR_ALWAYS);
scroller.setHorizontalScollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

// 重要！！是把文本区给到滚动窗格（经由滚动窗格的构造器），随后
// 把滚动窗格添加到面板。不是直接把文本区添加到面板！
panel.add(scroller);
</code></pre>
</li>
<li>
<p>替换文本区中的文本</p>
<pre><code class="language-java">text.setText(&quot;并非所有失踪的人都在流浪&quot;);
</code></pre>
</li>
<li>
<p>往文本区中的文本追加内容</p>
<pre><code class="language-java">text.append(&quot;按钮已被点击&quot;);
</code></pre>
</li>
<li>
<p>选择/高亮显示文本区中的文本</p>
<pre><code class="language-java">text.selectAll();
</code></pre>
</li>
<li>
<p>把光标放回文本区（这样用户就可以开始输入）</p>
<pre><code class="language-java">text.requestFocus();
</code></pre>
</li>
</ol>
<p><strong><code>JTextArea</code>示例</strong></p>
<pre><code class="language-java">package com.xfoss.learningJava;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class TextAreaDemo {
    JTextArea text;

    public static void main(String[] args) {
        TextAreaDemo gui = new TextAreaDemo();
        gui.go();
    }

    public void go () {
        JFrame f = new JFrame(&quot;JTextArea 演示&quot;);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JPanel p = new JPanel();
        JButton btn = new JButton(&quot;点一下就好&quot;);
        btn.addActionListener(new btnActionListener());

        text = new JTextArea(&quot;示例内容\n&quot;, 10, 20);
        text.setLineWrap(true);

        JScrollPane scroller = new JScrollPane(text);
        scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        p.add(scroller);

        f.getContentPane().add(BorderLayout.CENTER, p);
        f.getContentPane().add(BorderLayout.SOUTH, btn);
        f.setSize(640, 480);
        f.setVisible(true);
    }

    class btnActionListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            text.append(&quot;按钮已被点击\n&quot;);
            System.out.format(&quot;文本区内容为：\n%s&quot;, text.getText());
        }
    }
}
</code></pre>
<p><img src="images/JTextAreaDemo.gif" alt="JTextArea示例效果" /></p>
<p><em>图 25 - <code>JTextArea</code>示例效果</em></p>
<h3 id="jcheckbox"><a class="header" href="#jcheckbox"><code>JCheckBox</code></a></h3>
<p><strong>构造器</strong></p>
<pre><code class="language-java">JCheckBox check = new JCheckBox(&quot;前往 11 层&quot;);
</code></pre>
<p><strong>用法</strong></p>
<ol>
<li>
<p>监听某个条目的事件（在该条目被勾选或取消勾选时）</p>
<pre><code class="language-java">check.addItemListener(this);
</code></pre>
</li>
<li>
<p>处理事件（并搞清楚该条目是否被勾选）</p>
<pre><code class="language-java">public void itemStateChanged (ItemEvent ev){
    String onOrOff = &quot;off&quot;;
    if (check.isSelected()) onOrOff = &quot;on&quot;;
    System.out.format(&quot;勾选框是 %s&quot;, onOrOff);
}
</code></pre>
</li>
<li>
<p>以代码方式勾选或取消勾选条目</p>
<pre><code class="language-java">check.setSelected(true);
check.setSelected(false);
</code></pre>
</li>
</ol>
<ul>
<li><strong>布局管理器带来的麻烦，与他们的价值相比，难道不是更多吗？如果必须要面对这些麻烦，那还不如直接对物件的大小与所在坐标硬编码呢</strong>。</li>
</ul>
<blockquote>
<p>从某种布局管理器得到想要的准确布局，可能是个挑战。然而想想布局管理器为我们所做的事情。就算那些要找出物件应该位处屏幕上何处这样简单的任务，也会较为复杂的吧。比如布局管理器就会考虑让多个组件重叠有序。也就是说，布局管理器知道怎样去管理组件之间的空间（以及组件与视窗框之间的空间）。当然这也可以自己去完成，不过在想要这些组件更紧凑时呢？或许可以手动把组件妥善放置起来，然而这样做也就只对JVM来说会好一些（You might get them placed just right, by hand, but that's only good for your JVM）!</p>
<p>为何这样说呢？因为这些组件在不同平台之间会有些许不同，尤其是在这些组件使用所在平台原生的“外观与体验”时。比如按钮斜面等一些细节就会有这样的差别，在一个平台上会整齐排列，而另一个平台则会突然挤在一起。</p>
<p>然而这些都还不是布局管理器最重要的地方。想想在用户缩放视窗的时候！或者GUI是动态的，有组件会出现和离去的情况。在每次视窗大小调整或背景组件的内容发生改变时，都要对所有组件的布局进行更新......那会要老命的！</p>
</blockquote>
<h3 id="jlist"><a class="header" href="#jlist"><code>JList</code></a></h3>
<p><img src="images/Ch13_26.png" alt="JList Demo" /></p>
<p><em>图 26 - <code>JList</code> Demo</em></p>
<p><strong>构造器</strong></p>
<pre><code class="language-java">// JList 构造器会接收一个任意对象类型的数组。这些对象类型一定非得要是字符串，但不论
// 什么对象类型，在清单上出现的，将都会是一个字符的表示（JList constructor takes an array
// of any object type. They don't have to be Strings, but a String representation will
// appear in the list）。
String [] listEntries = {&quot;apple&quot;, &quot;banana&quot;, &quot;carriot&quot;, &quot;donut&quot;, &quot;fish&quot;, &quot;egg&quot;, &quot;grapes&quot;};
JList&lt;String&gt; l = new JList&lt;String&gt;(listEntries);
</code></pre>
<p><strong>用法</strong></p>
<ol>
<li>
<p>令到其有个垂直的滚动条</p>
<pre><code class="language-java">// 这就跟 JTextArea 一样 -- 构造一个 JScrollPane（并给他清单）
// 随后把这个滚动区域（而非这个清单）添加到面板
JScrollPane scroller = new JScrollPane(list);
scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

panel.add(scroller);
</code></pre>
</li>
<li>
<p>设置滚动前显示的行数</p>
<pre><code class="language-java">list.setVisibleRowCount(4);
</code></pre>
</li>
<li>
<p>限制用户一次选择一个物件</p>
<pre><code class="language-java">list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
</code></pre>
</li>
<li>
<p>对清单选择事件进行注册</p>
<pre><code class="language-java">list.addListSelectionListener(this);
</code></pre>
</li>
<li>
<p>对事件进行处理（找出清单中哪个物件被选中）</p>
<pre><code class="language-java">public void valueChanged(ListSelectionEvent lse) {
    // 若不加入这个 if 条件测试，那么就会收到这个
    // 事件两次
    if (!lse.getValueIsAdjusting()) {
        // getSelectedValue() 方法返回的其实是一个对象。清单
        // 并不止于字符串对象。
        String selection = (String) list.getSelectedValue();
        System.out.println(selection);
    }
}
</code></pre>
</li>
</ol>
<h2 id="代码厨房-2"><a class="header" href="#代码厨房-2">代码厨房</a></h2>
<p><img src="images/Ch13_27.png" alt="代码厨房" /></p>
<p><em>图 27 - 第 13 章代码厨房配图</em></p>
<p>此部分是可选的。这里在构造完整版的 <code>BeatBox</code>，GUI及全部的东西。在保存对象那一章，将学习怎样去保存与恢复鼓的各种模式（编曲）。最后在网络通信那一章（“构造连接”），就会把 <code>BeatBox</code> 做成一个可工作的聊天客户端。</p>
<h3 id="构造-beatbox"><a class="header" href="#构造-beatbox">构造 <code>BeatBox</code></a></h3>
<p>下面是这个版本的 <code>BeatBox</code> 的完整代码清单，有用于开始、停止及修改速度的那些按钮（This is the full code listing for this version of the <code>BeatBox</code>, with buttons for starting, stopping, and changing the tempo）。此清单是完整的，并且是重复注释的，而下面就是个概述：</p>
<ol>
<li>
<p>构造一个有着 256 个开始都是未勾选单选框（<code>JCheckBox</code>）、16个用于表示乐器名字的标签（<code>JLabel</code>），以及四个按钮的 GUI；</p>
</li>
<li>
<p>对四个按钮都注册一个 <code>ActionListener</code>。由于这里还不准备动态修改声音编排模式（即在用户勾选某个单选框时，立即反应出来），所以对于单个的单选框，并不需要事件收听者。而是在用户点击“开始”按钮时，才去对全部256个单选框跑一遍，来取得他们的状态，并构造出一个 MIDI 音轨；</p>
</li>
<li>
<p>建立起一个包含获取音序器（<code>Sequencer</code>）、构造序列（<code>Sequence</code>）及创建音轨的MIDI 系统（在这之前就已经完成了）。这里将使用到 Java 5.0 中才引入的一个音序器方法，<code>setLoopCount()</code>。这个方法允许我们指定某个序列循环多少次。这里还会用到序列的快慢因子，来提升或降低序列的速度，并在循环回访中维持新的速度（We're also using the sequence's tempo factor to adjust the tempo up or down, and maintain the new tempo from one iteration of the loop to the next）。</p>
</li>
<li>
<p>在用户点击 “开始” 时，就会开始真正的动作。“开始”按钮的事件处理方法调用 <code>buildTrackAndStart()</code> 方法。在那个方法中，将对全部 256 个单选框都跑一遍（每次一行，单个乐器的全部16拍），来获取这些单选框的状态，随后使用这些信息来构建出一个 MIDI 音轨（使用前一章中用到的那个方便的 <code>makeEvent()</code> 方法）。在音轨构建好了之后，就启动音序器（the sequencer），音序器将一直演奏（因为设置了循环演奏）直到用户点击了“停止”按钮。</p>
</li>
</ol>
<pre><code class="language-java">package com.xfoss.BeatBox;

import java.awt.*;
import javax.swing.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;
// 导入 java.net 包的目的，是为了使用下面的 URL 类型
import java.net.*;

public class BeatBox {
    JPanel mainPanel;
    // 这里是把那些单选框存储在一个 ArrayList 中
    ArrayList&lt;JCheckBox&gt; checkBoxList;
    Sequencer s;
    Sequence seq;
    Track t;
    JFrame f;
    JLabel tempoLabel = null;

    // 这些是乐器的名字，这里把他们当作一个字符串数组的，用于构建
    // GUI 的那些标签（每行一条）
    String [] instrumentNames = {&quot;贝斯鼓（低音鼓）&quot;, &quot;闭镲（闭合击镲）&quot;,
        &quot;空心钹（开音踩钹）&quot;, &quot;小鼓（军鼓）&quot;, &quot;双面钹（强音钹）&quot;, &quot;拍手（拍掌声）&quot;,
        &quot;高音鼓（高音桶鼓）&quot;, &quot;高音圆鼓（高音小鼓）&quot;, &quot;沙锤（沙铃）&quot;, &quot;口哨&quot;, &quot;低音手鼓&quot;,
        &quot;牛铃（牛颈铃）&quot;, &quot;颤音叉&quot;, &quot;中低音桶鼓&quot;, &quot;高音撞铃&quot;,
        &quot;开音高音手鼓&quot;};

    // 这些表示了各种真实鼓的“按键”。鼓通道就如同钢琴一样，只是钢琴上各个“琴键”
    // 是为某种不同的鼓而已。因此数字 ‘35’ 就是贝斯鼓的按键，而 ‘42’ 则是高音钹的
    // 按键。
    int [] instruments = {35, 42, 46, 38, 49, 39, 50, 60, 70, 72, 64, 56, 58, 47, 67, 63};

    public static void main (String[] args) {
        new BeatBox().buildGUI();
    }

    public void buildGUI () {
        f = new JFrame(&quot;赛博 BeatBox&quot;);

        // 这里给视窗加上一个 ico 图标，为了兼容性使用的是 PNG 图片
        // 
        // 其中用到的图片，作为与代码分离的措施，放在 src/main 目录的
        // resources 文件夹下的 images 目录里
        //
        // build.gradle.kts 构建配置文件中，有语句将这些 resources 
        // 拷贝到打包的jar中
        URL icoURI = getClass().getResource(&quot;/images/ico.png&quot;);
        ImageIcon ico = new ImageIcon(icoURI);
        f.setIconImage(ico.getImage());
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        BorderLayout l = new BorderLayout();
        JPanel bg = new JPanel(l);
        // 这里创建了一个“空白边框（EmptyBorder）”对象（并调用 JPanel 的
        // setBorder() 方法，设置到 bg 上），给到面板各个边缘和放置的
        // 组件之间的一个外边距。看起来颇具美感。
        bg.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // 后面就没什么特别的了，只是很多的 GUI 组件。
        // 其中大部分在之前就已经看到过了。
        checkBoxList = new ArrayList&lt;JCheckBox&gt; ();
        Box btnBox = new Box(BoxLayout.Y_AXIS);

        JButton btnS = new JButton(&quot;开始▶&quot;);
        btnS.addActionListener(new StartListener());
        btnBox.add(btnS);

        JButton btnStop = new JButton(&quot;停止◾&quot;);
        btnStop.addActionListener(new StopListener());
        btnBox.add(btnStop);

        btnBox.add(Box.createHorizontalStrut(5));
        btnBox.add(new JSeparator(SwingConstants.VERTICAL));
        btnBox.add(Box.createHorizontalStrut(5));

        JButton btnUpTempo = new JButton(&quot;加速&gt;&gt;&quot;);
        btnUpTempo.addActionListener(new UpTempoListener());
        btnBox.add(btnUpTempo);

        JButton btnDownTempo = new JButton(&quot;减慢&lt;&lt;&quot;);
        btnDownTempo.addActionListener(new DownTempoListener());
        btnBox.add(btnDownTempo);

        tempoLabel = new JLabel(String.format(&quot;速度因子：%.2f&quot;, 1.00f)); 
        btnBox.add(tempoLabel);

        Box nameBox = new Box(BoxLayout.Y_AXIS);
        for (int i = 0; i &lt; 16; i++) {
            nameBox.add(new Label(instrumentNames[i]));
        }

        bg.add(BorderLayout.EAST, btnBox);
        bg.add(BorderLayout.WEST, nameBox);

        // 还是些建立 GUI 的代码。并无不同之处。
        f.getContentPane().add(bg);

        GridLayout g = new GridLayout(16, 16);
        g.setVgap(1);
        g.setHgap(2);
        mainPanel = new JPanel(g);
        bg.add(BorderLayout.CENTER, mainPanel);

        // 这里构造出那些单选框，将他们设置为‘false’（从而使得他们
        // 保持未被勾选），然后将他们添加到那个 ArrayList 以及 GUI
        // 面板上。
        for (int i = 0; i &lt; 256; i++) {
            JCheckBox c = new JCheckBox();
            c.setSelected(false);
            checkBoxList.add(c);
            mainPanel.add(c);
        }

        setUpMidi();

        f.setBounds(50, 50, 640, 480);
        f.pack();
        f.setVisible(true);
    }

    // 这里是常见的用于获取音序器（the Sequencer）、MIDI序列（the Sequence）
    // 以及MIDI音轨（the Track），从而建立起 MIDI 的代码。
    public void setUpMidi () {
        try {
            s = MidiSystem.getSequencer();
            s.open();
            seq = new Sequence(Sequence.PPQ, 4);
            t = seq.createTrack();
            s.setTempoInBPM(120);
        } catch (Exception e) {e.printStackTrace();}
    }

    // 这里是全部事情发生的地方！正是在这里把单选框的状态，转换成
    // MIDI 事件，并把这些MIDI事件添加到MIDI音轨。
    public void buildTrackAndStart () {
        // 这里将会构造一个有16个元素的数组，来保存一种具体
        // 乐器 16 个节拍的各个取值。若该种乐器即将在那个节拍
        // 上奏乐时，那么那个节拍所在的值，就会是此种乐器的按键编号。
        // 若在那个节拍上该种乐器不会奏乐，那么在该节拍上就会放入一个零。
        int [] trackList = null;

        // 对原有的音轨进行处理，并构造一个全新的音轨。
        seq.deleteTrack(t);
        t = seq.createTrack();

        // 这个循环是对 16 行进行的（即：那些贝斯鼓、Congo等等）
        for (int i = 0; i &lt; 16; i++){
            trackList = new int[16];

            // 对乐器的‘按键’编号进行设置。表示当前是何种乐器（贝斯、Hi-Hat等
            // 数组 instruments 保存了各个乐器的真实 MIDI 编号。
            int key = instruments[i];

            // 这个循环是对这一行的 16 个节拍进行的
            for (int j = 0; j &lt; 16; j++) {

                JCheckBox jc = checkBoxList.get(j + 16*i);
                // 在这个节拍上的单选框是勾选了的吗？若被勾选，那么就把
                // 此乐器的按键编号放入数组该节拍对应的槽中（该槽位（the slot）就
                // 表示了这个节拍）。否则就表示该乐器在这个节拍不应奏乐，因此就要
                // 把这个槽位设置为零。
                if (jc.isSelected()) {
                    trackList[j] = key;
                } else {
                    trackList[j] = 0;
                }
            }

            // 对于当前乐器，以及整个16拍，进行MIDI事件的构造并将这些MIDI事件
            // 添加到 MIDI 音轨上。
            makeTracks(trackList);
            t.add(makeEvent(176, 1, 127, 0, 16));
        }

        // 这里总是要确保在第16拍处有必须有一个事件。否则 BeatBox app就不会
        // 在重新回放前跑满完整的 16 拍（We always want to make sure that there
        // IS an event for beat 16(it goes 0 to 15). Otherwise, the BeatBox might
        // not go the full 16 beats before it starts over）。
        t.add(makeEvent(192, 9, 1, 0, 15));
        try {
            s.setSequence(seq);
            // 这里 Sequencer 的 setLoopCount() 方法，预先指定循环次数，或者
            // 像这里这样，持续不停的循环下去。
            s.setLoopCount(Sequencer.LOOP_CONTINUOUSLY);
            // 这里就开始演奏上面的编排了。
            s.start();
            s.setTempoInBPM(120);
        } catch(Exception e) {e.printStackTrace();}
    }

    // 第一个内部类，这些内部类都是按钮的事件收听者。并无特别之处。
    class StartListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            buildTrackAndStart();
        }
    }

    // 其他的那些内部类。
    class StopListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            s.stop();
        }
    }

    class UpTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            // 速度因子（The Tempo Factor） 通过所提供的速度因数
            // (the factor provided) 对音序器的速度进行调节。默认的
            // 速度因数为 1.0，那么这里就是每点击一次，纠正 +/- 3%
            s.setTempoFactor(s.getTempoFactor() + 0.03f);
            tempoLabel.setText(String.format(&quot;速度因子：%.2f&quot;, s.getTempoFactor()));
        }
    }

    class DownTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            s.setTempoFactor(s.getTempoFactor() - 0.03f);
            tempoLabel.setText(String.format(&quot;速度因子：%.2f&quot;, s.getTempoFactor()));
        }
    }

    // 这个方法每次给一种乐器的全部 16 个节拍构造MIDI事件。
    // 那么他就应获取到每个乐器的一个 int[] 数组，该数组的各个索引
    // 下要么是乐器的按键编号，否则就会是0。在某个索引下的值为零时
    // 该乐器就认为不会在那个节拍上奏乐。否则就要构造一个事件并把
    // 所构造的事件添加到音轨上。
    public void makeTracks(int [] list) {
        for(int i = 0; i &lt; 16; i++) {
            int k = list[i];

            if(k != 0) {
                t.add(makeEvent(144, 9, k, 100, i));
                t.add(makeEvent(128, 8, k, 100, i+1));
            }
        }
    }

    // 这个方法实际上是上一章中的那个工具方法。并无新意。
    public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick){
        MidiEvent ev = null;
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            ev = new MidiEvent(a, tick);
        } catch (Exception e) {e.printStackTrace();}
        return ev;
    }
}
</code></pre>
<p><img src="images/Ch13_28.png" alt="BeatBox app 第一版" /></p>
<p><em>图 28 - <code>BeatBox</code> app 第一版</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对象序列化与文件-io-对象的保存"><a class="header" href="#对象序列化与文件-io-对象的保存">对象序列化与文件 <code>I/O</code>: 对象的保存</a></h1>
<p><strong>serialization and file <code>I/O</code>: Saving Objects</strong></p>
<p><img src="images/Ch14_01.png" alt="第14章题图" /></p>
<p><em>图  1 - 第14章题图</em></p>
<p><strong>对象可被放气或充气（Objects can be flattened and inflated）</strong>。对象具有状态和行为。关于对象的那些 <em>行为</em>，是存活在 <em>类</em> 中，而 <em>状态</em> 则是存活在各个单独 <em>对象</em> 中的（<em>Behavior</em> lives in the <em>class</em>, but <em>state</em> lives within each individual <em>object</em>）。那么在对对象状态进行保存时，会发生什么呢？比如在编写某个游戏时，就会需要一个特性来保存/恢复游戏。又比如在编写某个创建图表的app时，就需要一个保存/打开文件的特性。在程序需要保存状态时，<em>可以笨办法来完成</em>，对各个对象进行询问，然后费力地将各个示例变量的值，以某种自创格式，写到一个文件。或者，<strong>可以轻松的面向对象方式完成</strong> -- 简单地将对象本身冻干/压平/持久化/脱水，然后再通过重组/填充/恢复/注水，来取回对象。不过 <em>某些时候</em> 仍然需要以笨办法来完成对象状态的保存，尤其是app保存的文件必定会被其他非Java语言的 app 读取的时候，所以本章会对这两种保存对象状态的方式加以审视（If your program needs to save state, <em>you can do it the hard way</em>, interrogating each object, then painstakingly writing the value of each instance variable to a file, in a format you create. Or, <strong>you can do it the easy OO way</strong> -- you simply freeze-dry/flatten/persist/dehydrate the object itself, and reconstitue/inflate/restore/rehydrate it to get it back. But you'll still have to do it the hard way <em>sometimes</em>, especially when the file your app saves has to be read by some other non-Java application, so we'll look at both in this chapter）。</p>
<h2 id="对节拍进行捕获"><a class="header" href="#对节拍进行捕获">对节拍进行捕获</a></h2>
<p><strong>Capture the Beat</strong></p>
<p>现在 <em>构造</em> 好了完美的音乐曲目。那么就要把这个曲目 <em>存储</em> 起来。当然可以拿张纸然后摘抄下来，不过这里是要做成点击 <em><strong>保存</strong></em> 按钮的方式（或者从“文件”菜单中选择“保存”）。接着就要提供一个名称，选取某个目录，并确保这首优美的曲子，不会因为系统蓝屏司机而丢失（You could grab a piece of paper and start scribbling it down, but instead you hit the <em><strong>Save</strong></em> button(or choose Save from the File menu). Then you give it a name, pick a directory, and exhale knowing that your masterpiece won't go out the window with the blue screen of death）。</p>
<p>对于保存Java 程序状态来说，有很多个选项，至于具体选用何种选项，将取决于计划怎样去 <em>使用</em> 所保存的状态（You have lots of options for how to save the state of your Java program, and what you choose will probably depend on how you plan to <em>use</em> the saved state）。本章要检视的几种选项如下所示。</p>
<p><strong>在数据只会被生成数据的 Java 程式使用到时（If your data will be used by only the Java program that generated it）</strong>：</p>
<ol>
<li>
<p><strong>运用对象序列化</strong></p>
<p><strong>Use <em>serialization</em></strong></p>
<p>对留存了被压扁（序列化的）对象的一个文件进行写入。随后程序就从这个文件读取这些序列化的对象，并将他们充实回到活生生的、有呼吸的、存在于内存堆的对象（Write a file that holds flattened(serialized) objects. Then have your program read the serialized objects from the file and inflate them back into living, breathing, heap-inhabiting objects）。</p>
<p><strong>在数据会被其他程序使用到时</strong>：</p>
</li>
<li>
<p><strong>写入 <em>普通文本</em> 文件</strong></p>
<p><strong>Write <em>a plain text</em> file</strong></p>
<p>写入到一个带有分隔符，从而可被其他程序解析的文件。比如就可以写入到一个由制表符分隔的、可被电子表格或数据库应用使用的文件（Write a file, with delimiters that other programs can parse. For example, a tab-delimited file that a spreadsheet or database application can use）。</p>
<p>当然并非只有这两个选项。可以所选的任意格式来保存数据。除了往文件中写入字符，还可以将数据写为字节（Instead of writing characters, for example, you can write your data as bytes）。还可以把那些 Java 原生值当作 Java 原生值来写入文件 -- 对于整数、长整数、布尔值等原生值类型，是有相应方法来写入文件的。但不管使用何种方法来保存数据，文件<code>I/O</code>的基本技巧总是不变的：把一些数据写入到 <em>某个东西（something）</em>，而通常这某个东西要么是磁盘上的文件、要么就是来自网络连接的流（But regardless of the method you use, the fundamental <code>I/O</code> techniques are pretty much the same: write some data to <em>something</em>, and usually that something is either a file on disk or a stream coming from a network connection）。读取数据则是同样的过程，只是反过来而已：从磁盘上的文件或某个网络连接，读取到一些数据。同时本章所讨论的内容，是在未使用到某种具体数据库时，所涉及的数据保存。</p>
</li>
</ol>
<h2 id="对状态进行保存"><a class="header" href="#对状态进行保存">对状态进行保存</a></h2>
<p><strong>Saving State</strong></p>
<p>设想有这么一个程序，比方说，一个奇幻冒险游戏，需要与玩家进行多次会话才能完成。随着游戏的进展，游戏中的角色变得愈加强大、弱小、灵巧等等，并会收集（或丢失）各种武器。那么就肯定不愿意每次启动游戏都又从头开始玩 -- 那样你的游戏角色就永远不会在某次激烈战斗中有最佳状态。那么就需要一种保存游戏角色状态的方式，以及在继续游戏时对状态进行恢复的方式。而由于作为游戏程序的编写者，就会希望整个保存与恢复，应该尽可能是容易实现（且简单明了）。</p>
<ol>
<li>
<p>选项一</p>
<p><strong>把这三个序列化的游戏角色写到某个文件</strong></p>
<p>创建出一个文件，并写入三个序列化角色对象。这个文件在作为文本进行读取时，并无任何意义：</p>
<pre><code class="language-console"> ̈ÌsrGameCharacter 
 ̈%gê8MÛIpowerLjava/lang/
 String;[weaponst[Ljava/lang/
 String;xp2tlfur[Ljava.lang.String;≠“VÁ
 È{Gxptbowtswordtdustsq~»tTrolluq~tb
 are handstbig axsq~xtMagicianuq~tspe
 llstinvisibility
</code></pre>
</li>
<li>
<p>选项二</p>
<p><strong>写入普通文本文件</strong></p>
<p>创建出一个文件，并写入三行文本，每行一个游戏角色，用逗号分隔角色状态的各个部分：</p>
<pre><code class="language-console">50,Elf,bow, sword,dust
200,Troll,bare hands,big ax
120,Magician,spells,invisibility
</code></pre>
<p><img src="images/Ch14_02.png" alt="对象存储图解" /></p>
<p><em>图 2 - 对象存储图解</em></p>
</li>
</ol>
<h2 id="把序列化对象写到某个文件"><a class="header" href="#把序列化对象写到某个文件">把序列化对象写到某个文件</a></h2>
<p>以下就是将对象进行序列化（保存）的步骤（Here are the steps for serializing(saving) an object）。不用纠结于把这些步骤都记住；本章后续会深入讲解。</p>
<ol>
<li>
<p><strong>构造一个 <em><code>FileOutputStream</code></em> 对象</strong></p>
<pre><code class="language-java">// 构造出一个 FileOutputStream 对象。FileOutputStream 知道怎样去
// 连接（并创建出）一个文件。
// 
// 若这个 “MyGame.ser” 文件不存在，那么他就会被自动创建出来。
FileOutputStream fileStream = new FileOutputStream(&quot;MyGame.ser&quot;);
</code></pre>
</li>
<li>
<p><strong>构造一个 <em><code>ObjectOutputStream</code> 对象</em></strong></p>
<pre><code class="language-java">// ObjectOutputStream 实现对象写到文件，但他无法直接连接到
// 文件。他需要喂入一个“helper”。这实际上就是把一个流“链接”
// 到另一个上（This is actually called 'chaining' one stream
// to another）。
ObjectOutputStream oStream = new ObjectOutputStream(fileStream);
</code></pre>
</li>
<li>
<p><strong>写入对象</strong></p>
<pre><code class="language-java">// 对这些由 characterOne, Two, Three 所表示的对象进行序列化操作
// 并将他们写到文件 “MyGame.ser” 中。
oStream.writeObject(characterOne);
oStream.writeObject(characterTwo);
oStream.writeObject(characterThree);
</code></pre>
</li>
<li>
<p><strong>关闭 <code>ObjectOutputStream</code></strong></p>
<pre><code class="language-java">// 关闭了顶部的流，就会关闭其下所有的其他流，因此 `FileOutputStream` 
// （及那个文件）就会自动关闭。
oStream.close();
</code></pre>
</li>
</ol>
<p><strong>在各种流中，数据从一处往另一处移动（Data moves in streams from one place to another）</strong>。</p>
<p>Java 的 <code>I/O</code> API，有着各种表示到诸如文件或网络套接字这类目的与源的连接，以及将那些只有被链接到其他流才会工作的流 <em><strong>链接</strong></em> 起来的 <em>连接性</em> 流（The Java <code>I/O</code> API has <em><strong>connection</strong></em> streams, that represent connections to destinations and sources such as files or network sockets, and <em><strong>chain</strong></em> streams that work only if chained to other streams）。</p>
<p>通常，要至少同时钩起两个流流，才能完成有用的事情 -- <em>一个</em> 表示连接，而 <em>另一个</em> 则是要调用到他的方法。为什么是两个呢？因为 <em>连接</em> 流通常都是很低级别的。就拿 <code>FileOutputStream</code>（就是一个连接流）来说，就有写入 <em>字节</em> 的一些方法。但这里并不想要写入 <em>字节</em>！这里要的是写入 <em>对象</em>，因此就需要一个高级别的 <em>链接</em> 流（Often, it takes at least two streams hooked together to do something useful -- <em>one</em> to represent the connection and <em>another</em> to call methods on. Why two? Because <em>connection</em> streams are usually too low-level. <code>FileOutputStream</code>(a connection stream), for example, has methods for writing <em>bytes</em>. But we don't want to write <em>bytes</em>! We want to write <em>objects</em>, so we need a higher-level <em>chain</em> stream）。</p>
<p>好，那么又为什么不只要精准完成所需的单个流呢？一个实现对象写入并同时将对象转换成字节的流？这就要考虑良好的面向对象了。每个类做好 <em>一件</em> 事情。<code>FileOutputStream</code> 就是把字节写入到文件。<code>ObjectOutputStream</code> 就是把对象转换成可写入到流的数据。所以这里构造一个 <code>FileOutputStream</code> 来实现到文件的写入，并在 <code>FileOutputStream</code> 末尾钩起一个 <code>ObjectOutputStream</code>（一个链接流）。在调用<code>ObjectOutputStream</code>上的 <code>writeObject()</code> 方法时，对象就被泵入到流中，随后就移动到 <code>FileOutputStream</code>，在那里最终被作为一些字节，写到某个文件。</p>
<p>不同连接与链接流组合的混搭能力，赋予到我们惊人的灵活性！若强制要求使用仅仅 <em>单个</em> 的流类，那么就会受 API 设计者们的支配，就会希望他们能考虑到咱们所期望的所有功能。然而有了流链接特性，就可以组装出自己 <em>定制</em> 的各种流链（The ability to mix and match different combinations of connection and chain streams gives you tremendous flexibility! If you were forced to use only a <em>single</em> stream class, you'd be at the mercy of the API designers, hoping they'd thought of <em>everything</em> you might ever want to do. But with chaining, you can patch together your own <em>custom</em> chains）。</p>
<p><img src="images/Ch14_03.png" alt="Java对象写入文件过程" /></p>
<p><em>图 3 - Java对象写入文件过程</em></p>
<h2 id="在对象被序列化时到底发生了什么"><a class="header" href="#在对象被序列化时到底发生了什么">在对象被序列化时，到底发生了什么？</a></h2>
<p><strong>What really happens to an object when it's serialized</strong>?</p>
<p><img src="images/Ch14_04.png" alt="图解存活对象与序列化对象的区别" /></p>
<p><em>图 4 - 图解存活对象与序列化对象的区别</em></p>
<p><img src="images/Ch14_05.png" alt="Java保存对象实例" /></p>
<p><em>图 5 - Java保存对象实例</em></p>
<h3 id="然而对象状态-究竟是-个什么呢到底需要保存什么呢"><a class="header" href="#然而对象状态-究竟是-个什么呢到底需要保存什么呢">然而对象状态 <em>究竟是</em> 个什么呢？到底需要保存什么呢？</a></h3>
<p><strong>But what exactly <em>IS</em> an object's state? What needs to be saved</strong>?</p>
<p>现在就开始变得有趣起来了。要保存 <em>原生</em> 值 <code>37</code> 与 <code>70</code> 是相当容易。但如果对象有着一个是对象 <em>引用</em> 的实例变量呢？某个对象有着五个的对象引用的实例变量又会怎样呢？如果这些对象实例变量本身又有实例变量的话，又会怎样呢（Easy enough to save the <em>primitive</em> values <code>37</code> and <code>70</code>. But what if an object has an instance variable that's an object <em>reference</em>? What about an object that has five instance variables that are object references? What if those object instance variables themselves have instance variables）？</p>
<p>请想想。对象的什么部分，是潜在唯一的？试想一下为了获得一个与所保存对象一致的对象，究竟需要恢复的是什么。当然对象将有着不同的内存位置，然而对于这一点我们并不关心。这里所关心的，全是在内存堆上得出的结果，将获取到一个与对象被保存时有着相同状态的一个内存堆上的存活对象。</p>
<h2 id="脑力锻炼-2"><a class="header" href="#脑力锻炼-2">脑力锻炼</a></h2>
<p><img src="images/Ch14_06.png" alt="如何保存带有到其他对象引用变量的对象" /></p>
<p><em>图 6 - 如何保存带有到其他对象引用变量的对象</em></p>
<p>必须要怎样保存 <code>Car</code> 对象，才能从 <code>Car</code> 副本中恢复到其原先的状态？</p>
<p>试想一下要保存 <code>Car</code> 对象会需要些什么 -- 以及怎样去保存他。</p>
<p>同时在 <code>Engine</code> 对象又有着到 <code>Carburetor</code> 对象的引用时，会怎样呢？以及在 <code>Tire []</code> 这个数组对象中又有着什么呢？</p>
<p><strong>在某个对象被序列化时，自其实例变量引用到的全部对象同时被实例化。这些被引用对象引用到的对象亦被实例化。这些被引用到的对象所引用的对象，亦被实例化......而最妙的地方就是，这些都是自动发生的</strong>！</p>
<p>这个 <code>Kennel</code> 对象有着一个到 <code>Dog []</code> 数组对象的引用。而 <code>Dog []</code> 中留存了对两个 <code>Dog</code> 对象的引用。每个 <code>Dog</code> 对象留存了到一个字符串及一个 <code>Collar</code> 对象的引用。字符串对象有着一个字符集合，同时 <code>Collar</code> 对象有着一个整数。</p>
<p><img src="images/Ch14_07.png" alt="对象保存时涉及实例变量为对象引用的情形" /></p>
<p><em>图 7 - 对象保存时涉及实例变量为对象引用的情形</em></p>
<blockquote>
<p><strong>序列化保存了完整的 <em>对象图面（object graph）</em>。自所保存对象开始，全部的实例变量引用到对象，都会被序列化</strong>。</p>
</blockquote>
<h2 id="在希望所编写的类可被序列化时就要实现-serializable-接口"><a class="header" href="#在希望所编写的类可被序列化时就要实现-serializable-接口">在希望所编写的类可被序列化时，就要实现 <code>Serializable</code> 接口</a></h2>
<p><strong>If you want your class to be serializable, implement <code>Serializable</code></strong></p>
<p>由于 <code>Serializable</code> 接口没有要实现的方法，因此又被称作 <em>标记</em> 或者说 <em>标签</em> 接口（The <code>Serializable</code> interface is known as a <em>marker</em> or <em>tag</em> interface, because the interface doesn't have any methods to implement）。 其唯一目的，就是通告实现了他的类，是 <em>可被序列化的（serializable）</em>。也就是说，<code>Serializable</code> 类型的类，可通过序列化机制加以保存（In other words, objects of that type are saveable through the serialization mechanism）。在有超类是可序列化的类时，那么其子类将自动成为可序列化类，即使其子类并未显示声明 <em><code>implements Serializable</code></em>。（这也是接口一贯的 <em>运作</em> 方式。在某个类的超类 <code>IS-A</code> <code>Serializable</code>时，那么这个类同样是 <code>Serializable</code>的）。</p>
<pre><code class="language-java">// 这里传递给 writeObject() 方法的参数，必须 实现了 Serializable
// 接口，否则在运行时就会失败
objectOutputStream.writeObject(myBox);
</code></pre>
<p>--</p>
<pre><code class="language-java">package com.xfoss.learningJava;

// 接口 Serializable 是在 java.io 包中，因此要需要这个 import 语句
import java.io.*;

// 虽然没有要实现的方法，但在写下这里的 &quot;implements Serializable&quot;
// 时，就等于告诉了JVM，“可对这种类型的对象进行序列化。”
public class Box implements Serializable {

    // 这两个值将会被保存起来
    private int width;
    private int height;

    public void setWidth (int w) {
        width = w;
    }

    public void setHeight (int h) {
        height = h;
    }

    public static void main (String[] args) {
        Box box = new Box();
        box.setWidth(50);
        box.setHeight(20);

        // I/O 操作可能抛出异常。
        try {
            // 若存在一个名为“Box.ser”的文件，那么就连接到这个文件。而若不
            // 存在，就构造一个新的名为 “Box.ser” 的文件。
            FileOutputStream fStream = new FileOutputStream(&quot;Box.ser&quot;);
            // 构造一个链接到连接流 FileOutputStream 的 ObjectOutputStream 对象
            // 让他写入对象 box。
            ObjectOutputStream oStream = new ObjectOutputStream(fStream);
            oStream.writeObject(box);
            oStream.close();
        } catch (Exception ex) {ex.printStackTrace();}
    }
}
</code></pre>
<p>运行这段代码将创建出一个 <code>Box.ser</code> 的文件，其内容为：</p>
<pre><code class="language-console">¬í sr com.xfoss.learningJava.Boxý	¼%~FH I heightI widthxp      2
</code></pre>
<p>以后不管运行多少次，<code>Box.ser</code> 的内容都不会改变。</p>
<h2 id="序列化就是全部或者全无"><a class="header" href="#序列化就是全部或者全无">序列化就是全部，或者全无。</a></h2>
<p><strong>Serialization is all or nothing</strong>.</p>
<p><strong>设想一下如果对象的某些状态没有正确保存，会发生什么呢</strong>？</p>
<p><img src="images/Ch14_08.png" alt="序列化对象恢复的风险" /></p>
<p><em>图 8 - 序列化对象恢复的风险</em></p>
<p><strong>要么整个的对象图面被正确序列化，但凡有一个差错，那么就算作序列化失败（Either the entire object graph is serialized correctly or serialization fails）</strong>。</p>
<p><strong>在对一个 <code>Pond</code> 对象进行序列化时，若他 <code>Duck</code> 实例变量拒绝被实例化（因为没有对 <code>Serializable</code> 接口进行实现），那么就无法实例化这个 <code>Pond</code> 对象</strong>。</p>
<pre><code class="language-java">package com.xfoss.learningJava;

import java.io.*;

// Pond 的对象，可被序列化
public class Pond implements Serializable {
    // 类 Pond 有一个实例变量，是到一个 Duck 
    // 对象的引用。
    private Duck duck = new Duck();
    
    public static void main (String[] args) {
        Pond pond = new Pond();

        try {
            FileOutputStream fStream = new FileOutputStream(&quot;Pond.ser&quot;);
            ObjectOutputStream oStream = new ObjectOutputStream(fStream);

            // 在对 pond （一个 Pond 的对象）进行序列化时，该对象
            // 的 Duck 实例变量会自动被序列化。
            oStream.writeObject(pond);
            oStream.close();
        } catch (Exception ex) { ex.printStackTrace(); }
    }
}

// 然而！！Duck（在 com.xfoss.learningJava.UseADuck中声明） 并
// 不是可序列化的！Duck 类并没有实现 Serializable, 因此在对
// Pond 对象进行序列化时，由于该 Pond 对象的 Duck 实例变量
// 无法被保存，而失败。
</code></pre>
<p>将报出以下错误：</p>
<pre><code class="language-console">Quack... My size is 32, my number is 1
java.io.NotSerializableException: com.xfoss.learningJava.Duck
        at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1185)
        at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1553)
        at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1510)
        at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433)
        at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179)
        at java.base/java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:349)
        at com.xfoss.learningJava.Pond.main(Pond.java:15)
</code></pre>
<p><img src="images/Ch14_09.png" alt="非 Serializable 对象无法被序列化的麻烦" /></p>
<p><em>图 9 - 非 <code>Serializable</code> 对象无法被序列化的麻烦</em></p>
<p><strong>在实例变量无法（或不应）被保存时，就要把他标记为 <em>瞬态</em> 实例变量（Mark an instance variable as <em>transient</em> if it can't (or shouldn't) be saved）</strong>。</p>
<p>若希望某个实例变量跳过对象的序列化过程，那么就要使用 <code>transient</code> 关键字，对该变量进行标记。</p>
<pre><code class="language-java">import java.net.*;

class Chat implements Serializable {
    // 关键字 transient, 说的是 “在序列化期间不要
    // 保存这个变量，只要跳过他就好。”
    transient String currentID;

    // 在序列化期间，变量 userName 将被保存为该对象
    // 的一部分。
    String userName;

    // 其他代码
}
</code></pre>
<p>在有着一个因为本身不是可序列化，而无法被保存的实例变量时，就可以使用 <code>transient</code> 关键字对那个变量进行标记，从而序列化过程就会精准地跳过他。</p>
<p><strong>然而一个变量无法被序列化的原因又究竟为何呢</strong>？其中可能简单地就是，那个类的设计者仅仅是 <em>忘了</em> 把其构造为对 <code>Serializable</code> 接口进行实现。或者由于对象依赖于一些特定于运行时信息，因此就直接无法保存。虽然 Java 类库中绝大多数物件都是可序列化的，但对于诸如网络连接、线程或文件对象等物件，是无法保存的。这些物件，全都依赖于（特定于）某种特别运行时 “体验”。也就是说，这些对象是以专为所编在程序，在特定平台上、在特定的JVM中的一次特定运行，而进行初始化的。一旦程序关闭，就没有了将这些物件，以任何有意义的方式，再复活过来的办法；这些对象，每次都要从头创建出来（So why would a variable not be seralizable? It could be that the class designer simply <em>forgot</em> to make the class implement <code>Serializable</code>. Or it might be because the object relies on runtime-specific information that simply can't be saved. Although most things in the Java class libraries are serializable, you can't save things like network connections, threads, or file systems. They're all dependent on (and specific to) a particular runtime 'experience'. In other words, they're instantiated in a way that's unique to a particular run of your program, on a particular platform, in a particular JVM. Once the program shuts down, there's no way to bring those thins back to life in any meaningful way; they have to be created from scratch each time）。</p>
<h2 id="答疑-14"><a class="header" href="#答疑-14">答疑</a></h2>
<ul>
<li><strong>既然序列化如此重要，那为何不是全部类都默认可序列化呢？为何类 <code>Object</code> 没有实现 <code>Serializable</code> 接口，这样所有子类就自动地可被序列化了呀</strong>？</li>
</ul>
<blockquote>
<p>尽管绝大多数类都会，且都应对 <code>Serializable</code> 接口进行实现，不过仍然可以选择选择不予实现此接口。对于所设计的类，必须逐一审视，在是否要通过实现 <code>Serializable</code> 来 “开启” 序列化功能上，作出慎重决定。那么首先，如果序列化作为默认了，又该怎样把他关掉呢？<strong>接口就意味着功能，而非功能的消减（Interfaces indicate functionality, not a <em>lack</em> of functionality）</strong>，那么如果这样来告诉外部世界某个对象无法保存：<code>implements NonSerializable</code>，多态机制模型就会无法正确运作了。</p>
</blockquote>
<ul>
<li><strong>究竟为何要编写一个不可序列化的类</strong>？</li>
</ul>
<blockquote>
<p>编写不可序列化类的理由极少，比如在不希望某个口令对象被存储起来地方，如果将其编写为可序列化对象而被保存了起来，那么就会有着安全问题。有比如在有着某个由于其关键实例变量就是不可序列化的他们本身，而保存起来没什么意义的类时，那么这个时候如果再把他们构造为可序列化的类，就没有什么有用处，多此一举了（There are very few reasons, but you might, for example, have a security issue where you don't want a password object stored. Or you might have an object that makes no sense to save, because its key instance variables are themselves not serializable, so there's no useful way for you to make your class serializable）。</p>
</blockquote>
<ul>
<li><strong>在所使用的类不是可序列化的，又没有什么好的理由去来让这个类不可序列化（仅仅由于这个类的设计者忘记给这个类实现 <code>Serializable</code> 接口，或由于其设计者的愚蠢），那么可以对这个“不良”的类进行子类化，从而将子类构造为可序列化的吗</strong>？</li>
</ul>
<blockquote>
<p>当然可以！在类本身为可扩展时（即非 <code>final</code>），就可以构造一个可序列化子类，并只要在那些期望那个超类类型的地方，用这个子类去替换即可。（请记住，多态机制是允许这样做的。）不过这又提出了另一个有趣的问题：超类不可序列化究竟意味着什么呢？</p>
</blockquote>
<ul>
<li><strong>你所提到的：从不可序列化类构造出可序列化类，意味着什么</strong>？</li>
</ul>
<blockquote>
<p>这里就要先看看在类解序列化时，会发生什么，（后面很快就会讨论到这个问题）。简而言之，在对象被解序列化且对象的超类为不可序列化的情况下，那么其超类的构造器就会运行，从而创建出那种类型的一个对象来。在没有让某个类成为不可序列化类的适当理由的情况下，那么构造一个可序列化的子类，将是一种良好的做法（In a nutshell, when an object is deserialized and its superclass is not serializable, the superclass constructor will run just as though a new object of that type were bebing created. If there's no decent reason for a class to not be serializable, make a serializable subclass might be a good solution）。</p>
</blockquote>
<ul>
<li><strong>噢！我是不是发现了了不起的东西......只要使某个变量成为“瞬态（<code>transient</code>）”，就意味着在序列化过程中该变量的值被跳过。那么这个瞬态变量究竟发生了什么？这里通过将不可序列化实例变量构造为瞬态变量的方式，解决了实例变量不可序列化问题，然而在将其所属对象复活时，难道就不再需要那个瞬态变量了吗？也就是说，难道整个序列化操作的目的，不就是保留对象的状态吗</strong>？</li>
</ul>
<blockquote>
<p>是的，这确实是个问题，不过幸运的是，有办法解决这个问题。在对某个对象进行序列化操作时，不论瞬态引用实例变量在保存时的值为何，他们都将将恢复到 <code>null</code>。这就意味着连接到那个特定实例变量的整个对象图面，都不会被保存。显然，这样处理会有坏处，因为可能需要那个变量为非空值（Yes, this is an issue, but fortunately there's a solution. If you serialize an object, a transient reference instance variable will be brought back as <code>null</code>, regardless of the value it had at the time it was saved. That means the entire object graph connected to that particular instance variable won't be saved. This could be bad, obviously, because you probably need a <code>non-null</code> value for that variable）。</p>
<p>这个时候就有两个选项：</p>
<ol>
<li>
<p>在将对象恢复过来时，将那个 <code>null</code> 的实例变量，重新初始化回某种默认状态。在所解序列化的对象不依赖特定值的那个瞬态变量时，这种做法是可行的。也就是比如对于<code>Dog</code>对象，带有一个 <code>Collar</code> 的属性，就比较重要，而或许所有的 <code>Collar</code> 对象都是同样的，那么在给到所有复活过来的 <code>Dog</code> 一个全新的 <code>Collar</code>，就无关紧要；没有人会知道其中的差别（When the object is brought back, reinitialize that <code>null</code> instance variable back to some default state. This works if your deseralized object isn't dependent on a particular value for that transient variable. In other words, it might be important that the <code>Dog</code> have a <code>Collar</code>, but perhaps all <code>Collar</code> objects are the same so it doesn't matter if you give the resurrected <code>Dog</code> a brand new <code>Collar</code>; nobody will know the difference）。</p>
</li>
<li>
<p>在瞬态变量的取值确实至关重要时（比如每个 <code>Dog</code> 对象的瞬态变量 <code>Collar</code> 的颜色与式样都不相同），那么就需要对 <code>Collar</code> 的关键属性值进行保存，并在复活 <code>Dog</code> 对象时，使用这些关键属性值来再造一个与原先一致的全新 <code>Collar</code> 对象出来。</p>
</li>
</ol>
</blockquote>
<ul>
<li><strong>若对象图面中的两个对象引用变量，指向了相同对象，这个时候会怎样呢？比如说，在 <code>Kennel</code> 中有两个不同的 <code>Cat</code> 对象引用变量，但这两个<code>Cat</code>引用变量都是同一具体对象的引用。那么那个具体<code>Cat</code>对象会被保存两次吗？我倒希望不会</strong>。 </li>
</ul>
<blockquote>
<p>非常棒的问题！Java的序列化特性是足够聪明的，可以了解到图面中那两个对象是同样的。在图面中有两个同样对象时，那么就只有其中一个会被保存，而在解序列化过程中，所有到那个对象引用，都会被恢复出来。</p>
</blockquote>
<h2 id="解序列化恢复对象"><a class="header" href="#解序列化恢复对象">解序列化：恢复对象</a></h2>
<p><strong>Deserialization: restoring an object</strong></p>
<p><img src="images/Ch14_10.png" alt="序列化对象与解序列化对象" /></p>
<p><em>图 10 - 序列化对象与解序列化对象</em></p>
<p>给对象进行序列化的关键，就是在往后某一天，与不同JVM的“运行”里（甚至在不同于对象被序列化时所运行的同一JVM里），可以把对象恢复到其原本状态。解序列化与序列化十分相像，只是过程相反。</p>
<ol>
<li>
<p><strong>构造一个 <code>FileInputStream</code></strong></p>
<pre><code class="language-java">// 构造一个 FileInputStream 对象。这里的 FileInputStream 就
// 知道怎样去连接上要给既有的文件。
//
// 在文件 &quot;MyGame.ser&quot; 不存在时，将得到一个异常。
FileInputStream fileStream = new FileInputStream(&quot;MyGame.ser&quot;);
</code></pre>
</li>
<li>
<p><strong>构造一个 <code>ObjectInputStream</code></strong></p>
<pre><code class="language-java">// ObjectInputStream 允许读取对象，但他无法直接连接到某个
// 文件。他需要被链接到一个连接性流，这个示例中就是链接到
// 的一个 FileInputStream。
ObjectInputStream os = new ObjectInputStream(fileStream)
</code></pre>
</li>
<li>
<p><strong>读取那些对象</strong></p>
<pre><code class="language-java">// 在每次写下 readObject() 方法时，就获得了流中的下一个
// 对象。因此将以这些对象被写入的同样顺序，把这些对象读取
// 回来。若尝试读取多于写入的对象时，就会得到一个大大的异常。
Object one = os.readObject();
Object two = os.readObject();
Object three = os.readObject();
</code></pre>
</li>
<li>
<p><strong>对读取到的这些对象，进行类型强制转换</strong></p>
<pre><code class="language-java">// readObject() 方法的返回值是类型 Object 的（就跟
// ArrayList那里的情况一样），因此就必须将其强制
// 转换回所知的真实类型。
GameCharacter elf = (GameCharacter) one;
GameCharacter troll = (GameCharacter) two;
GameCharacter magician = (GameCharacter) three;
</code></pre>
</li>
<li>
<p><strong>关闭 <code>ObjectInputStream</code></strong></p>
<pre><code class="language-java">// 关闭了顶部的流也就关闭了其下的那些流，因此 FileInputStream
// （以及那个文件）就会自动关闭。
os.close();
</code></pre>
</li>
</ol>
<h3 id="解序列化期间发生了什么"><a class="header" href="#解序列化期间发生了什么">解序列化期间发生了什么？</a></h3>
<p><strong>What happens during deserialization</strong>?</p>
<p>在对象被解序列化时，JVM尝试通过在内存堆上构造一个新的、与对象在被序列化时有着同样状态的对象，来把对象复活过来。当然，这是排除了那些瞬态变量的，那些瞬态变量要么以<code>null</code>值（对于那些对象的引用变量）再现，要么以默认原生值再现。</p>
<p><img src="images/Ch14_11.png" alt="对象解序列化的过程" /></p>
<p><em>图 11 - 对象解序列化的过程</em></p>
<ol>
<li>
<p>从流 <strong>读取到</strong> 对象；</p>
</li>
<li>
<p>JVM推断出对象的 <strong>类类型</strong>（通过序列化的对象中存储的信息，The JVM determines (through info stored with the serialized object) the object's <strong>class type</strong>）；</p>
</li>
<li>
<p>JVM 尝试 <strong>找到并加载</strong> 该对象的 <strong>类</strong>。若 JVM 无法找到并/或加载该类，那么 JVM 就会抛出一个异常，同时解序列化宣告失败（The JVM attempts to <strong>find and load</strong> the object's <strong>class</strong>. If the JVM can't find and/or load the class, the JVM throws an exception and the deserialization fails）；</p>
</li>
<li>
<p>在内存堆上，一个新的对象被分配到空间，但 <strong>被序列化对象的构造器并 <em>不会</em> 运行</strong>！显然，若该构造器运行，就会把那个对象的状态，恢复到其原本的“新”状态，不过这并不是这里所想要的。这里要的时对象被恢复到他被序列化时所具有的状态，而不是他最开始被创建出时的状态（A new object is given space on the heap, but the <strong>serialized object's constructor doess NOT run</strong>! Obviously, if the constructor ran, it would restore the state of the object back to its original 'new' state, and that's not what we want. We want the object to be restored to the state it had <em>when it was serialized</em>, not when it was first created）;</p>
</li>
<li>
<p>若该对象在其继承树往上的某处，有着一个不可序列化类，那么随着这个不可序列化类之上的其他全部构造器的运行（即使这些往上的类是可序列化的）， <strong>那个不可序列化类的构造器也将运行起来</strong>。一旦构造器链式运行起来，就无法停止了，这就意味着从第一个不可序列化类开始的所有超类，都会重新初始化出他们的状态（If the object has a non-serializable class somewhere up its inheritance tree, the <strong>constructor for that non-serializable class will runn</strong> along with any constructors above that(even if they're serializable). Once the constructor chaining begins, you can't stop it, which means all superclasses, beginning with the first non-serializable one, will reinitialize their state）;</p>
</li>
<li>
<p>对象的 <strong>那些实例变量，都被赋予到来自序列化状态时的值</strong>。那些瞬态变量，被赋予对象引用变量的默认值 <code>null</code>，以及原生类型下相应的默认值（<code>0</code>、<code>false</code>等等）。</p>
</li>
</ol>
<h2 id="答疑-15"><a class="header" href="#答疑-15">答疑</a></h2>
<ul>
<li><strong>为何类没有作为对象的一部分，被保存起来？那样的话，就不存在类不会被找到的问题了</strong>。</li>
</ul>
<blockquote>
<p>确实，Java/JVM 的设计者们原本可以让序列化特性以那种方式运作。不过那样会造成巨大的浪费和开销。相比于运用序列化特性，将对象写到本地硬盘上的某个文件这种不是那么拮据的操作，那么通过序列化特性而通过网络来发送对象，就会困难得多。若把类绑定到各个被序列化（可传送）的对象，那么对带宽的要求就要比现在大得多（Sure, they could have made serialization work that way. But what a tremendous waste and overhead. And while it might not be such a hardship when you're using serialization is also used to send objects over a network connection. If a class was bundled with each serialized (shippable) object, bandwidth would become a much larger problem than it already is）。</p>
<p>然而对于那些被序列化来透过网络传输的对象，实际上有着一种，可将此种序列化对象 “盖戳上” 一个，表示在何处可以找到他的类的URL的机制。这个机制在 Java 的远程方法调用中有运用到，从而可以将序列化对象，作为方法参数的一部分进行传送，这个时候如果接收到的调用的JVM没有这个类，那么JVM就可以使用该URL，来从网络获取到这个类并进行加载，此过程全部是自动进行的。（在第 17 章将讨论到RMI，For objects serialized to ship over a network, though, there actually is a mechanism where the serialized object can be 'stamped' with a URL for where its class can be found. This is used in Java's Remote Method Invocation(RMI) so that you can send a serialized object as part of, say, a method argument, and if the JVM receiving the call doesn't have the class, it can use the URL to fetch the class from the network and load it, all automatically. (We'll talk about RMI in chapter 17.)）</p>
</blockquote>
<ul>
<li><strong>那些静态变量呢？他们会被序列化吗</strong>？</li>
</ul>
<blockquote>
<p>不会。请记住，静态就表示“每个类一个”，而不是“每个对象一个”。静态变量不被保存，且在某个对象被解序列化时，该对象的类 <em>当前</em> 有什么静态变量，那么该对象就会有什么静态变量。谨记：不要构造那些对动态改变的静态变量有依赖的可序列化对象！那样的话在恢复出对象时，就会出现与原先不一致的情况（Nope. Remember, static means &quot;one per class&quot; not &quot;one per object&quot;. Static variables are not saved, and when an object is deserialized, it will have whatever static variable its calss <em>currently</em> has. The moral: don't make serializable objects dependent on a dynamically-changing static variable! It might not be the same when the object comes back）。</p>
</blockquote>
<h2 id="游戏角色的保存与恢复"><a class="header" href="#游戏角色的保存与恢复">游戏角色的保存与恢复</a></h2>
<p><strong>Saving and restoring the game characters</strong></p>
<pre><code class="language-java">
package com.xfoss.learningJava;

import java.io.*;
import com.xfoss.Utils.*;

public class GameSaverTest {
    public static void main (String[] args) {
        // 构造一些角色......
        GameCharacter one = new GameCharacter(50, &quot;Elf&quot;, new String[] {&quot;bow&quot;, &quot;sword&quot;, &quot;dust&quot;});
        GameCharacter two = new GameCharacter(200, &quot;Troll&quot;, new String[] {&quot;bare hands&quot;, &quot;big ax&quot;});
        GameCharacter three = new GameCharacter(120, &quot;Magician&quot;, new String[] {&quot;spells&quot;, &quot;invisibility&quot;});

        XPlatformThings th = new XPlatformThings();
        String dataDir = th.getWorkingDir(&quot;learningJava&quot;);

        File dir = new File(dataDir);
        if(!dir.exists()) dir.mkdirs();
        
        String serFile = String.format(&quot;%s/GameCharacter.ser&quot;, dataDir);

        // 设想对这些角色进行操作的代码，可能改变这些角色的状态
        try {
            ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(serFile));
            os.writeObject(one);
            os.writeObject(two);
            os.writeObject(three);
            os.close();
        } catch (IOException ex) {ex.printStackTrace();}

        // 这里把这些角色设置为 null, 这样就无法在内存堆上访问到这些对象了
        one = null;
        two = null;
        three = null;

        try {
            // 现在从文件把这些角色读取回来......
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(serFile));
            GameCharacter oneRestore = (GameCharacter) is.readObject();
            GameCharacter twoRestore = (GameCharacter) is.readObject();
            GameCharacter threeRestore = (GameCharacter) is.readObject();
            is.close();

            // 检查一下这样的保存与读取是否可行。
            System.out.format(&quot;One's type: %s\n&quot;, oneRestore.getType());
            System.out.format(&quot;Two's type: %s\n&quot;, twoRestore.getType());
            System.out.format(&quot;Three's type: %s\n&quot;, threeRestore.getType());
        } catch (Exception ex) {ex.printStackTrace();}
    }
}
</code></pre>
<p><img src="images/Ch14_12.png" alt="对象序列化实例运行效果" /></p>
<p><em>图 12 - 对象序列化实例运行效果</em></p>
<h3 id="类-gamecharacter"><a class="header" href="#类-gamecharacter">类 <code>GameCharacter</code></a></h3>
<pre><code class="language-java">// 这是一个简单的仅用于测试序列化操作的类，同时这里也并没有一个
// 真正的游戏，不过实现游戏的过程，可以自己去完成。
package com.xfoss.learningJava;

import java.io.*;

public class GameCharacter implements Serializable {
    int power;
    String type;
    String [] weapons;

    public GameCharacter (int p, String t, String [] w) {
        power = p;
        type = t;
        weapons = w;
    }

    public int getPower () {
        return power;
    }

    public String getType () {
        return type;
    }

    public String getWeapons () {
        String weaponList = &quot;&quot;;

        for (int i = 0; i &lt; weapons.length; i++) {
            String.format(&quot;%s %s&quot;, weaponList, weapons[i]);
        }

        return weaponList;
    }
}
</code></pre>
<h2 id="对象序列化的重点"><a class="header" href="#对象序列化的重点">对象序列化的重点</a></h2>
<p><strong>Object Serialization, BULLET POINTS</strong></p>
<ul>
<li>通过将对象序列化，可保存对象的状态；</li>
<li>要序列化某个对象，就需要一个 <code>ObjectOutputStream</code>（来自 <code>java.io</code>包） 对象；</li>
<li>流要么是连接流，要么是链式流；</li>
<li>连接流可表示到源或目的地，典型的就是某个文件、网络套接字，或控制台，的一个连接；</li>
<li>链式流无法连接到源或目的地，而必须链接到连接（或其他）流；</li>
<li>要将对象序列化到文件，就要构造一个 <code>FileOutputStream</code> 对象，并将这个对象链接进入一个 <code>ObjectOutputStream</code>;</li>
<li>调用 <code>ObjectOutputStream</code> 对象上的 <em><code>writeObject(theObject)</code></em> 方法，来对这个 <code>theObject</code> 进行序列化。这里无需调用 <code>FileOutputStream</code> 上的那些方法；</li>
<li>对象要被序列化，就必须实现 <code>Serializable</code> 接口。在该类的超类实现了 <code>Serializable</code>，那么进行这个子类没有特别声明 <em>implements Serializable</em>，也自动成为可被序列化；</li>
<li>在对象被序列化时，他的整个对象图面都被序列化了。那就意味着被该序列化对象的那些实例变量所引用的全部对象，以及这些被引用对象所应用的全部对象......等等都被序列化了；</li>
<li>若图面中有任何对象不可被序列化，那么在运行时就会抛出异常，除非指向这个不可序列化对象的实例变量被跳过；</li>
<li>若希望序列化操作跳过某个变量，使用关键字 <code>transient</code> 标记这个变量即可。这个被 <code>transient</code> 关键字标记过的变量，将被恢复到 <code>null</code> （对于对象引用变量），或默认值（对于原生类型变量）；</li>
<li>在解序列化过程中，对象图面中所有对象的类，必须对JVM可用；</li>
<li>读取对象（使用 <code>readObject()</code> 方法）是以所读取的那些对象原先写入的顺序读出；</li>
<li><code>readObject()</code> 方法返回值类型为 <code>Object</code> 类型，因此解序列化出的对象，必须被强制转换（<code>cast</code>）到他们真实类型；</li>
<li>静态变量不会被序列化！将静态变量作为特定对象状态的一部分进行保存没有意义，因为那种类型的所有对象，都共享着仅仅这一个值 -- 就是类中的那个；</li>
</ul>
<h2 id="写入一个字符串到文本文件"><a class="header" href="#写入一个字符串到文本文件">写入一个字符串到文本文件</a></h2>
<p><strong>Writing a <code>String</code> to a <code>Text</code> File</strong></p>
<p>经由序列化特性保存对象，是在某个Java程序的不同运行之间，进行数据保存与恢复的最容易方式（Saving objects, through serialization, is the easiest way to save and restore data between runnings of a Java program）。不过有时候仍需要把数据保存到普通老式文本文件。设想有Java程序必须把数据，写入到某个其他（极有可能为非Java的）程序需要读取的简单文本文件。比如说，有这样一个Java编写的、获取用户输入到浏览器的表单数据的小服务程序（a servlet），并把这些表单数据，写入到一个其他程序也会加载到某个电子表单进而加以分析的文本文件。</p>
<p>写入文本数据（实际上是一个字符串），跟写入对象类似，只是写入的是一个字符串而不再是对象，还有使用的是 <code>FileWriter</code>而不是<code>FileOutputStream</code>（并且也不是链接到 <code>ObjectOutputStream</code>的）。</p>
<p><img src="images/Ch14_13.png" alt="以文本文件方式保存对象数据" /></p>
<p><em>图 13 - 以文本文件方式保存对象数据</em></p>
<p><strong>要写入序列化对象</strong>：</p>
<pre><code class="language-java">objectOutputStream.writeObject(someObject);
</code></pre>
<p><strong>而要写入一个字符串</strong>：</p>
<pre><code class="language-java">fileWriter.write(&quot;My first String to save&quot;);
</code></pre>
<pre><code class="language-java">// 这里需要 java.io 包来提供到 FileWriter 类
import java.io.*;

class WriteAFile {
    public static void main (String[] args) {
        // 所以 I/O 操作，都必须在一个 try/catch 代码块中。其中的
        // 全部操作都能抛出 IOException 异常！！
        try {
            // 如果这个 “Foo.txt” 文件不存在，FileWriter就会创建他。
            FileWriter writer = new FileWriter(&quot;Foo.txt&quot;);
            
            // write() 方法取的是一个字符串参数
            writer.write(&quot;hello foo!&quot;);

            // 在完成写入后要关闭这个 FileWriter 对象！
            writer.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
}
</code></pre>
<h2 id="文本文件示例e-flashcards"><a class="header" href="#文本文件示例e-flashcards">文本文件示例：<code>e-Flashcards</code></a></h2>
<p><strong>Text File Example: <code>e-Flashcards</code></strong></p>
<p>还记得上学时用过的那些学习卡片（flashcards）吗？那种卡片一面有个问题，背后就是问题的答案。虽然这些学习卡片对于掌握理解某些内容没有帮助，但用于简单操练和死记硬背，他们是无可比拟的。<em>尤其是在必须把某个事实刻入脑中的时候</em>。同时这样的卡牌，用于益智猜谜竞赛中也非常棒。</p>
<p><img src="images/Ch14_14.png" alt="老式3x5索引卡牌" /></p>
<p><em>图 14 - 老式3x5索引卡牌</em></p>
<p><strong>接下来就要构造以恶有三个类的电子版卡牌</strong>：</p>
<ol>
<li>
<p>类<code>QuizCardBuilder</code>，用于一套电子卡牌的创建及存储的一个简单创作工具；</p>
</li>
<li>
<p>类 <code>QuizCardPlayer</code>，一个可加载进一套电子卡牌，并给用户玩这套卡牌的回放引擎；</p>
</li>
<li>
<p>类<code>QuizCard</code>，一个表示卡牌数据的简单类。这里会贯穿卡牌构建器与卡牌播放器的代码，而把 <code>QuizCard</code>类留给读者自己取构造，使用下表：</p>
</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><b><code>QuizCard</code></b></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>QuizCard(q, a)</code></td></tr>
<tr><td style="text-align: left"><code>question</code> <br /> <code>answer</code></td></tr>
<tr><td style="text-align: left"><code>getQuestion()</code> <br /> <code>getAnswer()</code></td></tr>
</tbody></table>
</div>
<p><img src="images/Ch14_15.png" alt="QuizCardBuilder" /></p>
<p><em>图 15 - <code>QuizCardBuilder</code></em></p>
<p>有着带有用于把当前这套卡牌，保存到文本文件的 “保存” 选项的 “文件” 菜单。</p>
<p><img src="images/Ch14_16.png" alt="QuizCardPlayer" /></p>
<p><em>图 16 - <code>QuizCardPlayer</code></em></p>
<p>有着用于从文本文件加载一套卡牌的“加载”选项的“文件”菜单。</p>
<h3 id="quizcardbuilder-代码大纲"><a class="header" href="#quizcardbuilder-代码大纲"><code>QuizCardBuilder</code> （代码大纲）</a></h3>
<pre><code class="language-java">public class QuizCardBuilder {
    // 构建并显示GUI，包括事件收听者的构造与注册。
    public void go () {
        // GUI的构建及显示
    }

    // 内部类
    private class NextCardListener implements ActionListener {
        // 当用户点击 “下一卡片” 按钮时，触发这个事件处理
        // 方法；表示用户希望把那个卡片存储在清单中，并
        // 开始制作一张新卡片。
        public void actionPerformed (ActionEvent ev) {
            // 将当前卡牌添加到清单并清空那两个文本区
        }
    }

    // 内部类
    private class SaveMenuListener implements ActionListener {
        // 在用户选择了文件菜单中的 “保存” 菜单项时触发
        // 这个事件处理方法；表示用户希望以“套”的形式
        // （比如，“量子力学卡套（Quantum Mechanics Set）”，“好莱坞
        // 趣闻（Hollywood Trivia）”，“Java规则集”等等），保存当前
        // 清单中的全部卡片。
        public void actionPerformed (ActionEvent ev) {
            // 拉起一个文件对话框
            // 让用户命名并保存这套卡片
        }
    }

    // 内部类
    private class NewMenuListener implements ActionListener {
        // 在点选了文件菜单中的“新建”菜单项后触发这个事件处理
        // 方法；表示用户希望开始创建一套全新卡片（因此就要
        // 情况卡片清单及文本区）。
        public void actionPerformed (ActionEvent ev) {
            // 清空卡片清单，还要情况那两个文本区
        }
    }

    // 此方法被 SaveMenuListener 调用；完成具体的文件写入。
    private void saveFile(File file) {
        // 对卡片清单进行遍历，并把各个卡片，以可解析的方式（也就是
        // 在卡片各个部分之间有明确的间隔），写入到一个文本文件
    }
}
</code></pre>
<h3 id="quizcardbuilder-代码"><a class="header" href="#quizcardbuilder-代码"><code>QuizCardBuilder</code> 代码</a></h3>
<pre><code class="language-java">package com.xfoss.QuizCard;

import java.util.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.net.*;

public class QuizCardBuilder {
    private JTextArea question;
    private JTextArea answer;
    private ArrayList&lt;QuizCard&gt; cardList;
    private JFrame frame;

    public static void main (String[] args) {
        QuizCardBuilder builder = new QuizCardBuilder();
        builder.go();
    }

    private void go() {
        // 构建出 GUI
        // 
        // 这里全是 GUI 的代码。没有什么特别的，不过可能会
        // 看看这里的 MenuBar、Menu及 MenuItems 等代码。
        frame = new JFrame(&quot;测试卡构建器&quot;);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        URL icoURI = getClass().getResource(&quot;/images/flashcards.png&quot;);
        ImageIcon ico = new ImageIcon(icoURI);
        frame.setIconImage(ico.getImage());

        JPanel mainPanel = new JPanel();

        Font bigFont = new Font(&quot;sanserif&quot;, Font.BOLD, 24);

        question = new JTextArea(6, 20);
        question.setLineWrap(true);
        question.setWrapStyleWord(true);
        question.setFont(bigFont);

        JScrollPane qScroller = new JScrollPane(question);
        qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        answer = new JTextArea(6, 20);
        answer.setLineWrap(true);
        answer.setWrapStyleWord(true);
        answer.setFont(bigFont);

        JScrollPane aScroller = new JScrollPane(answer);
        aScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        aScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        JButton nextBtn = new JButton(&quot;下一卡片&quot;);
        nextBtn.addActionListener(new NextCardListener());

        cardList = new ArrayList&lt;QuizCard&gt; ();

        JLabel qLabel = new JLabel(&quot;问题：&quot;);
        JLabel aLabel = new JLabel(&quot;答案：&quot;);

        mainPanel.add(qLabel);
        mainPanel.add(qScroller);
        mainPanel.add(aLabel);
        mainPanel.add(aScroller);
        mainPanel.add(nextBtn);

        // 这里构造了一个菜单栏，一个文件菜单，随后把
        // &quot;新建&quot; 与 “保存” 菜单项放入到文件菜单。然后
        // 把这个菜单添加到菜单栏，并告诉视窗框使用这个
        // 菜单栏。菜单项可以发起 ActionEvent 事件。
        JMenuBar menuBar = new JMenuBar();
        JMenu fileMenu = new JMenu(&quot;文件（F）&quot;);

        JMenuItem newMenuItem = new JMenuItem(&quot;新建（N）&quot;);
        newMenuItem.addActionListener(new NewMenuItemListener());

        JMenuItem saveMenuItem = new JMenuItem(&quot;保存（S）&quot;);
        saveMenuItem.addActionListener(new SaveMenuItemListener());

        fileMenu.add(newMenuItem);
        fileMenu.add(saveMenuItem);

        menuBar.add(fileMenu);

        frame.setJMenuBar(menuBar);
        frame.getContentPane().add(BorderLayout.CENTER, mainPanel);
        frame.setSize(480, 640);
        frame.setVisible(true);
    }

    private class NextCardListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            if(question.getText().length() &gt; 0 &amp;&amp; answer.getText().length() &gt; 0) {
                QuizCard card = new QuizCard(question.getText(), answer.getText());
                cardList.add(card);
                clearCard();
            }

            question.requestFocus();
        }
    }

    private class NewMenuItemListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            cardList.clear();
            clearCard();
        }
    }

    private class SaveMenuItemListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            QuizCard card = new QuizCard(question.getText(), answer.getText());
            cardList.add(card);

            // 这里拉起（bring up） 一个文件对话框并等待用户选择对话框
            // 中的 “保存”按钮。文件对话框的全部导航及文件选择工作等，都是
            // 由 JFileChooser 替咱们完成的！就这么容易。
            JFileChooser fileSave = new JFileChooser();
            fileSave.showSaveDialog(frame);
            saveFile(fileSave.getSelectedFile());
        }
    }

    private void clearCard () {
        question.setText(&quot;&quot;);
        answer.setText(&quot;&quot;);
        question.requestFocus();
    }

    // 正是这个方法，完成文件写入（由 SaveMenuListener 的事件处理器调用）。
    // 这里的参数就是那个用户要保存的 'File' 对象。在后面就会讨论到类 File。
    private void saveFile (File f) {
        try {
            // 这里把一个 BufferedWriter 对象，链接到一个新创建的 FileWriter
            // 对象上，以令到写入更加高效（稍后不久就会讨论到这个问题）。
            BufferedWriter writer = new BufferedWriter(new FileWriter(f));

            // 对这个 QuizCard 的 ArrayList 进行遍历，并将这些卡片写出来，每行
            // 一张卡片，其中的问题与答案之间用 “/” 分隔开，之后每行在加上
            // 一个另起一行字符（“\n”）
            for (QuizCard c:cardList) {
                if(c.getQuestion().length() &gt; 0 &amp;&amp; c.getAnswer().length() &gt; 0)
                    writer.write(String.format(&quot;%s/%s\n&quot;, c.getQuestion(), c.getAnswer()));
            }

            writer.close();
        } catch (IOException ex) {
            System.out.println(&quot;无法将卡片清单 cardList 写出&quot;);
            ex.printStackTrace();
        }
    }
}

class QuizCard {
    private String question;
    private String answer;

    public QuizCard(String q, String a) {
        question = q;
        answer = a;
    }

    public String getQuestion () {return question;}
    public String getAnswer() {return answer;}
}
</code></pre>
<p><img src="images/Ch14_17.png" alt="QuizCardBuilder运行效果" /></p>
<p><em>图 17 - <code>QuizCardBuilder</code>运行效果</em></p>
<h2 id="类-javaiofile"><a class="header" href="#类-javaiofile">类 <code>java.io.File</code></a></h2>
<p>类 <code>java.io.File</code> <em>代表（represents）</em> 磁盘上的某个文件，但并不具体表示那个文件的 <em>内容（contents）</em>。不明白？把 <code>File</code> 对象当作某个文件的 <em>路径名称（pathname）</em> （或者甚至某个 <em>目录（directory）</em>），而非那个真实文件本身就好。类 <code>File</code> 本身就不具有比如读取和写入这样的方法。使用 <code>File</code> 对象来表示磁盘文件，与仅使用一个字符串来表示相比，一个非常有用的地方，就在于这样做是更加安全的方式。那些构造器接收字符串文件名的大多数类（诸如 <code>FileWriter</code> 或 <code>FileInputStream</code>），同时也能接收 <code>File</code> 对象。可构建出一个 <code>File</code> 对象，而通过这个对象，完成诸如路径有效性验证等检查，并于随后把这个文件对象，提供给 <code>FileWriter</code> 或  <code>FileInputStream</code>。</p>
<blockquote>
<p><strong><code>File</code> 对象表示的，是磁盘上文件或目录的名字及路径，比如</strong>：</p>
<p><code>/User/Kathy/Data/GameFile.txt</code></p>
<p><strong>但 <code>File</code> 对象并不代表文件 <em>中的</em> 数据，也并未给到对文件中数据的访问</strong>！</p>
</blockquote>
<p><img src="images/Ch14_18.png" alt="File对象与磁盘文件及文件内部数据" /></p>
<p><em>图 18 - <code>File</code>对象与磁盘文件及文件内部数据</em></p>
<h3 id="使用-file-对象可以完成的一些事情"><a class="header" href="#使用-file-对象可以完成的一些事情">使用 <code>File</code> 对象可以完成的一些事情</a></h3>
<ol>
<li>
<p><strong>构造一个表示既有文件的 <code>File</code> 对象</strong></p>
<pre><code class="language-java">File f = new File(&quot;MyCode.txt&quot;);
</code></pre>
</li>
<li>
<p><strong>新建一个目录</strong></p>
<pre><code class="language-java">File dir = new File(&quot;Chapter7&quot;);
dir.mkdir();
</code></pre>
</li>
<li>
<p><strong>列出某个目录的内容</strong></p>
<pre><code class="language-java">if (dir.isDirectory()) {
    String[] dirContents = dir.list();
    for (int i = 0; i &lt; dirContents.length; i++) {
        System.out.println(dirContents[i]);
    }
}
</code></pre>
</li>
<li>
<p><strong>获取文件或目录的绝对路径</strong></p>
<pre><code class="language-java">System.out.println(dir.getAbsolutePath());
</code></pre>
</li>
<li>
<p><strong>删除某个文件或目录（删除成功时返回 <code>true</code>）</strong></p>
<pre><code class="language-java">boolean isDeleted = f.delete();
</code></pre>
</li>
</ol>
<h2 id="缓存之美"><a class="header" href="#缓存之美">缓存之美</a></h2>
<p><strong>The beauty of buffers</strong></p>
<p><strong>没有缓存器，就如同逛超市没有购物推车。就不得不把买的东西一件件地搬到车上，一次拿一个汤罐头或一卷厕纸</strong>。</p>
<p><img src="images/Ch14_19.png" alt="缓存器与购物推车" /></p>
<p><em>图 19 - 缓存器与购物推车</em></p>
<p><img src="images/Ch14_20.png" alt="缓存器在写入文件中的作用" /></p>
<p><em>图 20 - 缓存器在写入文件中的作用</em></p>
<pre><code class="language-java">// 请注意这里甚至不需要保留一个到FileWriter 对象的引用（注：即并没有
// 为这个对象设置一个变量）。这里只关心这个 BufferedWriter，因为正是
// 要调用这个对象上的方法，且在关闭这个 BufferedWriter 时，这个对象
// 同时会照顾到该数据写入链条上的其余部分。
BufferedWriter writer = new BufferedWriter(new FileWriter(aFile));
</code></pre>
<p>缓存酷的地方，在于比起不使用缓存，他们的效率高很多。可通过调用 <code>FileWriter</code>对象上的 <code>write(someString)</code>，单独使用 <code>FileWriter</code> 来写入某个文件，不过 <code>FileWriter</code> 是每次一个地写入传递给他的东西。而相比于操作内存中的数据，每次去访问磁盘就是件十分耗时的事情，由于这个原因，直接使用 <code>FileWriter</code> 每次一个地写入，就带来我们所不希望的开销。而通过在 <code>FileWriter</code> 上连接一个 <code>BufferedWriter</code>时，这个 <code>BufferedWriter</code>就会在缓存放满之前，把要写入的东西暂时留存起来。<em>只有在缓存充满时，才会告诉 <code>FileWriter</code> 往磁盘上的文件写入</em>。</p>
<p>若希望在缓存尚未充满前就要发送其中的数据，可是可以的。<em><strong>只需刷新缓存即可（Just flush it）</strong></em>。调用 <code>writer.flush()</code> 就是说，“发送缓存中的内容，立即！”</p>
<h2 id="从文本文件读取数据"><a class="header" href="#从文本文件读取数据">从文本文件读取数据</a></h2>
<p><strong>Reading from a Text File</strong></p>
<p>从文件读取文本是简单的，不过这里要使用一个 <code>File</code> 对象来表示那个文件，使用一个 <code>FileReader</code> 来完成实际读取，还要使用一个<code>BufferedReader</code>，来令到读取更具效率。</p>
<p>读取是通过在一个 <em><code>while</code></em> 的循环中，去读取那些行进行，在 <code>readLine()</code> 返回结果为 <code>null</code> 时，终止这个循环。这也正是数据读取（针对几乎所有非序列化对象的那些数据）最常见的方式：在 <code>while</code> 循环（实际上是<code>while</code> 循环的 <em>条件测试</em>）中，进行数据读取，在没有东西要读取时循环终止（因为不论使用何种读取方法，其结果都是 <code>null</code>，故直到已经读取完毕）。</p>
<p><img src="images/Ch14_21.png" alt="一个有着两行文本的文件" /></p>
<p><em>图 21 - 一个有着两行文本的文件</em></p>
<pre><code class="language-java">package com.xfoss.learningJava;

import java.io.*;
import java.util.Objects;
import com.xfoss.Utils.*;

public class ReadFile {
    public static void main (String[] args) {
        XPlatformThings xpt = new XPlatformThings();
        String wd = xpt.getWorkingDir(&quot;learningJava&quot;);

        try {
            File f = new File(String.format(&quot;%s/data/MyText.txt&quot;, wd));
            // 这里的FileReader，时用于字符的、连接到某个文本文件的连接流
            FileReader fReader = new FileReader(f);

            // 这里将这个 FileReader 连接到一个 BufferedReader，目的是
            // 更高效的读取数据。这样就只会在缓存为空时（因为这个程序要
            // 读取文件中的全部数据），才回到文件去读取。
            BufferedReader reader = new BufferedReader(fReader);

            // 构造一个字符串变量，用来在每次读取行时，留存住这个行
            String line = null;
            // 这里讲了 “读取一行文本，并将其赋值给这个字符串变量'line'.
            // 在那个变量不为 'null'时（由于在这之前还有东西可读）把刚
            // 读取到的那行打印出来。”
            //
            // 或者以另外一种讲法，“在仍有文本行可读取的情况下，对这些文本
            // 行加以读取并打印出来。”
            while(!Objects.isNull(line = reader.readLine())) {
                System.out.println(line);
            }
            reader.close();
        } catch (Exception ex) {}
    }
}
</code></pre>
<p><img src="images/Ch14_22.png" alt="一个有三行文本的文本文件" /></p>
<p><em>图 22 - 一个有三行文本的文本文件</em></p>
<p><img src="images/Ch14_23.png" alt="ReadFile的输出" /></p>
<p><em>图 23 - <code>ReadFile</code>的输出</em></p>
<h2 id="quizcardplayer-代码大纲"><a class="header" href="#quizcardplayer-代码大纲"><code>QuizCardPlayer</code> （代码大纲）</a></h2>
<p><strong><code>QuizCardPlayer</code> (code outline)</strong></p>
<pre><code class="language-java">public class QuizCardPlayer {
    public void go () {
        // 构建并显示 GUI
    }

    class NextCardListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            // 若这是个问题，那么就展示其答案，否则就显示下一问题
            // 对一个用于表示是在查看问题还是答案的标志标量进行设置
        }
    }

    class OpenMenuListener implements Action Listener {
        public void actionPerformed (ActionEvent ev) {
            // 拉起一个文件对话框（bring up a file dialog box）
            // 让用户导航到某个卡片集，并选中要打开的卡片集
        }
    }

    private void loadFile(File file) {
        // 这里必须通过从文本文件读取一些卡片，然后构建出
        // 一个卡片的 ArrayList
        //
        // 此方法是从 OpenMenuListener 事件处理器中进行调用的，以一次
        // 读取一行的方式来读取文件，并让 makeCard() 方法来从读取到的行
        // 构造出新的卡片
        //
        // （文件中的一行，同时保存了问题与答案，问题与答案通过一个 '/'
        // 分隔开）
    }

    private void makeCard(String lineToParse) {
        // 由 loadFile() 方法调用，从文本文件拿到一行并
        // 将改行解析为两个片段 -- 问题与答案 -- 还要创建出一个
        // 新的 QuizCard 对象出来，然后把这个新的 QuizCard 对象添加
        // 到名为 CardList 的 ArrayList
    }
}
</code></pre>
<h2 id="quizcardplayer-代码"><a class="header" href="#quizcardplayer-代码"><code>QuizCardPlayer</code> 代码</a></h2>
<pre><code class="language-java">package com.xfoss.QuizCard;

import java.util.*;
import java.awt.event.*;
import javax.swing.*;
import java.awt.*;
import java.io.*;

public class QuizCardPlayer extends JFrame {

    private JTextArea display;
    private ArrayList&lt;QuizCard&gt; cardList;
    private QuizCard currentCard;
    private int currentCardIndex;
    private JButton nextBtn;
    private boolean isShowAnswer;

    public static void main (String[] args) {
        QuizCardPlayer player = new QuizCardPlayer();
    }

    // 这个构造函数，就相当于之前的方法 go(), 用来构建 GUI
    // 并省略了 main() 方法中的一个对 go() 的调用
    public QuizCardPlayer () {
        // 构建 GUI
        super(&quot;测试卡播放器&quot;);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JPanel mainPanel = new JPanel();
        Font bigFont = new Font(&quot;sanserif&quot;, Font.BOLD, 24);

        display = new JTextArea(10, 20);
        display.setFont(bigFont);
        display.setLineWrap(true);
        display.setEditable(false);

        JScrollPane qScroller = new JScrollPane(display);
        qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        nextBtn = new JButton(&quot;给出问题&quot;);
        nextBtn.addActionListener(new NextCardListener());
        nextBtn.setEnabled(false);

        mainPanel.add(qScroller);
        mainPanel.add(nextBtn);

        JMenuBar menuBar = new JMenuBar ();

        JMenu fileMenu = new JMenu(&quot;文件（F）&quot;);
        fileMenu.setMnemonic(KeyEvent.VK_F);

        JMenuItem loadMenuItem = new JMenuItem(&quot;加载卡片集（L）&quot;);
        loadMenuItem.setMnemonic(KeyEvent.VK_L);
        loadMenuItem.addActionListener(new OpenMenuListener());

        JMenuItem quitMenuItem = new JMenuItem(&quot;退出（Q）&quot;);
        quitMenuItem.addActionListener(new QuitMenuItemListener());
        quitMenuItem.setMnemonic(KeyEvent.VK_Q);

        fileMenu.add(loadMenuItem);
        fileMenu.add(quitMenuItem);
        menuBar.add(fileMenu);

        setJMenuBar(menuBar);
        getContentPane().add(BorderLayout.CENTER, mainPanel);
        setSize(640, 500);
        setVisible(true);
    }

    private class QuitMenuItemListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            dispose();
            System.exit(0);
        }
    }

    private class NextCardListener implements ActionListener {
        // 这里对 isShowAnswer 这个布尔值标志进行检查，从而获悉
        // 用户当前所查看的，究竟是问题还是答案，并根据具体情况
        // 来进行适当的操作。
        public void actionPerformed (ActionEvent ev) {
            if (isShowAnswer) {
                display.setText(currentCard.getAnswer());
                nextBtn.setText(&quot;下一卡片&quot;);
                isShowAnswer = false;
            } else {
                if (currentCardIndex &lt; cardList.size()) showNextCard();
                else {
                    display.setText(&quot;这已是最后一张卡片。&quot;);
                    nextBtn.setEnabled(false);
                }
            }
        }
    }

    private class OpenMenuListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            // 拉起文件对话框并让用户进行导航，从而选择要打开的文件。
            JFileChooser fileOpen = new JFileChooser();
            fileOpen.showOpenDialog(QuizCardPlayer.this);
            loadFile(fileOpen.getSelectedFile());
        }
    }

    private void loadFile(File file) {
        cardList = new ArrayList&lt;QuizCard&gt; ();

        try {
            // 构造一个链接到新的 FileReader 对象的 BufferedReader 对象
            // 把用户从“打开文件”对话框中选择的文件对象，交给这里的
            // FileReader 对象。
            //
            // 这里一次读取一行，然后把读到的行传递给对其进行解析
            // 并将其转换到真正 QuizCard 对象、然后把这个对象添加到
            // ArrayList 的 makeCard() 方法。
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String line = null;
            while ((line = reader.readLine()) != null) {
                makeCard(line);
            }
            nextBtn.setEnabled(true);
            reader.close();
        } catch (Exception ex) {
            System.out.println(&quot;无法读取卡片集文件&quot;);
            ex.printStackTrace();
        }
    }

    private void makeCard (String lineToParse) {
        // 每行文本对应单个的卡片，不过这里必须把问题与答案
        // 分别作为单独部分解析出来。这里使用了字符串 String 
        // 的 split() 方法来把文本行拆分成两个分词（tokens, 
        // 以恶用作问题，一个用作答案）。后面就会介绍到这个 split()
        // 方法。
        String [] result = lineToParse.split(&quot;/&quot;);
        QuizCard card = new QuizCard(result[0], result[1]);
        cardList.add(card);
        System.out.println(&quot;构造好了一个卡片&quot;);
    }

    private void showNextCard () {
        currentCard = cardList.get(currentCardIndex);
        currentCardIndex++;
        display.setText(currentCard.getQuestion());
        nextBtn.setText(&quot;揭开答案&quot;);
        isShowAnswer = true;
    }
}
</code></pre>
<h3 id="使用-string-的-split-方法来解析"><a class="header" href="#使用-string-的-split-方法来解析">使用 <code>String</code> 的 <code>split()</code> 方法来解析</a></h3>
<p><strong>Parsing wih <code>String</code> <code>split()</code></strong></p>
<p><img src="images/Ch14_24.png" alt="以文本文件方式保存对象数据" /></p>
<p><em>图 24 - 以文本文件方式保存对象数据</em></p>
<p><strong>怎样区分出问题和答案</strong>？</p>
<p><strong>How do you separate he question and answer</strong>?</p>
<p>在读取这个文件时，问题与答案是挤在一行里头的，以一个正斜杠（<code>/</code>）分隔开（由于这正是在 <code>QuizCodeBuilder</code> 代码中写到文件的方式）。</p>
<p><strong><code>String</code> 的静态方法 <code>split()</code> 实现了将字符串拆开为多个片段</strong>。</p>
<p><strong><code>String</code> <code>split()</code> lets you break a String into pieces</strong>.</p>
<p>方法 <code>split()</code> 是指，“给我一个分隔符，我就会为你拆分出这个字符串的所有片段，并把他们放到一个字符串数组中。”</p>
<p><img src="images/Ch14_25.png" alt="String类的静态方法 split()" /></p>
<p><em>图 25 - <code>String</code>类的静态方法 <code>split()</code></em></p>
<pre><code class="language-java">// 在 QuizCardPlayer 应用中，这就是从文件中读取到单行
// 文本时看起来的样子
String toTest = &quot;What i blue + yellow?/green&quot;;

// split() 方法取得这个正斜杠 '/' ，并使用这个正斜杠
// 来将这个字符串拆分成两个片段（在此示例中）。（请
// 注意：split() 要远比这里的用法强大。在与
// 过滤器、通配符等工具结合使用时，可以完成极为复杂的解析。）
String[] result = toTest.split(&quot;/&quot;);

// 对这个字符串字符进行遍历，并把各个分词（token，片段）打印
// 出来。在此示例中，就只有两个分词：“What is blue + yellow?”
// 以及 “green”。
for (String token:result) {
    System.out.println(token);
}
</code></pre>
<h2 id="答疑-16"><a class="header" href="#答疑-16">答疑</a></h2>
<ul>
<li><strong>好吧，我看了看你 API 文档，发现在 <code>java.io</code> 包中差不多有 5 百万个类。到底该怎样知道要用哪些类呢</strong>？</li>
</ul>
<blockquote>
<p><code>I/O</code> API 用到了模块化的 ‘链接’ 概念，因此就可以对这些连接性流与链式流（也叫做“过滤器”流），以相当宽泛的组合方式进行调用，从而获取到想要的几乎全部东西（The <code>I/O</code> API uses the modular 'chaining' concept so that you can hook together connection streams and chain streams(also called 'filter' streams) in a wide range of combinations to get just about anything you could want）。</p>
<p>这些处理链，不必仅止于两层；可在一个链式流上调用多个链式流，来获取到所需的恰当数量流程（The chains don't have to stop at two levels; you can hook multiple chain streams to one another to get just the right amount of processing you need）。</p>
<p>不过多数时候，都仅会用到上面这样的小而好用的类。比如在写入文本文件时，<code>BufferedReader</code>与<code>BufferedWriter</code>（分别链接到 <code>FileReader</code>与 <code>FileWriter</code>）差不多就是所需的全部了。而在写入序列化对象时，就可以使用<code>ObjectOutputStream</code>与<code>ObjectInputStream</code>（分别链接到 <code>FileInputStream</code> 与 <code>FileOutputStream</code>）。</p>
<p>也就是说，今后要使用 Java <code>I/O</code> 来完成的操作，90% 都只会涉及到上面讲的两种情况。</p>
</blockquote>
<ul>
<li><strong>请讲讲Java 1.4 中引入的新 <code>I/O</code> 包 <code>nio</code> 中那些类的情况吧</strong>（<strong>What about the new <code>I/O</code> <code>nio</code> class added in <code>1.4</code></strong>）</li>
</ul>
<blockquote>
<p><code>java.nio</code> 包中的类，带来了大大的性能提升，并更好地利用了程序运行所在机器的原生优势（The <code>java.nio</code> classes bring a big performance improvement and take greater advantage of native capatibilities of the maching your program is running on）。<code>nio</code> 包的关键特性之一，就是让Java程序员可以对缓存进行直接控制。值得一提另一项新特性，则是非阻塞 <code>I/O</code> （non-blocking <code>I/O</code>），指的是所编写的 <code>I/O</code> 代码，在没有要读取或写入的数据时，不会只是在那里发呆等候。<code>nio</code> 中的一些既有类（包括 <code>FileInputStream</code> 与 <code>FileOutputStream</code>），也都受益于一些新特性，等着我们去运用。不过这些 <code>nio</code> 类使用起来要复杂一些，所以除非 <em>真的</em> 需要这些新特性，那么就一直使用这里用到的简单版本就好。另外，在不小心的情况下，<code>nio</code> 还会导致性能上的 <em>损失</em>。对于日常需要完成的 <code>I/O</code> 操作，这里用到的非 <code>nio</code> 的 <code>I/O</code>，大约已经可以满足 90% 了，尤其是刚开始使用 Java 编程语言的时候。</p>
<p>然而可以通过使用 <code>FileInputStream</code> ，并经由其 <code>getChannel()</code> 方法（是在Java 1.4 版本中添加到 <code>FileInputStream</code> 类的），去访问他的 <em>通道（channel）</em> ，以此来让切换到 <code>nio</code> 的那些类更容易。</p>
</blockquote>
<hr />
<blockquote>
<p><em>Roses are first, violets are next</em>.</p>
</blockquote>
<blockquote>
<p><em><em><code>Readers</code></em> and <em><code>Writers</code> are only for <em>text</em></em></em>.</p>
</blockquote>
<h2 id="重点-4"><a class="header" href="#重点-4">重点</a></h2>
<ul>
<li>对于写文本文件，要以 <code>FileWriter</code> 连接性流开头；</li>
<li>为效率着想，要将 <code>FileWriter</code> 链接到 <code>BufferedWriter</code>；</li>
<li><code>File</code>对象表示在特定路径的文件，而不表示文件的具体内容；</li>
<li>有了<code>File</code>对象，就可以对目录进行创建、遍历及删除操作；</li>
<li>可使用字符串的文件名的那些流，大多数也可以使用<code>File</code>对象，同时<code>File</code>对象用起来更加安全；</li>
<li>要读取文本文件，就要以一个 <code>FileReader</code> 连接性流开头；</li>
<li>为效率着想，要将<code>FileReader</code>链接到 <code>BufferedReader</code>；</li>
<li>要解析文本文件，就要确保该文件是以某种识别出不同元素的方式写下来的（To parse a text file, you need to be sure the file is written with some way to recognize the different elements）。而常见的方法，则是使用某种字符来将那些单独片段分隔开来；</li>
<li>使用<code>String</code>类的<code>split()</code>方法，将字符串切分为多个单独分词。带有一个分隔符的字符串将有两个分词，分隔符的两侧各有一个。<em>分隔符本身不被算作是分词</em>。</li>
</ul>
<h2 id="版本id序列化的大问题"><a class="header" href="#版本id序列化的大问题">版本ID：序列化的大问题</a></h2>
<p><strong>Version ID: A Big Serialization Gotcha</strong></p>
<p>现在已经看到，Java中的 <code>I/O</code>实际上是相当简单的了，在一直使用最常见的连接/链式流时尤其如此。然而这里有个 <em>或许</em> 真的应该关注的问题。</p>
<h2 id="版本控制至关重要"><a class="header" href="#版本控制至关重要">版本控制至关重要！</a></h2>
<p><strong>Version Control is crucial</strong>!</p>
<p>在序列化某个对象时，为了随后的解序列化以及使用到这个对象，那么就必须要有对应的类。好吧，这是显然的。然而不那么显然的是，如果期间 <strong>修改了对象</strong>，会怎样呢？呀。设想在尝试恢复某个序列化的 <code>Dog</code> 对象时，有一个实例变量（非瞬态的）从双精度浮点数变成了字符串。这就极大地破坏了 Java 的类型安全这一痛点了（That violates Java's type-safe sensibilities in a Big Way）。然而这还不是唯一的可能会危害兼容性的做法。请思考下面这些：</p>
<p><img src="images/Ch14_26.png" alt="可序列化对象的版本控制" /></p>
<p><em>图 26 - 可序列化对象的版本控制</em></p>
<h3 id="会危及解序列化操作的类修改"><a class="header" href="#会危及解序列化操作的类修改">会危及解序列化操作的类修改：</a></h3>
<ul>
<li>删除某个实例变量；</li>
<li>修改实例变量的声明类型；</li>
<li>将非瞬态实例变量，修改为瞬态；</li>
<li>改变某个类在继承树上的位置（Moving a class up or down in the inheritance hierarchy）；</li>
<li>将某个类（只要是在对象图面上的）从可序列化修改为不可序列化（通过从类声明移除 <code>implements Serializable</code>）；</li>
<li>把某个实例变量修改为静态变量。</li>
</ul>
<h3 id="通过不会造成问题的对类的修改"><a class="header" href="#通过不会造成问题的对类的修改">通过不会造成问题的对类的修改：</a></h3>
<ul>
<li>往类加入新的实例变量（原有的那些对象，将以默认值来解序列化那些他们被序列化时所没有的那些实例变量）；</li>
<li>往继承树加入一些类；</li>
<li>从继承树移除一些类；</li>
<li>修改实例变量呃访问级别，对解序列化操作对该变量的赋值没有影响（Changing the access level of an instance variable has no effect on the ability of deserialization to assign a value to the variable）；</li>
<li>将某个瞬态实例变量，修改为非瞬态（先前被序列化的那些对象，将直接给先前瞬态的那些实例变量一个默认值）。</li>
</ul>
<h2 id="使用-serialversionuid"><a class="header" href="#使用-serialversionuid">使用 <code>serialVersionUID</code></a></h2>
<p>在每次对象被序列化时，对象（包括其对象图面中的所有对象），就会被“印上（stamped）”一个其所属类的版本ID编号（a version ID number for the object's class）。这个ID就叫做 <code>serialVersionUID</code>，是依据类的结构信息计算得到的。在对象被解序列化时，若在对象被序列化后类被修改了，那么类就会有一个与被序列化对象所印上的不同 <code>serialVersionUID</code>，那么解序列化就会失败！然而对此可以自己掌控。</p>
<p><strong>在认为类会有可能在今后 <em>演化</em>的情况下，就要在类中放入一个序列版本ID（If you think there is ANY possibility that your class might <em>evolve</em>, put a serial version ID in your class）</strong></p>
<p>在Java尝试对某个对象解序列化时，他会对这个被序列化对象的 <code>serialVersionUID</code> 与 JVM 用来对这个对象进行解序列化的类<code>serialVersionUID</code>加以比较。比如，在某个 <code>Dog</code> 实例被以 <code>ID</code> <code>23</code>（现实中 <code>serialVersionUID</code> 要长得多） 进行序列化时，那么在 JVM 对这个 <code>Dog</code> 对象解序列化时，就会首先拿这个 <code>Dog</code> 对象的 <code>serialVesionID</code> 与 <code>Dog</code> 类的 <code>serialVersionUID</code> 进行比较。在两个数字不匹配时，JVM 就会假定用于解序列化呃类，与先前被序列化的对象不兼容，同时在解序列化过程中会抛出一个异常。</p>
<p>那么解决办法就是在类中放入一个 <code>serialVersionUID</code>，然会随着类的演化，<code>serialVersionUID</code>将保持一致，这个时候就算类发生了改变， JVM 也会认为，“好吧，很好，这个类与这个被序列化对象是兼容的。”</p>
<p>这样处理也 <em>只会</em> 在对类修改小心谨慎时才凑效！也就是说，若在将旧有的对象以新的类复活时，有任何问题出现，都要由 <em>代码编写者</em> 来负责（In other words, <em>you</em> are taking responsibility for any issues that come up when an older object is brought back to life with a newer class）。</p>
<p>使用与 Java 开发包（Java development kit, jdk）一起发布的 <code>serialver</code> 工具，来获取类的 <code>serialVersionUID</code>:</p>
<pre><code class="language-console">$ serialver -classpath build/libs/com.xfoss.learningJava-0.0.1.jar com.xfoss.learningJava.Dog
com.xfoss.learningJava.Dog:    private static final long serialVersionUID = 1720600418317157466L;
</code></pre>
<p><img src="images/Ch14_27.png" alt="serialver 命令工具的使用和输出" /></p>
<p><em>图 27 - <code>serialver</code> 命令工具的使用和输出</em></p>
<blockquote>
<p>注：若类声明中没有 <code>implements Serializable</code>，那么 <code>serialver</code> 命令工具将给出如下输出：</p>
</blockquote>
<pre><code class="language-console">$ serialver -classpath build/libs/com.xfoss.learningJava-0.0.1.jar com.xfoss.learningJava.Dog
Class com.xfoss.learningJava.Dog is not Serializable.
</code></pre>
<p><img src="images/Ch14_28.png" alt="不可序列化对象的 serialver 输出" /></p>
<p><em>图 28 - 不可序列化对象的 <code>serialver</code> 输出</em></p>
<h3 id="在有人已经序列化了某个类的对象后而意识到这个类会进行演化时"><a class="header" href="#在有人已经序列化了某个类的对象后而意识到这个类会进行演化时">在有人已经序列化了某个类的对象后，而意识到这个类会进行演化时......</a></h3>
<p><strong>When you think your class might evolve after someone has serialized objects from it</strong>...</p>
<ol>
<li>
<p>使用命令行工具 <code>serialver</code> 获取这个类的版本 ID（<code>serialVersionUID</code>）</p>
<p><img src="images/Ch14_29.png" alt="使用命令行工具serialver，获取类的 serialVersionUID" /></p>
<p><em>图 29 - 使用命令行工具<code>serialver</code>，获取类的 <code>serialVersionUID</code></em></p>
</li>
<li>
<p>将上面的输出，粘贴到类中</p>
<pre><code class="language-java">public class Dog {
    private static final long serialVersionUID = 1720600418317157466L;

    private String name;
    private int size;

    // 以下是方法的代码
}
</code></pre>
</li>
<li>
<p>确保在对这个类做出修改时，自己要对这个类做出修改所带来的后果负责！比如就要确保新的 <code>Dog</code> 类能够以默认值，来处理在 <code>Dog</code> 被序列化后，所添加的那些实例变量的解序列化（For example, be sure that your new <code>Dog</code> class can deal with an old <code>Dog</code> be deserialized with default values for instance variables added to the class after the <code>Dog</code> was serialized）。</p>
</li>
</ol>
<h2 id="代码厨房-3"><a class="header" href="#代码厨房-3">代码厨房</a></h2>
<p><img src="images/Ch14_30.png" alt="第14章代码厨房：BeatBox app 曲目数据的保存与恢复" /></p>
<p><em>图 30 - 第14章代码厨房：<code>BeatBox</code> app 曲目数据的保存与恢复</em></p>
<p><strong>这里要让 <code>BeatBox</code> 把那些喜欢的曲目，加以保存并恢复</strong>。</p>
<h3 id="保存-beatbox-编曲"><a class="header" href="#保存-beatbox-编曲">保存 <code>BeatBox</code> 编曲</a></h3>
<p><strong>Saving a <code>BeatBox</code> pattern</strong></p>
<p>请记住，在 <code>BeatBox</code> 中，鼓编排无非就是一堆勾选框。在要演奏序列时，代码就会遍历这些勾选框，找出哪些鼓乐器的声音在总的16个节拍中的每个节拍会演奏（When it's time to play the sequence, the code walks through the checkboxes to figure out which drums sounds are playing at each of the 16 beats）。那么要保存编曲，只需把这些勾选框的状态保存下来即可。</p>
<p>这里可以构造一个简单的布尔值数组，来保存总共256个勾选框中各个勾选框的状态。由于数组 <em>中的</em> 那些东西可被序列化，因此数组亦是可序列化的，因此在保存布尔值的数组时没有问题。</p>
<p>而要将编曲加载回来，就要读取这个单个的布尔值数组对象（对其进行解序列化），并对这些勾选框加以恢复。在之前构建 <code>BeatBox</code> GUI的代码厨房中，已经见到了绝大部分的代码，那么在这一章中，就只会看到保存与恢复的代码了。</p>
<p>本次的代码厨房，将为下一章做好准备，在下一章中不再是把编曲写入 <em>文件（file）</em>，而是要将编曲透过 <em>网络（network）</em> 发送到服务器。同时与从文件加载 <em>进</em> 编曲不同，下一章会从 <em>服务器</em> 获取到编曲，用户一次会发送一个编曲到服务器。</p>
<p><strong>对编曲进行序列化（Serializing a pattern）</strong></p>
<pre><code class="language-java">// 这是一个`BeatBox`代码里面的内部类。
class SendPatternListener implements ActionListener {
    // 编曲保存操作，全部发生在用户点击了那个按钮，而发出了
    // 这个 ActionEvent 的时候。
    public void actionPerformed(ActionEvent ev) {
        // 构造一个保存各个勾选框状态的布尔值数组。
        boolean[] checkboxesState = new boolean[256];

        // 对 checkBoxList（即那些勾选框的 ArrayList）进行遍历
        // 并获得各个勾选框的状态，再将状态添加到这个布尔值
        // 的数组中。
        for (int i = 0; i &lt; 256; i++){
            JCheckBox check = (JCheckBox) checkBoxList.get(i);

            if (check.isSelected()) checkboxesState[i] = true;
        }

        try {
            // 这里就是小菜一碟了。只是将这个布尔值数组进行写入/序列化！
            String serFile = String.format(&quot;%s/pattern.ser&quot;, XPlatformThings.getWorkingDir(&quot;BeatBox&quot;));
            FileOutputStream fileStream = new FileOutputStream(new File(serFile));
            ObjectOutputStream os = new ObjectOutputStream(fileStream);
            os.writeObject(checkboxesState);
            os.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="beatbox编曲的恢复"><a class="header" href="#beatbox编曲的恢复"><code>BeatBox</code>编曲的恢复</a></h3>
<p><strong>Restoring a <code>BeatBox</code> pattern</strong></p>
<p>这就刚好与保存操作是反过来的了......读取那个序列化的布尔值数组对象，然后利用这个复活过来的数组对象，恢复GUI的那些勾选框状态。曲目恢复操作，全部发生自用户点击了“恢复”按钮的一瞬间。</p>
<p><strong>编曲的恢复（Restoring a pattern）</strong></p>
<pre><code class="language-java">// 这是另一个 BeatBox 代码里头的内部类。
class ReadInPatternListener implements ActionListener {
    public void actionPerformed(ActionEvent ev) {
        boolean[] checkboxesState = null;

        try {
            FileInputStream fileIn = new FileInputStream(new File(String.format(&quot;%s/pattern.ser&quot;, 
                            XPlatformThings.getWorkingDir(&quot;BeatBox&quot;))));
            ObjectInputStream is = new ObjectInputStream(fileIn);
            // 读取文件中那单独对象（即那个布尔值数组），并将其强制转换回到
            // 布尔值数组（请记住，readObject() 方法返回的是一个类型为 Object
            // 的引用变量。）
            checkboxesState = (boolean[]) is.readObject();
            is.close();
        } catch (Exception ex) {ex.printStackTrace();}

        // 现在对那些真正 JCheckBox 对象的 ArrayList 中各个勾选框状态
        // 进行恢复。
        for (int i = 0; i &lt; 256; i++) {
            JCheckBox check = (JCheckBox) checkboxList.get(i);
            if(checkboxesState[i]) check.setSelected(true);
            else check.setSelected(false);
        }

        // 此时要停止当前所演奏的任何曲目，并使用这个 JCheckBox ArrayList
        // 中的那些勾选框状态，重建出 MIDI 序列。
        s.stop();
        buildTrackAndStart();
    }
}
</code></pre>
<h3 id="动手练习"><a class="header" href="#动手练习">动手练习</a></h3>
<p><strong>Sharpen your pencil</strong></p>
<p>此版本有着巨大局限！在点击了 &quot;对其序列化&quot; 按钮时，程序将自动进行序列化操作，到一个名为“pattern.ser”的文件（若该文件不存在，就会被创建出来）。不过在每次保存时，都将覆写先前保存的文件。</p>
<p>请通过结合 <code>JFileChooser</code>，对这里的保存与恢复特性加以改进，从而可以随意命名，并保存出许多不同的曲目，同时还能够从先前所保存的文件，加载/恢复出 <em>任意</em> 的曲目。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="联网与线程构造连接"><a class="header" href="#联网与线程构造连接">联网与线程：构造连接</a></h1>
<p><strong>Networking and threads: Make a Connection</strong></p>
<p><strong>要与外部世界连通</strong>。Java程序是能够触及另一台机器上程序的。而且不难触及。<code>java.net</code>库中的众多类，负责全部低级别网络通信细节。采用 Java 的众多益处之一，就是透过网络来发送和接收数据，就跟普通 <code>I/O</code> 操作一样，些许不同之处在于，位于 <code>I/O</code> 操作链末端有着不同的连接性流。在获得了一个 <code>BufferedReader</code>后，就可以 <em>读取</em> 数据了。而 <code>BufferedReader</code>是不会在乎数据是从文件还是从以太网线上来的。本章将使用套接字来连接到外界（And the <code>BufferedReader</code> couldn't care less if the data came out of a file or flew down an ethernet cable. In this chapter we'll connect to the outside world with sockets）。这里会构造 <em>客户端</em> 套接字。也会构造 <em>服务器</em> 套接字。这里会构造 <em>客户端</em> 与 <em>服务器</em>。同时还会让二者互相对话。在本章完成之前，就会有一个功能完整、多线程的聊天客户端。对了，这里提到了 <em>多线程</em>，那么就 <em>即将</em> 学到怎样在与 Bob 对话的同时，还要听 Suzy 讲话的诀窍。</p>
<h2 id="实时-beatbox-聊天室应用"><a class="header" href="#实时-beatbox-聊天室应用">实时 <code>BeatBox</code> 聊天室应用</a></h2>
<p><strong>Real-time <code>BeatBox</code> Chat</strong></p>
<p><img src="images/Ch15_01.png" alt="具备网络通信与线程特性之后的 BeatBox 应用" /></p>
<p><em>图 1 - 具备网络通信与线程特性之后的 <code>BeatBox</code> 应用</em></p>
<p>现在是在计算机游戏上工作了。玩家和队友一起，为游戏的各个部分制作声音素材。运用一个 <em>聊天室</em> 版的 <code>BeatBox</code> 应用，团队就可以协同工作 -- 可把一个节拍编排与一条消息一起发出，然后<code>BeatBox</code>聊天室中的所有人就会收到这条消息以及与消息一起发出的节拍编排。因此就不光要 <em>读取</em> 其他参与者的消息，还要可通过直接点击接收消息区中的某条消息，来加载并 <em>演奏出</em> 一个节拍编排。</p>
<p>在本章将了解到，要构造一个这样的聊天客户端需要些什么。甚至还会了解到一点有关构造聊天 <em>服务器</em> 的知识。为后面代码厨房的目的，这里将保留完整的 <code>BeatBox</code> 聊天室，不过在本章中 <em>将</em> 编写一个 <code>LudicrouslySimpleChatClient</code> 应用，以及一个用于发送和接收文本消息的非常简单的聊天服务器。</p>
<p><img src="images/Ch15_02.png" alt="SimpleChatClient 应用" /></p>
<p><em>图 2 - <code>SimpleChatClient</code> 应用</em></p>
<h2 id="聊天程序概览"><a class="header" href="#聊天程序概览">聊天程序概览</a></h2>
<p><strong>Chat Program Overview</strong></p>
<p><img src="images/Ch15_03.png" alt="SimpleChat应用概览" /></p>
<p><em>图 3 - <code>SimpleChat</code>应用概览</em></p>
<h3 id="工作原理"><a class="header" href="#工作原理">工作原理</a></h3>
<p><strong>How it Works</strong>:</p>
<ol>
<li>
<p><strong>客户端连接到服务器</strong></p>
<p><strong>Client connects to the server</strong></p>
<p><img src="images/Ch15_04.png" alt="SimpleChat应用原理（一）" /></p>
<p><em>图 4 - <code>SimpleChat</code>应用原理（一）- 客户端连接到服务器</em></p>
</li>
<li>
<p><strong>服务器构造一个连接，并将该客户端加入到参与者清单</strong></p>
<p><strong>The server makes a connection and adds the client to the list of participants</strong></p>
<p><img src="images/Ch15_05.png" alt="SimpleChat应用原理（二）" /></p>
<p><em>图 5 - <code>SimpleChat</code>应用原理（二） - 服务器构造一个连接，并将该客户端加入到参与者清单</em></p>
</li>
<li>
<p><strong>另一客户端进行连接</strong></p>
<p><strong>Another client connects</strong></p>
<p><img src="images/Ch15_06.png" alt="SimpleChat应用原理（三）" /></p>
<p><em>图 6 - <code>SimpleChat</code>应用原理（三） - 另一客户端进行连接</em></p>
</li>
<li>
<p><strong>客户端 A 发送一条消息给聊天服务</strong></p>
<p><img src="images/Ch15_07.png" alt="SimpleChat应用原理（四） - 客户端 A 发送一条消息给聊天服务" /></p>
<p><em>图 7 - <code>SimpleChat</code>应用原理（四） - 客户端 A 发送一条消息给聊天服务</em></p>
</li>
<li>
<p><strong>服务器将该条消息，发布给所有参与者（包括原本的发送者）</strong></p>
<p><img src="images/Ch15_08.png" alt="SimpleChat应用原理（五） - 该条消息被发布到全体参与者" /></p>
<p><em>图 8 - <code>SimpleChat</code>应用原理（五） - 该条消息被发布到全体参与者</em></p>
<h2 id="建立连接发送数据与数据接收"><a class="header" href="#建立连接发送数据与数据接收">建立连接、发送数据，与数据接收</a></h2>
<p><strong>Connecting, Sending, and Receiving</strong></p>
</li>
</ol>
<p>为了让 <code>SimpleChat</code> 客户端运作，必须掌握以下三件事：</p>
<ol>
<li>如何建立客户端与服务器之间最开始的 <strong>连接</strong>（How to establish the initial <strong>connection</strong> between the client and server）；</li>
<li>如何把消息 <strong>发送给</strong> 服务器（How to <strong>send</strong> messages <em>to</em> the server）；</li>
<li>如何从服务器 <strong>接收</strong> 消息（How to <strong>receive</strong> messages <em>from</em> the server）。</li>
</ol>
<p>这些事项要能运行起来，就必须要有大量底层的操作要实现（There's a lot of low-level stuff that has to happen for these things to work）。不过值得庆幸的是，Java 的网络通信包 API （<code>java.net</code>）让这一切，都变成了小菜一碟。因此相比于网络通信与 <code>I/O</code> 代码，看到的更多的是 GUI 代码。</p>
<p>而且这还不是全部。</p>
<p><code>SimpleChat</code>客户端中潜在的另一个到目前为止尚未遇到的问题，就是在同一时间进行两件事情。连接的建立是一次性的操作（要么成功要么失败）。然而在那之后，聊天室参与者就要 <em>发送传出消息</em>，并 <strong>同时</strong> <em>接收</em> 来自其他参与者的 <em>传入消息</em>。嗯...这就要花点心思，不过很快就会接触到这个问题。</p>
<ol>
<li>
<p><strong>连接（Connect）</strong></p>
<p>经由建立起一个 <strong>套接字（Socket）</strong> 连接，客户端连接到服务器。</p>
<p><img src="images/Ch15_09.png" alt="SimpleChat客户端连接到服务器" /></p>
<p><em>图 9 - <code>SimpleChat</code>客户端连接到服务器</em></p>
</li>
<li>
<p><strong>发送（Send）</strong></p>
<p>客户端将消息 <strong>发送</strong> 给服务器。</p>
<p><img src="images/Ch15_10.png" alt="SimpleChat客户端将消息发送给服务器" /></p>
<p><em>图 10 - <code>SimpleChat</code>客户端将消息发送给服务器</em></p>
</li>
<li>
<p><strong>接收（Receive）</strong></p>
<p>客户端从服务器 <strong>获取到</strong> 消息。</p>
<p><img src="images/Ch15_11.png" alt="SimpleChat客户端从服务器获取到消息" /></p>
<p><em>图 11 - <code>SimpleChat</code>客户端从服务器获取到消息</em></p>
</li>
</ol>
<h2 id="构造网络套接字连接"><a class="header" href="#构造网络套接字连接">构造网络套接字连接</a></h2>
<p><strong>Make a network Socket connection</strong></p>
<p>要连接到另一台机器，就需要一个套接字连接。套接字（<code>java.net.Socket</code>）是一个表示两台机器之间网络连接的对象（A Socket(<code>java.net.Socket</code>) is an object that represents a network connection between two machines）。何为连接？即两台机器之间的一种 <em>关系（relationship）</em>，其中 <em>两个软件相互有了解（two pieces of software know about each other）</em>。更为重要的是，这两个软件知道怎样互相 <em>通信（communication）</em>。换句话说，他们知道如何将一系列的 <em>二进制位</em> 发送给对方。</p>
<p>好在这里不会关注那些底层细节，这是由于这些低级别细节，是在 “网络通信栈” 中的更底层处处理的（We don't care about the low-level details, thankfully, because they're handled at a much lower place in the 'networking stack'）。若对于“网络通信栈”一无所知，那么也无需担心他。那只是一种关于信息（一系列二进制位）从运行在某种OS上的JVM中的Java程序，到物理实体硬件（比如以太网线），到另一机器后又从物理硬件到Java程序中，所必须经历的多个层的说法。必须 <em>有人</em> 来处理这些全部繁重工作（If you don't know what the 'networking stack' is, don't worry about it. It's just a way of looking at the layers that information (bits) must travel throught to get from a Java program running in a JVM on some OS, to physical hardware(ethernet cables, for example), and back again on some other machine. <em>Somebody</em> has to take care of all the dirty details）。不过那不是咱们Java程序员要做的。处理这些底层网络通信的，正是那些特定于OS的软件，以及Java的网络通信API。真正要担心的，是那些高级别的东西 -- 构造出那个 <em>甚为</em> 高级别的对象 -- 从而就变得惊人的简单了。准备好了吗？</p>
<blockquote>
<p>要构造一个 <code>Socket</code> 连接，就需要知道有关服务器的 <strong>两件事</strong>：服务器是谁，以及运行在哪个端口上。</p>
<p>换句话说，</p>
<p>即 <strong>IP 地址和 TCP 端口编号</strong>。</p>
</blockquote>
<pre><code class="language-java">// '196.164.1.103' 是服务器的 IP 地址
//
// '5000' 是 TCP 端口号
Socket chatSocket = new Socket(&quot;196.164.1.103&quot;, 5000);
</code></pre>
<p><img src="images/Ch15_12.png" alt="Java网络通信套接字的构造原理" /></p>
<p><em>图 12 - Java网络通信套接字的构造原理</em></p>
<p><strong><code>Socket</code> 连接是指两台机器有着对方的信息，包括网络位置（即 IP 地址）以及 TCP 端口（A <code>Socket</code> connection means the two machines have information about each other, including network location(IP address) and TCP port）</strong>。</p>
<p><strong>所谓 TCP 端口，无非是一个编号，一个 16 位的、区分服务器上特定程序的数字（A TCP port is just a number. A 16-bit number that identifies a specific program on the server）。</strong></p>
<p>互联网 Web（HTTP） 服务器运行在端口 <code>80</code>。那就是一项标准。在获取到一台远程登录（Telnet）服务器时，那么就是运行在端口 <code>23</code>上。至于 FTP？则为 <code>20</code>。POP3 邮件服务器？是 <code>110</code>。SMTP？为<code>25</code>。时间服务器位于 <code>37</code>。只需把端口编号当作唯一识别符就可以了。这些端口编号，表示的都是到运行在服务器上特定软件的逻辑连接（Think of port numbers as unique identifiers. They represents a logical connection to a particular piece of software running on the server）。就是这样子。对于这些端口编号，在物理机器外壳上无论如何也是找不到的。但要记住一点，服务器上有总共 <code>65536</code>个端口编号（<code>0 ~ 65535</code>）。那么显然这些端口编号不是表示物理设备上可以插入接头的地方。这些编号都只是表示某个应用的一个数字而已。</p>
<p>但若没有这些端口编号，那么服务器就没有办法知道客户端要连接到哪个应用了。而由于各个应用可能有着他自己独特的协议，那么可以设想一下若没有这些标识符，会有多大麻烦。比如在 Web 浏览器落在了 POP3 的邮件服务器，而不是 HTTP服务器上时，会发生什么呢？此时邮件服务器就不知道怎么去解析 HTTP 请求了！同时就算邮件服务器知道怎样区解析 HTTP请求，POP3 服务器也对如何去对HTTP请求进行服务一无所知。</p>
<p><img src="images/Ch15_13.png" alt="关于网络通信中的端口编号" /></p>
<p><em>图 13 - 关于网络通信中的端口编号</em></p>
<p><strong>从 <code>0</code> 到 <code>1023</code> 的 TCP 端口编号，被保留给那些知名服务。在自己的服务器程序中请勿使用他们<sup>*</sup>！</strong></p>
<p><strong>这里所编写的聊天室服务器使用了端口 <code>5000</code>。所选用的就是 <code>1024</code> 与 <code>65535</code> 之间的一个数字</strong>。</p>
<blockquote>
<p><sup>*</sup> 当然也 <em>可以</em> 使用 <code>0</code> ~ <code>1023</code> 中的某个端口编号，不过你工作地方的系统管理员可能会杀了你。</p>
</blockquote>
<h2 id="答疑-17"><a class="header" href="#答疑-17">答疑</a></h2>
<ul>
<li><strong>该怎么知道要与其会话的服务器程序的端口编号呢（How do you know the port number of the server program you want to talk to）</strong>？</li>
</ul>
<blockquote>
<p>这取决于那个服务器程序是否是那些知名服务（well-known services）之一。在要连接某个知名服务，比如上面提到的那些（HTTP、SMTP、FTP等待）时，那么在互联网上就能找到他们的端口编号（Google 一下 “Well-Known TCP Port”）。或者问一下你隔壁的系统管理员同事。</p>
<p>但在服务器程序并非这些知名服务时，那么就需要问一下部署该项服务的那个人了。通常某人编写了一项网络服务，且他/她又希望有人来为这个网络服务编写客户端时，那么他就会把此项服务的 IP 地址、端口号以及协议公布出来。比如在给一个名为 <code>GO</code> 的游戏服务器编写客户端时，就可以访问某个 <code>GO</code> 服务器站点，从而找到有关如何为那个特定<code>GO</code>游戏服务器编写客户端的信息。</p>
</blockquote>
<ul>
<li><strong>在单个端口上可以运行多个的程序吗？也就是说，同一台服务器上的两个应用，可以有着同样的端口号吗</strong>？</li>
</ul>
<blockquote>
<p>不行！在尝试将某个程序绑定到一个已在使用中的端口时，就会收到一个 <code>BindException</code> 异常。而将某个程序 <em>绑定</em> 到某个端口，就意味着启动某个服务器应用，并告诉这个应用在特定端口上运行。老调重弹，在本章后面的服务器部分，会了解到更多有关此方面的内容。</p>
</blockquote>
<p><img src="images/Ch15_14.png" alt="理解IP地址与端口号" /></p>
<p><em>图 14 - 理解IP地址与端口号</em></p>
<h3 id="脑力锻炼-3"><a class="header" href="#脑力锻炼-3">脑力锻炼</a></h3>
<p>好，现在有了一个 <code>Socket</code> 连接。客户端与服务器都知道了对方的 IP 地址和 TCP 端口编号。那么现在又该怎么办呢？该怎样透过那个连接进行通讯呢？也就是说，怎样将一系列的二进制位，从一个地方移动到另一个地方呢？请设想一下有哪些类型的消息，要有这个客户端来发送与接收。</p>
<p><img src="images/Ch15_15.png" alt="思考题：聊天室客户端与服务器之间如何进行会话" /></p>
<p><em>图 15 - 思考题：聊天室客户端与服务器之间如何进行会话</em></p>
<h2 id="使用-bufferedreader-从套接字读取数据"><a class="header" href="#使用-bufferedreader-从套接字读取数据">使用 <code>BufferedReader</code> 从套接字读取数据</a></h2>
<p><strong>To read data from a <code>Socket</code>, use a <code>BufferedReader</code></strong></p>
<p>要透过<code>Socket</code>连接来进行通信，就要用到流。常规的那些老式 <code>I/O</code> 流，就如同上一章中用到的那些。Java中最酷特性之一，就是大部分的 <code>I/O</code> 工作，都不会关心高级别链式流具体连接到的何种连接性流（One of the coolest features in Java is that most of your <code>I/O</code> work won't care what your high-level chain stream is actually connected to）。也就是说，可就像之前写入文件时那样使用 <code>BufferedReader</code>，不同之处在于这里所采用的连接性流，是连接到一个 <em>套接字（<code>Socket</code>）</em>，而不再是之前的 <em>文件（<code>File</code>）</em>！</p>
<p><img src="images/Ch15_16.png" alt="Java网络通信中的输入与输出流，都是套接字连接" /></p>
<p><em>图 16 - Java网络通信中的输入与输出流，都是套接字连接</em></p>
<ol>
<li>
<p><strong>构造一个到服务器的 <code>Socket</code> 连接</strong></p>
<p><strong>Make a <code>Socket</code> connection to the server</strong></p>
<pre><code class="language-java">// '127.0.0.1' 是 “localhost”，也就是此代码
// 运行所在的机器的 IP 地址。在单台、独立机器上对客户端
// 和服务器进行测试时，可使用这个 IP 地址。
//
// 而这个端口号，之前就讲过，5000是这里聊天服务器
// 的端口号。
Socket chatSocket = new Socket(&quot;127.0.0.1&quot;, 5000);
</code></pre>
</li>
<li>
<p><strong>构造一个链接到这个套接字底层（连接性）输入流的 <code>InputStreamReader</code></strong></p>
<p><strong>Make an <code>InputStreamReader</code> chained to the <code>Socket</code>'s low-level (connection) input stream</strong></p>
<pre><code class="language-java">// InputStreamReader 是底层字节流（就比如这里的从套接字获取
// 到的那个），与高级别字符流（如同后面那个作为链式流顶部的
// `BufferedReader`）之间的“桥梁”
// 
// 这里只须从该套接字请求一个输入流即可！所获取到的，就是
// 一个低级别的连接性流，不过这里只要将其链接到某个对文本
// 更加友好的东西上（All we have to do is ASK the socket for
// an input stream! It's a low-level connection stream, but we're
// just gonna chain it to something more text-friendly）。
InputStreamReader stream = new InputStreamReader(chatSocket.getInputStream());
</code></pre>
</li>
<li>
<p><strong>构造一个 <code>BufferedReader</code>然后读取就是了</strong>！</p>
<p><strong>Make a <code>BufferedReader</code> and read</strong>!</p>
<pre><code class="language-java">// 把这个 BufferedReader 链接到 InputStreamReader （他又
// 是链接到那个从套接字获得的底层连接性流的）。
BufferedReader reader = new BufferedReader(stream);
String message = reader.readLine();
</code></pre>
<p><img src="images/Ch15_17.png" alt="从网络通信套接字读取数据的流链条" /></p>
<p><em>图 17 - 从网络通信套接字读取数据的流链条</em></p>
</li>
</ol>
<h2 id="使用-printwriter往套接字写数据"><a class="header" href="#使用-printwriter往套接字写数据">使用 <code>PrintWriter</code>往套接字写数据</a></h2>
<p><strong>To write data to a <code>Socket</code>, use a <code>PrintWriter</code></strong></p>
<p>在最后一章用到的并不是<code>PrintWriter</code>，那里用了 <code>BufferedWriter</code>。虽然这里有选择，不过在一次写一个字符串时，<code>PrintWriter</code>就是标准选择。同时也会认识到，<code>PrintWriter</code>中的两个关键方法，<code>print()</code>与<code>println()</code>，就如同先前 <code>System.out</code>中的两个一样。</p>
<ol>
<li>
<p><strong>构造一个到服务器的 <code>Socket</code> 连接</strong></p>
<p><strong>Make a <code>Socket</code> connection to the server</strong></p>
<pre><code class="language-java">// 此部分与先前从套接字读取数据时一样 -- 要写到
// 服务器，仍必须连接到服务器。
Socket chatSocket = new Socket(&quot;127.0.0.1&quot;, 5000);
</code></pre>
</li>
<li>
<p><strong>构造一个链接到套接字底层（连接性）输出流的 <code>PrintWriter</code></strong></p>
<p><strong>Make a <code>PrintWriter</code> chained to the <code>Socket</code>'s low-level(connection) output stream</strong></p>
<pre><code class="language-java">// InputStreamReader 扮演了字符数据与从套接字低级别输出流获取到
// 的字节之间的桥梁。通过将 PrintWriter 链接到套接字的输出流，就可以
// 将字符串写到套接字连接了（PrintWriter acts as its own bridge
// between character data and the bytes it gets from the Socket's
// low-level output stream. By chaining a PrintWriter to the Socket's
// output stream, we can write Strings to the Socket connection）。
//
// 这个套接字给到一个低级别连接性流，同时这里通过将这个连接性流
// 交给 PrintWriter 的构造器，而把这个连接性流链接到
// 新构造的 PrintWriter。
PrintWriter writer = new PrintWriter(chatSocket.getOutputStream());
</code></pre>
</li>
<li>
<p><strong>写（<code>print</code>）下一些内容</strong></p>
<p><strong>Write(<code>print</code>) something</strong></p>
<pre><code class="language-java">// println() 会在他发送的东西末尾加一个另起一行（'/n'）
writer.println(&quot;要发送的消息&quot;);
// print() 不会添加那个另起一行（'/n'）
writer.print(&quot;另一条消息&quot;);
</code></pre>
<p><img src="images/Ch15_18.png" alt="往套接字写入数据的流链条" /></p>
<p><em>图 18 - 往套接字写入数据的流链条</em></p>
</li>
</ol>
<h2 id="dailyadviceclient-程序"><a class="header" href="#dailyadviceclient-程序"><code>DailyAdviceClient</code> 程序</a></h2>
<p><strong>The <code>DailyAdviceClient</code></strong></p>
<p>在开始构建 <code>SimpleChat</code> app前，先来做一个较小的东西。<code>AdviceGuy</code>是一个提供实用、励志的一些提示的服务器程序，从而让我们度过漫长编写代码的日子。</p>
<p>这里要构建的是一个 <code>AdviceGuy</code>程序的客户端，他在每次连接服务器时，从服务器拉取一条消息。</p>
<p>你还等什么呢，若没有这个 app，没人知道你会失去些什么机会。</p>
<p>1） <strong>连接</strong></p>
<pre><code>**Connect**

客户端连接到服务器，并从他获取到一个输入流（Client connects to the server and gets an input stream from it）。

![`AdviceGuy` app 建立连接](images/Ch15_19.png)

*图 19 - `AdviceGuy` app 建立连接*
</code></pre>
<ol start="2">
<li>
<p><strong>读取</strong></p>
<p><strong>Read</strong></p>
<p>客户端从服务器读取一条消息（Client reads a message from the server）。</p>
<p><img src="images/Ch15_20.png" alt="AdviceGuy app 读取消息" /></p>
<p><em>图 20 - <code>AdviceGuy</code> app 读取消息</em></p>
</li>
</ol>
<h3 id="dailyadviceclient-的代码"><a class="header" href="#dailyadviceclient-的代码"><code>DailyAdviceClient</code> 的代码</a></h3>
<p><strong><code>DailyAdviceClient</code> code</strong></p>
<p>这个程序构造一个 <code>Socket</code>，并构造一个 <code>BufferedReader</code>（有着其他流的辅助），进而从服务器应用（即运行在端口<code>4242</code>的那个）读取单行文本。</p>
<pre><code class="language-java">package com.xfoss.AdviceGuy;

import java.io.*;
// 类 Socket 是在 java.net 包中
import java.net.*;

public class DailyAdviceClient {
    public DailyAdviceClient () {
        // 这里有很多会出错的代码
        try {
            // 构造一个到位于此代码运行所在的同一主机
            // （即 'localhost'）、端口 4242 上程序的套接字连接
            Socket s = new Socket(&quot;127.0.0.1&quot;, 4242);

            // 这里 InputStreamReader 构造函数的第二个参数，指定了字符串
            // 编码，表示 InputStreamReader 的构造函数是过载的。
            // 若不加入这个参数，当服务器和客户端运行在不同平台时
            // 会出现乱码。
            InputStreamReader streamReader = new InputStreamReader(s.getInputStream(), &quot;UTF-8&quot;);
            // 把一个 BufferedReader 链接到一个 InputStreamReader
            // 这个 InputStreamReader 又是链接到来自套接字的输入流
            BufferedReader reader = new BufferedReader(streamReader);

            // 这个 readLine() 与之前用到的、链接到文件的
            // BufferedReader 时的那个一模一样。也就是说在
            // 调用 BufferedReader 的某个方法时，读取器（the reader）
            // 是不知道或不关心字符是从何处而来的。
            String advice = reader.readLine();
            System.out.format(&quot;今日宜：%s\n&quot;, advice);

            reader.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new DailyAdviceClient();
    }
}
</code></pre>
<h3 id="编写一个简单的服务器"><a class="header" href="#编写一个简单的服务器">编写一个简单的服务器</a></h3>
<p><strong>Writing a simple server</strong></p>
<p>那么编写一个服务器应用需要用到哪些东西呢？只需要一对套接字就行。是的，一对就是 <em>两个</em>。一个 <code>ServerSocket</code>，等待客户端的那些请求（在客户端构造新的 <code>Socket()</code> 时），还要一个普通的老式 <code>Socket</code> 套接字，用于与客户端进行通信。</p>
<p><strong>服务器工作原理（How it works）</strong>:</p>
<ol>
<li>
<p>服务器应用在某个特定端口上，构造一个 <code>ServerSocket</code></p>
<pre><code class="language-java">ServerSocket serverSock = new ServerSocket(4242);
</code></pre>
<p>这行语句就启动了服务器应用收听那些目的为端口<code>4242</code>、进入的客户端请求（This starts the server application listening for client requests coming in for port <code>4242</code>）。</p>
<p><img src="images/Ch15_21.png" alt="服务器应用构造一个 ServerSocket" /></p>
<p><em>图 21 - 服务器应用构造一个 <code>ServerSocket</code></em></p>
</li>
<li>
<p>客户端构造一个到服务器应用的 <code>Socket</code> 连接</p>
<p><strong>Client makes a <code>Socket</code> connection to the server application</strong></p>
<pre><code class="language-java">Socket sock = new Socket(&quot;190.165.1.103&quot;, 4242);
</code></pre>
<p>客户端了解 IP 地址以及端口号（是由将改服务器app配置在那个端口上的人公布或给到编写客户端的人）</p>
<p><img src="images/Ch15_22.png" alt="客户端构造一个连接到服务器应用的 Socket" /></p>
<p><em>图 22 - 客户端构造一个连接到服务器应用的 <code>Socket</code></em></p>
</li>
<li>
<p>服务器构造一个新的、与此客户端通信的 <code>Socket</code></p>
<p><strong>Server makes a new <code>Socket</code> to communicate with this client</strong></p>
<pre><code class="language-java">Socket sock = serverSock.accept();
</code></pre>
<p>在等待某个客户端 <code>Socket</code> 连接期间，这个<code>accept()</code>方法会阻塞（即闲在那里）。在有客户端最终尝试进行连接时，该方法就会返回一个知道怎样与客户端进行通信（即知道 <em>客户端</em> 的 IP地址和端口号），的普通老式套接字（在某个 <em>不同</em> 的端口上）。这个 <code>Socket</code>是在不同于 <code>ServerSocket</code> 的端口上的，因此 <code>ServerSocket</code> 才可以回去继续等待其他客户端的连接（The <code>accept()</code> method blocks(just sits there) while it's waiting for a client <code>Socket</code> connection. When a client finally tries to connect, the method returns a plain old <code>Socket</code> (on a <em>different</em> port) that knows how to communicate with the client(i.e., knows the <em>client</em>'s IP address and port number). The <code>Socket</code> is on a different port than the <code>ServerSocket</code>, so that the <code>ServerSocket</code> can go back to waiting for other clients）。</p>
<p><img src="images/Ch15_23.png" alt="服务器程序构造一个新的、与客户端通信的 Socket" /></p>
<p><em>图 23 - 服务器程序构造一个新的、与客户端通信的 <code>Socket</code></em></p>
</li>
</ol>
<h3 id="dailyadviceserver-程序代码"><a class="header" href="#dailyadviceserver-程序代码"><code>DailyAdviceServer</code> 程序代码</a></h3>
<p><strong><code>DailyAdviceServer</code> code</strong></p>
<pre><code class="language-java">package com.xfoss.AdviceGuy;

// 要记得这些导入
import java.io.*;
import java.net.*;

public class DailyAdviceServer {
    // 日常劝解来自这个数组
    // （请记住，这些字符串是由编码编辑器包装起来的单词。绝不要在字符串
    // 中间敲入回车（remember, these Strings were word-wrapped by 
    // the code editor. Never hit return in the middle of a String）！）
    String[] adviceList = {
        &quot;少食多餐&quot;, 
        &quot;买些紧身牛仔裤。他们不会让你看起来显胖。&quot;, 
        &quot;一个字：不合适&quot;,
        &quot;就今天而言，要诚实，告诉你的老板你的真实想法。&quot;,
        &quot;对于这个发型，你应该三思而后行&quot;
        };

    public DailyAdviceServer () {
        try {
            // 这里的 ServerSocket 对象，令到此服务器应用在该
            // 代码运行所在机器的端口 4242 上，“收听” 那些
            // 客户端请求。
            ServerSocket serverSock = new ServerSocket(4242);

            // 服务器进入到一个永久循环，等待（并服务）那些
            // 客户端请求。
            while (true) {
                // 这个 accept() 方法将会阻塞（即处于空闲状态），直到
                // 有请求进来，并在有请求进来时返回一个用于与
                // 客户端通信的 `Socket`（在某个匿名端口）
                //
                // the accept method blocks (just sits there) until
                // a request comes in, and then the method returns 
                // a Socket(on some anonymous port) for communicating
                // with the client
                Socket sock = serverSock.accept();

                // 此时就要是由这个到客户端的套接字连接，来构造一个
                // PrintWriter，并把一个字符串的劝解消息，发送给他（println()）
                // 而由于完成了这个客户端的请求，所以随后就要关闭这个套接字。
                //
                // now we use the Socket connection to the client to make a 
                // PrintWriter and send it (println()) a String advice message
                // Then we close the Socket because we're done with this client.
                //
                // PrintWriter writer = new PrintWriter(sock.getOutputStream());
                // 这里进行了修改，加入了字符串编码，解决服务器与客户端运行于
                // 不同 OS 下时乱码问题。
                PrintWriter writer = new PrintWriter(new OutputStreamWriter(sock.getOutputStream(), &quot;UTF-8&quot;));
                String advice = getAdvice();
                writer.println(advice);
                writer.close();
                System.out.println(advice);
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private String getAdvice() {
        int random = (int) (Math.random() * adviceList.length);
        return adviceList[random];
    }

    public static void main (String[] args) {new DailyAdviceServer();}
}
</code></pre>
<h3 id="脑力锻炼-4"><a class="header" href="#脑力锻炼-4">脑力锻炼</a></h3>
<p><strong>服务器怎样知道他与客户端如何通信</strong>？</p>
<p>客户端知悉服务器的 IP 地址与端口编号，然而服务器又是怎样能构造一个跟客户端的套接字连接（进而构造输入和输出流）呢？</p>
<p>请思考一下服务器怎样/于何时/何处获悉到客户端的知识的（Think about how/when/where the server gets knowledge about the client）。</p>
<h2 id="答疑-18"><a class="header" href="#答疑-18">答疑</a></h2>
<ul>
<li><strong>上面的算命服务器代码，有个非常严重的问题 -- 看起来他只能一次处理一个客户端</strong>！</li>
</ul>
<blockquote>
<p>是的，说的没错。在没有完成当前客户端请求，进而开始那个无限循环（正是在这个无限循环里，服务器的 <code>accept()</code> 调用会处于空闲，等待客户端请求进入，在请求进入时，服务器构造一个跟新客户端的套接字，完成请求处理后就又开始另一个迭代和等待）的下一次迭代之前，这个服务器是无法接受另一客户端请求的（Yes, that's right. It can't accept a request from a client until it has finished with the current client and started the next iteration of the infinite loop(where it sits at the <code>accept()</code> call until a request comes in, at which time it makes a Socket with the new client and starts the process over again)）。</p>
</blockquote>
<ul>
<li><strong>我还是换个说法吧：怎样才能构造一个可以同时并发地处理多个客户端的服务器？？？好比说现在这个服务器，<em>绝对不能</em> 当作一个聊天服务器</strong>。</li>
</ul>
<blockquote>
<p>呃，那并不难，真的。使用一些单独线程，然后把各个新客户端套接字交给这些线程即可。这里正要掌握怎么实现线程和并发特性呢（Ah, that's simple, really. Use separate threads, and give each new client <code>Socket</code> to a new thread. We're just about to learn how to do that）！</p>
</blockquote>
<h2 id="重点-5"><a class="header" href="#重点-5">重点</a></h2>
<ul>
<li>客户端和服务器应用透过套接字连接进行通信（Client and server applications communicate over a <code>Socket</code> connection）；</li>
<li>套接字表示两个应用之间的连接，两个应用可运行在同一台机器，亦可运行在不同机器上；</li>
<li>客户端必须知道服务器应用的IP地址（或域名）与TCP端口好；</li>
<li>TCP端口是个指派给特定服务器应用的16位无符号数。TCP端口号实现不同客户端连接到同一台机器，而与运行在那台机器上的不同应用进行通信；</li>
<li>从 <code>0</code> 到 <code>1023</code> 的端口号，保留用于那些 “知名服务（well-known services）”，包括 HTTP、FTP、SMTP等待；</li>
<li>客户端通过构造服务器套接字，连接到服务器；</li>
</ul>
<pre><code class="language-java">Socket s = new Socket(&quot;127.0.0.1&quot;, 4200);
</code></pre>
<ul>
<li>一旦连接成功，客户端就可以从那个套接字获取到输入与输出流。从套接字获取到的输入输出流，都是底层的 “连接性” 流；</li>
</ul>
<pre><code class="language-java">sock.getInputStream();
sock.getOutputStream();
</code></pre>
<ul>
<li>要从服务器读取文本数据，就要创建 <code>BufferedReader</code>，将其链接到一个 <code>InputStreamReader</code>，而 <code>InputStreamReader</code>又链接到来自套接字的输入流；</li>
<li><code>InputStreamReader</code>是一个取得字节序列，然后转换为文本（字符）数据的 “桥接性” 流。主要用作高级别 <code>BufferedReader</code> 与底层套接字的输入流的中间链（<code>InputStreamReader</code> is a 'bridge' stream that takes in bytes and converts them to text(character) data. It's used primarily to act as the middle chain between the high-level <code>BufferedReader</code> and the low-level <code>Socket</code> input stream）；</li>
<li>要向服务器写数据，就要创建直接链接到套接字输出流的 <code>PrintWriter</code>对象。调用其 <code>print()</code> 或 <code>println()</code> 方法，来将字符串发送给服务器；</li>
<li>服务器会用到在特定端口号上等待客户端请求的 <code>ServerSocket</code>；</li>
<li>在 <code>ServerSocket</code> 收到请求时，<code>ServerSocket</code>就会通过构造跟客户端的套接字连接，而 “受理” 这个请求。</li>
</ul>
<h2 id="编写-chatclient"><a class="header" href="#编写-chatclient">编写 <code>ChatClient</code></a></h2>
<p><strong>Writing a <code>ChatClient</code></strong></p>
<p>这里将通过两阶段，来编写 <code>ChatClient</code>。首先要构造一个把消息发送给服务器，但尚不会读取其他聊天室参与者发出消息的仅发送版本（一个对完整聊天室概念的激动人心又神秘的曲解，First we'll make a send-only version that sends messages to the server but doesn't get to read any of the messages from other paritcipants(an exciting and mysterious twist to the whole chat room concept)）。</p>
<p>随后就会实现完善的聊天方式，而构造一个兼具聊条消息发送 <em>与</em> 接收的 <code>ChatClient</code>。</p>
<h3 id="第一版仅发送"><a class="header" href="#第一版仅发送">第一版：仅发送</a></h3>
<p><strong>Version One: send-only</strong></p>
<p><img src="images/Ch15_24.png" alt="LudicrouslySimpleChatClient聊天室客户端第一版" /></p>
<p><em>图 24 - <code>LudicrouslySimpleChatClient</code>聊天室客户端第一版</em></p>
<p><strong>代码大纲</strong></p>
<pre><code class="language-java">public class SimpleChatClientA extends JFrame {
    JTextField outgoing;
    PrintWriter writer;
    Socket sock;

    public SimleChatClientA () {
        // SimpleChatClientA 类构造函数
        // 构造 GUI 及在发送按钮上注册事件收听者
        // 调用下面的 setUpNetworking() 方法
    }

    private void setUpNetworking () {
        // 构造一个 Socket 对象，随后构造一个 PrintWriter 对象
        // 将 PrintWriter 指派给实例变量 writer
    }

    public class SendButtonListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            // 从文本字段获取文本，并
            // 使用 writer 实例变量（即一个 PrintWriter 对象），把
            // 获取到的文本发送给服务器
        }
    }
}
</code></pre>
<pre><code class="language-java">package com.xfoss.SimpleChat;

// 各种流（java.io）、套接字（java.net）及GUI等得各种导入
import java.io.*;
import java.net.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleChatClientA extends JFrame {

    JTextField outgoing;
    PrintWriter writer;
    Socket sock;

    public SimpleChatClientA () {
        // 这里只是构建 GUI，没有什么新东西，且不涉及到网络通信
        // 或 I/O 操作
        super(&quot;搞笑的简单聊天客户端&quot;);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JPanel mainPanel = new JPanel();

        outgoing = new JTextField(20);

        JButton sendButton = new JButton(&quot;发送&quot;);
        sendButton.addActionListener(new SendButtonListener());

        mainPanel.add(outgoing);
        mainPanel.add(sendButton);

        getContentPane().add(BorderLayout.CENTER, mainPanel);

        setUpNetworking();

        setSize(640, 480);
        setVisible(true);

        addWindowListener(new WindowAdapter(){
            public void windowClosing(WindowEvent winEvt) {
                if(writer != null) writer.close();
                System.exit(0);
            }
        });
    }

    // 此时完成具体写入。请记住，这里的 writer 对象，链接的是来自
    // Socket 对象的输出流，因此不能何时执行 println() 方法，都会
    // 透过网络抵达服务器！
    //
    // Now we actually do the writing. Remember, the writer is chained
    // to the output stream from the Socket, so whenever we do a println()
    // it goes over the network to the server!
    public class SendButtonListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            try {
                writer.println(outgoing.getText());
                writer.flush();
            } catch (Exception ex) {ex.printStackTrace();}

            outgoing.setText(&quot;&quot;);
            outgoing.requestFocus();
        }
    }

    private void setUpNetworking () {
        try {
            // 由于用的是 localhost ，因此可以在一台机器上测试客户端
            // 和服务器。
            // 
            // 这里就是构造 Socket 与 PrintWriter （这个 setUpNetworking() 
            // 方法，是在刚刚显示出该 app 的 GUI 界面后，从类 SimpleChatClientA 
            // 构造器调用）。
            sock = new Socket(&quot;127.0.0.1&quot;, 5000);
            writer = new PrintWriter(new OutputStreamWriter(sock.getOutputStream(), &quot;UTF-8&quot;));
            System.out.println(&quot;网络通信已建立&quot;);
        } catch (IOException ex) {ex.printStackTrace();}
    }
}
</code></pre>
<blockquote>
<p><strong>若现在就想尝试运行，那么就要输入本章末尾处的已编写好的服务器代码。现在一个终端启动服务器，接着用另一个终端启动这个客户端即可</strong>。</p>
</blockquote>
<h3 id="版本二发送与接收"><a class="header" href="#版本二发送与接收">版本二：发送与接收</a></h3>
<p><strong>Version Two: send and receive</strong></p>
<p><img src="images/Ch15_25.png" alt="具备发送和接收功能的 SimpleChatClient app" /></p>
<p><em>图 25 - 具备发送和接收功能的 <code>SimpleChatClient</code> app</em></p>
<p><strong>大问题：怎样从服务器获取消息</strong>？</p>
<p>应该不难；建立起网络通讯时，就要同时构造一个输入流（应该是个<code>BufferedReader</code>）。随后使用 <code>readLine()</code>读取消息。</p>
<p><strong>更大的问题：何时从服务器获取消息</strong>？</p>
<p><strong>Bigger Question: WHEN do you get messages from the server</strong>?</p>
<p>请思考一下这个问题。有哪些选项？</p>
<ol>
<li>
<p><strong>选项一：每隔20秒轮询一次服务器（Option One: Poll the server every 20 seconds）</strong></p>
<p><strong>优点（Pros）</strong>: 是的，这是可行的。</p>
<p><strong>弊端（Cons）</strong>：服务器怎么知道客户端已经收到的消息与尚未收到的消息？服务器就不得不把消息存储起来，而不是在每次收到消息后只要分发并忘却。并且为什么间隔是20秒？这样的延迟对可用性有影响，而如果降低这个延迟值，又会带来对服务器不必要冲击。这个选项效率底下（The server would have to store the messages, rather than just doing a distribute-and-forget each time it gets one. And why 20 seconds? A delay like this affects usability, but as you reduce the delay, you risk hitting your server needlessly. Inefficient）。</p>
</li>
<li>
<p><strong>选项二：在用户每次发送消息时从服务器读入一些东西（Option Two: Read something in from the server each time the user sends a message）</strong>。</p>
<p><strong>优点（Pros）</strong>: 可行，很容易。</p>
<p><strong>弊端（Cons）</strong>：笨办法。为什么要选择这样的任意时间去查收那些消息？如果用户一直潜水不发送任何消息会怎样呢？</p>
</li>
<li>
<p><strong>选项三：在服务器发出消息后立即读取消息（Option Three: Read messages as soon as they're sent from the server）</strong>。</p>
<p><strong>优点（Pros）</strong>: 最为高效，最佳可用性。</p>
<p><strong>弊端（Cons）</strong>: 怎样在同一时间完成两件事情？应该把代码放在何处？这就会涉及到某处的一个一直等待着从服务器读取的循环。然而这个循环应该放在哪里呢？在启动了 GUI后，就只有在GUI部件发出事件后，程序才有动作了，其他情况下程序是不会有任何动作的（How do you do two things at the same time? Where would you put this code? You'd need a loop somewhere that was always waiting to read from the server. But where would that go? Once you launch the GUI, nothing happens until an event is fired by a GUI component）。</p>
</li>
</ol>
<blockquote>
<p><strong>在 Java 中，真的可以一边走路一边嚼口香糖</strong>。</p>
</blockquote>
<p><strong>你肯定明白从现在开始就要采行选项三了吧</strong>。</p>
<p>这里要的是持续运行对来自服务消息进行检查，而又 <em>不会对用户与 GUI 交互能力造成干扰</em> 的东西（We want something to run continuously, checking for messages from the server, but <em>without interrupting the user's ability to interact with the GUI</em>）！那么在用户开心地输入消息，或者在众多传入消息中愉悦地滚动翻阅的同时，所需要的就是 <em>这美好场景背后</em>，有代码去持续读取来自服务器的新输入。</p>
<p>这就意味着这里最终需要一个新线程。一个新的、独立的栈（That means we finally need a new thread. A new, separate stack）。</p>
<p>这里要让在前面那个仅发送版（版本一）中完成的所有工作，还以同样方式运作，与此同时伴随一个新的 <strong>进程（process）</strong> 来读取来自服务器的信息，并将读取到的信息显示在传入文本区。</p>
<p>好吧，也不尽然是这样子的。除非计算机上有多个处理器，否则各个新 Java 线程也并非真正是运行在操作系统上的单独进程。不过这些新 Java 线程 <em>给人的感觉</em>，就跟独立进程一样（Well, not quite. Unless you have multiple processors on your computer, each new Java thread is not actually a separate process running on the OS. But it almost <em>feels</em> as though it is）。</p>
<h2 id="java中的多线程技术"><a class="header" href="#java中的多线程技术">Java中的多线程技术</a></h2>
<p><strong>Multithreading in Java</strong></p>
<p>Java在其语言结构中，就内置了多线程技术。同时构造一个新执行线程十分简单（Java has multiple threading built right into the fabric of the language. And it's a snap to make a new thread of execution）：</p>
<pre><code class="language-java">Thread t = new Thread();
t.start();
</code></pre>
<p>这就完了。通过创建新的 <code>Thread</code> <em>对象</em>，就启动了一个单独的、有着自己独有调用栈的 <em>执行线程</em>（That's it. By creating a new <code>Thread</code> <em>object</em>, you've launched a separate <em>thread of execution</em>, with its very own call stack）。</p>
<p><strong>然而这里有个问题（Except for one problem）</strong>。</p>
<p>上面的线程实际上什么也不会 <em>做</em>，因此可以说这个线程一出生就几乎“死了”。在线程死去时，他的新栈也会消失。故事结束（That thread doesn't actually <em>do</em> anything, so the thread &quot;dies&quot; virtually the instant it's born. When a thread dies, its new stack disappears again. End of story）。</p>
<p>因此这里缺失了一项关键组件 -- 线程的 <em>作业</em>。也就是说，这里需要打算让独立线程去运行的那些代码（So we're missing one key component -- the thread's <em>job</em>. In other words, we need the code that you want to have run by separate thread）。</p>
<p>Java 中的多线程技术，意味着这里必须同时要了解 <em>线程</em> 及由该线程所 <em>运行</em> 的 <em>作业</em>（Multiple threading in Java means we have to look at both the <em>thread</em> and the <em>job</em> that's <em>run</em> by the thread）。与此同时这里还会了解 <code>java.lang</code> 包中的 <code>Thread</code> 类。（请记住，<code>java.lang</code>无需手动导入、已被隐式导入，同时这个包中有着Java这门语言的一些最有基础的类，包括<code>String</code>及<code>System</code>等。）</p>
<h3 id="java有着多线程特性却只有一个thread类"><a class="header" href="#java有着多线程特性却只有一个thread类">Java有着多线程特性，却只有一个<code>Thread</code>类</a></h3>
<p><strong>Java has multiple threads but only on <code>Thread</code> class</strong></p>
<p>对于 <em>线程（thread）</em>，既可以讲作带小写字母 ‘t’ 的 <code>thread</code>，同时也可讲作带大写字母 ‘T’ 的 <code>Thread</code>。在讲到 <code>thread</code>，时，讲的是一条独立的执行线。也就是一个单独调用栈。而在讲到 <code>Thread</code>时，请想想 Java 的命名约定。Java 里以大写字母开头的都是些什么？都是些类和接口。那么在此情形下，<code>Thread</code>就是 <code>java.lang</code> 包中的一个类。而<code>Thread</code>对象表示的，就是一条 <em>执行线</em>；在每次想要启动一条新的执行线时，都会创建一个 <code>Thread</code> 类的实例。</p>
<blockquote>
<p><strong>一个线程就是一条单独 “执行线”</strong>。也即是一个单独的调用栈。</p>
<p><strong>而<code>Thread</code> 则是表示某个线程的 Java 类</strong>。</p>
<p><strong>要构造一个线程，就要构造一个 <code>Thread</code> 对象</strong>。</p>
</blockquote>
<p><img src="images/Ch15_26.png" alt="关于线程" /></p>
<p><em>图 26 - 关于线程</em></p>
<p>线程是一条独立的执行线（A thread(lower-case 't') is a separate thread of execution）。意思是一个单独调用栈。每个Java应用都会启动一个主线程 -- 那个把 <code>main()</code> 方法放在栈底部的线程。JVM负责主线程的启动（以及一些JVM选定的其他线程，包括垃圾回收线程等）。作为Java程序员，可编写代码来启动自己的其他线程。</p>
<p><img src="images/Ch15_27.png" alt="类 Thread" /></p>
<p><em>图 27 - 类<code>Thread</code></em></p>
<p><code>Thread</code> （带大写字母 <code>T</code>）是表示执行线程的一个类。有着用于启动线程、将一个线程与另一线程结合以及将线程置于睡眠状态等方法。（类<code>Thread</code>有着其他一些方法；这三个不过是这里需要用到关键方法）。</p>
<h3 id="具有多个调用栈指的是什么"><a class="header" href="#具有多个调用栈指的是什么">具有多个调用栈指的是什么？</a></h3>
<p><strong>What does it mean to have more than one call stack</strong>?</p>
<p>有了多个调用栈，就能得到同时发生多个事情的 <em>样子</em>。实际只有真正多处理器系统，才能真正地一次完成多个事情，而在Java多线程特性下，就可以 <em>出现</em> 同时完成多个事情。也就是说，代码执行可极为迅速地在多个调用栈之间前后移动，以至于这所有栈是在同时执行。请记住，Java只是运行在所在操作系统上的一个进程。因此首先，Java <em>本身</em> 就必须是操作系统上的 “当前正在执行的进程”。然而一旦Java得到他的执行轮次，JVM会利用这个执行轮次来 <em>运行什么</em> 呢？哪些字节码会执行呢？当然是位于当前正在执行栈顶部的那些！而就在 100 毫秒期间，当前执行代码就可能切换到一个 <em>不同</em> 栈的 <em>不同</em> 方法（With more than one call stack, you get the <em>appearance</em> of having multiple things happen at the same time. In reality, only a true multiprocessor system can actually do more than one thing at a time, but with Java threads, it can <em>appear</em> that you're doing several things simultaneously. In other words, execution can move back and forth between stacks so rapidly that you feel as though all stacks are executing at the same time. Remember, Java is just a process running os your underlying OS. So first, Java <em>itself</em> has to be 'the currently executing process' on the OS. But once Java gets its turn to execute, exactly <em>what</em> does the JVM <em>run</em>? Which bytecodes execute? Whatever is on the top of the currently-running stack! And in <code>100</code> milliseconds, the currently executing code might switch to a <em>different</em> method on a <em>different</em> stack）。</p>
<p>线程必须完成的事情中有一项，就是保持对线程栈上当前正在执行语句（所在方法）的跟踪（One of the things a thread must do is keep track of which statement(of which method) is currently executing on the thread's stack）。</p>
<p>线程工作原理看起来差不多是这样的：</p>
<ol>
<li>
<p><strong>JVM 调用 <code>main()</code> 方法</strong></p>
<pre><code class="language-java">public static void main(String[] args) {
    ...
}
</code></pre>
<p><img src="images/Ch15_28.png" alt="主进程" /></p>
<p><em>图 28 - 主进程</em></p>
</li>
<li>
<p><code>main()</code> 启动一个新线程。在新线程开始运行的同时，主线程被临时冻结（<code>main()</code> starts a new thread. The main thread is temporarily frozen while the new thread starts running）。</p>
<pre><code class="language-java">// 很快就会学到这里的 Runnable 对象 r 是什么意思。
Runnable r = new MyThreadJob();
Thread t = new Thread(t);
t.start();
Dog d = new Dog();
</code></pre>
<p><img src="images/Ch15_29.png" alt="主线程启动一个新的线程" /></p>
<p><em>图 29 - 主线程启动一个新的线程</em></p>
</li>
<li>
<p>JVM 在新线程（用户线程A）与原本的主线程直接不断切换，直到两个线程执行完毕。</p>
<p><img src="images/Ch15_30.png" alt="进入多线程执行阶段，在全部线程栈运行完毕之前，JVM于这些栈之间不断切换" /></p>
<p><em>图 30 - 进入多线程执行阶段，在全部线程栈运行完毕之前，JVM于这些栈之间不断切换</em></p>
</li>
</ol>
<h3 id="怎样启动一个新线程"><a class="header" href="#怎样启动一个新线程">怎样启动一个新线程</a></h3>
<p><strong>How to launch a new thread</strong></p>
<ol>
<li>
<p><strong>构造一个 <code>Runnable</code> 对象（即该新线程的作业）</strong></p>
<pre><code class="language-java">Runnable treadJob = new MyRunnable();
</code></pre>
<p><img src="images/Ch15_31.png" alt="构造一个Runnable 对象" /></p>
<p><em>图 31 - 构造一个<code>Runnable</code> 对象</em></p>
<p><code>Runnable</code> 是一个接口，后面马上就会学到。将会编写一个对 <code>Runnable</code> 接口进行实现的类，而正是在这个类中，去定义某个线程要执行的任务工作。也就是那些要在线程的新调用栈上运行的那个方法（<code>Runnable</code> is an interface you'll learn about on the next page. You'll write a class that implements the <code>Runnable</code> interface, and that class is where you'll define the work that a thread will perform. In other words, the method that will be run from the thread's new call stack）。</p>
</li>
<li>
<p><strong>构造一个<code>Thread</code> 对象（即工具人线程）并把一个<code>Runnable</code>对象（即作业）交给他（Make a <code>Thread</code> object(the worker) and give tit a <code>Runnable</code>(the job)）</strong></p>
<pre><code class="language-java">Thread myThread = new Thread(threadJob);
</code></pre>
<p><img src="images/Ch15_32.png" alt="以这个Runnable对象做参数，构造一个Thread对象" /></p>
<p><em>图 32 - 以这个<code>Runnable</code>对象做参数，构造一个<code>Thread</code>对象</em></p>
<p>将上面构造的新<code>Runnable</code>对象传递给 <code>Thread</code> 类构造器。这就告诉了新的<code>Thread</code>对象，要将哪个方法放在新执行栈 的底部 -- 当然是那个 <code>Runnable</code> 对象的 <code>run()</code> 方法。</p>
</li>
<li>
<p><strong>启动该线程（Start the <code>Thread</code>）</strong></p>
<pre><code class="language-java">myThread.start();
</code></pre>
<p>在调用该<code>Thread</code>对象的<code>start()</code>方法前，什么也不会发生。对此方法的调用，正是由一个<code>Thread</code>实例，向一条新执行线程转变的时间点。在新线程启动起来时，新线程就取得那个<code>Runnable</code>对象的<code>run()</code>方法，并将其放在新线程栈的底部（Nothing happens until you call the <code>Thread</code>'s <code>start()</code> method. That's when you go from having just a <code>Thread</code> instance to having a new thread of execution. When the new thread starts up, it takes the <code>Runnable</code> object's <code>run()</code> method and puts it on the bottom of the new thread's stack）。</p>
<p><img src="images/Ch15_33.png" alt="启动线程" /></p>
<p><em>图 33 - 启动线程</em></p>
</li>
</ol>
<h3 id="每个thread对象都需要一项要执行的作业即一个要放到新线程栈上的方法"><a class="header" href="#每个thread对象都需要一项要执行的作业即一个要放到新线程栈上的方法">每个<code>Thread</code>对象都需要一项要执行的作业。即一个要放到新线程栈上的方法。</a></h3>
<p><strong>Every <code>Thread</code> needs a job t do. A method to puton the new thread stack</strong>.</p>
<blockquote>
<p><strong><code>Runnable</code>对象之于<code>Thread</code>对象，就好比某项作业任务之于一名工人。<code>Runnable</code>对象就是线程要运行的作业（<code>Runnable</code> is to a <code>Thread</code> what a job is to a worker. A <code>Runnable</code> is the job a thread is supposed to run）。</strong></p>
<p><strong><code>Runnable</code>对象保存着那个将要放到新线程执行栈底部的方法：<code>run()</code>（A <code>Runnable</code> holds the method that goes on the bottom of the new thread's stack: <code>run()</code>）</strong>。</p>
</blockquote>
<p><code>Thread</code>对象需要作业。在现场启动起来时，线程就会运行一项作业。而那项作业，实际上就是去到新线程执行栈上的第一个方法，且作业务必总是一个看起来像这样的方法：</p>
<pre><code class="language-java">// 接口 Runnable 只定义了一个方法，那就是 public void run()
// （请记住，由于他是个接口，因此这个方法是 public 的，与
// 这里的是否像这样输入代码无关。）
//
// The Runnable interface defines only one method,
// public void run(). (Remember, it's an interface so the 
// method is public regardless of whether you type it in that
// way.)
public void run () {
    // 将被新线程运行的代码
}
</code></pre>
<p>线程怎样知道该放那个方法在执行栈的底部呢？因为<code>Runnable</code>接口定义了合约。因为<code>Runnable</code>是个接口。线程作业可被定义在任何的实现了<code>Runnable</code>接口的类里头。线程仅关心传递给<code>Threa</code>类构造器的，十一个实现了<code>Runnable</code>接口的类的对象（How does the thread know which method to put at the bottom of the stack? Because <code>Runnable</code> defines a contract. Because <code>Runnable</code> is an interface. A thread's job can be defined in any class that implements the <code>Runnable</code> interface. The thread cares only that you pass the <code>Thread</code> cnstructor an object of a class that implements <code>Runnable</code>）。</p>
<p>在将<code>Runnable</code>类型对象传递给<code>Thread</code>构造器时，真的就只是给予了那个<code>Thread</code>对象，一种抵达<code>run()</code>方法的方式。实在给予那个<code>Thread</code>对象其要执行的作业（When you pass a <code>Runnable</code> to a <code>Thread</code> constructor, you're really just giving the <code>Thread</code> a way to get to a <code>run()</code> method. You're giving the <code>Thread</code> its job to do）。</p>
<h3 id="要构造线程的作业就要实现runnable接口"><a class="header" href="#要构造线程的作业就要实现runnable接口">要构造线程的作业，就要实现<code>Runnable</code>接口</a></h3>
<p><strong>To mke a job for your thread, implement the <code>Runnable</code> interface</strong></p>
<pre><code class="language-java">// Runnable 是在 java.lang 包中，因此无需导入。
public class MyRunnable implements Runnable {
    private String incomingMessage;

    public MyRunnable (String message) {
        incomingMessage = message;
    }

    // Runnable只有一个要实现的方法：
    // public void run() （不带参数）
    // 这就是放置线程将要运行作业方法的地方。这也是那个
    // 位于新执行栈底部的方法。
    public void run () {
        go();
    }

    public void go () {
        doMore ();
    }

    public void doMore () {
        System.out.format(&quot;这是执行栈的顶部, 收到主线程传入的消息：%s\n&quot;, incomingMessage);
    }
}

class ThreadTester {
    public static void main (String[] args) {
        Runnable threadJob = new MyRunnable(&quot;你好，用户线程！&quot;);
        // 将新构造的Runnable实例，传入到这个
        // 新 Thread 构造器。这就告诉线程，把什么样的
        // 方法放在新执行栈的底部。也就是新执行栈将运行的
        // 第一个方法。
        Thread myThread = new Thread(threadJob);

        // 在没有调用这个 Thread 实例上的 start() 方法前，不会
        // 得到新的执行线程。在启动线程前，线程还不成其为线程。
        // 在启动 Thread 实例之前，他就跟其他的对象一样，
        // 只是个 Tread 的实例，而不会有任何真实的 “线程特征”（
        // Before that, it's just a Thread instance, like any 
        // other object, but it won't have any real 'threadness'）。
        myThread.start();

        System.out.println(&quot;回到主线程&quot;);
    }
}
</code></pre>
<blockquote>
<p><strong>注</strong>: 这段代码演示了：1、构造新线程；2、在构造新线程时，主线程往用户线程传递数据；3、Java 中主类可以不是显式 <code>public</code> 的类，或者说一个 <code>.java</code>文件中只能有一个<code>public</code>类的情况下，其他非显式<code>public</code>的类，也可作为Java的主类，作为<code>jar</code>包的执行进入点。</p>
</blockquote>
<p><img src="images/Ch15_34.png" alt="示例代码的执行栈图解" /></p>
<p><em>图 34 - 示例代码的执行栈图解</em></p>
<p>上面代码的输出，如下所示：</p>
<pre><code class="language-console">$java -jar learningJava/build/libs/com.xfoss.learningJava-0.0.1.jar
回到主线程
线程栈的顶部，收到主线程的消息：你好，用户线程！
</code></pre>
<h3 id="脑力锻炼-5"><a class="header" href="#脑力锻炼-5">脑力锻炼</a></h3>
<p>在运行 <code>ThreadTester</code> 类时，为什么会有上面这样的输出？</p>
<h3 id="新线程的三种状态"><a class="header" href="#新线程的三种状态">新线程的三种状态</a></h3>
<p><strong>The three state of a new thread</strong></p>
<pre><code class="language-java">Threed t = new Thread(r);
</code></pre>
<p><img src="images/Ch15_35.png" alt="线程的三种状态" /></p>
<p><em>图 35 - 线程的三种状态</em></p>
<p><strong>新构建（NEW）状态</strong></p>
<pre><code class="language-java">Thread t = new Thread(r);
</code></pre>
<p>线程已被创建但未被启动。也就是说，已经有了一个<code>Thread</code>对象，但还没有 <em>执行线</em>（A <code>Thread</code> instance has been created but not started. In other words, there is a <code>Thread</code> <em>object</em>, but no <em>thread of execution</em>）。</p>
<p><strong>可运行（RUNNABLE）状态</strong></p>
<pre><code class="language-java">t.start();
</code></pre>
<p>在启动这个线程时，他便进入到可运行状态。这意味着该线程准备好了运行，只是在等待着他被选作执行的时机。这个时候，就有了此线程的调用栈了（When you start the thread, it moves into the runnable state. This means the thread is ready to run and just waiting for its Big Change to be selected for execution. At this point, there is a new call stack for this thread）。</p>
<p><strong>运行（RUNNING）状态</strong></p>
<p>这是所有线程渴望的状态！成为被选中的那个线程。那个当前运行线程。而只有JVM的线程调度器，才能做出决定。有时可人为对该决定 <em>施加影响</em>，但无法强制某个线程从可运行状态转换成运行状态。在运行状态，线程（且 <strong>只有</strong> 这个线程）有着活动的调用栈，同时该调用栈顶部的那个方法在执行（This is the state all thread lust after! To be The Chosen One. The Currently Running Thread. Only the JVM thread scheduler can make that decision. You can sometimes <em>influence</em> that decision, but you cannot force a thread to move from runnable to running. In the running state, a thread (and ONLY this thread) has an active call stack, and the method on the top of the stack is executing）。</p>
<p><strong>然而关于线程状态，还有更多的东西。一旦线程成为可运行状态，他就可以在可运行状态（runnable）、运行状态（running），以及一些其他状态：<em>临时非可运行状态（temporarily not runnable）</em>（也叫做“阻塞状态（blocked）”） 之间交互变化</strong>。</p>
<h3 id="典型的可运行运行状态循环"><a class="header" href="#典型的可运行运行状态循环">典型的可运行/运行状态循环</a></h3>
<p><strong>Typical runnable/running loop</strong></p>
<p>典型情况下，JVM线程调度器选出某个线程来运行，并在随后将其踢回，而让另一线程有时机运行，如此线程是在可运行状态与运行状态直接来回切换的（Typically, a thread moves back and forth between runnable and running, as the JVM thread scheduler selects a thread to run and then kicks it bak out so another thread gets a chance）。</p>
<p><img src="images/Ch15_36.png" alt="典型状况下线程从可运行状态与运行状态之间变换" /></p>
<p><em>图 36 - 典型状况下线程从可运行状态与运行状态之间变换</em></p>
<h3 id="线程可被置为暂时非可运行状态"><a class="header" href="#线程可被置为暂时非可运行状态">线程可被置为暂时非可运行状态</a></h3>
<p><strong>A thread can be made temporarily not-runnable</strong></p>
<p><img src="images/Ch15_37.png" alt="线程的阻塞状态" /></p>
<p><em>图 37 - 线程的阻塞状态</em></p>
<p>因为各种不同原因，线程调度器可将运行状态线程，移入到阻塞状态。比如线程可能正在执行从套接字输入流读取数据的代码，但套接字输入流上现在并没有要读取的数据。那么调度器就会将该线程从运行状态移除，知道要读取的数据可用为止。或者线程正在执行的代码，告诉线程要将他自己置入睡眠状态（<code>sleep()</code>）。抑或可能由于在尝试调用某个对象上的方法，而那个对象却被“锁了起来”，因此该线程就处于等待状态。在这种情况下，直到所调用对象的锁，被持有这个锁的线程释放之前，等待中的线程，是无法继续执行的（The thread schedular can move a running thread into a blocked state, for a variety of reasons. For example, the thread might be executing code to read from a <code>Socket</code> input stream, but there isn't any data to read. The schedular will move the thread out of the running state until something becomes available. Or the executing code might have told the thread to put itself to sleep(<code>sleep()</code>). Or the thread might be waiting because it tried to call a method on an object, and that object was 'locked'. In that case, the thread can't continue until the object's lock is freed by the thread that has it）。</p>
<p>所有上述的情形（以及其他情形），都会导致线程成为临时非可运行状态（All of those conditions(and more) cause a thread to become temporarily not-runnable）。</p>
<h2 id="进程调度器"><a class="header" href="#进程调度器">进程调度器</a></h2>
<p><strong>The Thread Schedular</strong></p>
<p>线程调度器就谁将从可运行状态迁往运行状态，与何时（及在何种条件下）某个线程离开运行状态等事情，做出一切决定。调度器决定谁会运行，与运行多长时间，以及在调度器决定把某些线程从当前运行状态踢出去时，这些线程前往何处（The thread schedular makes all the decisions about who moves from runnable to running, and about when(and under what circumstances) a thread leaves the running state. The schedular decides who runs, and for how long, and where the threads go when the scheduler decides to kick them out of the currently-running state）。</p>
<p>编程者无法对调度器施加控制。调度器上并无调用方法的API。最重要的时，并无调度的任何保证！（虽然有那么几个 <em>近乎</em> 保证的东西，但就算这些也是毫无头绪的。）（You can't control the scheduler. There is no API for calling methods on the scheduler. Most importantly, there are no guarantees about scheduling! (There are a few <em>almost</em>-guarantees, but even those are a little fuzzy.)）</p>
<p>在处理线程调度器时，底线就是：<em><strong>不用把程序的正确运行，建立在调度器以某种特定方式运作的基础上</strong></em>！对于不同JVM，此调度器的实现是各异的，即使在同一台机器上运行同样的程序，都能给出不同的运行结果。新手Java程序员最糟糕的问题，就是在单台机器上测试他们的多线程程序，并错误地假定线程调度器会一致以那种方式运作，而不考虑程序会在何处运行（The bottom line is this: <em><strong>do not base your program's correctness on the scheduler working in a particular way</strong></em>! The scheduler implementations are different for different JVM's, and even running the same program on the same machine can give you different results. One of the worst mistakes new Java programmers make is to test their multi-threaded program on a single machine, and assume the thread scheduler will always work that way, regardless of where the program runs）。</p>
<p>而这到底对“一次编写各处运行”意味着什么呢？这意味着要编写独立于平台Java代码，那么所编写的多线程程序，就必须在不管线程调度器 <em>怎样</em> 行事，都要能工作。那就是说不能对，比如，调度器确保所有线程都能在运行状态上得到良好的、绝对公平的执行机会，有所依赖。尽管如今几乎不会有这样的情况发生：程序运行在一个有着这样说的调度器JVM上，“好的，五号线程，现在你可以执行了，在我仍管事的时候，你可以一直执行，直到你的 <code>run()</code> 方法执行完毕而结束为止”（So what does this mean for write-one-run-anywhere? It means that to write platform-independent Java code, your multi-threaded program must work no matter <em>how</em> the thread scheduler behaves. That means that you can't be dependent on, for example, the scheduler making sure all the threads take nice, perfectly fair and equal turns at the running state. Although highly unlikely today, your program might end up running on a JVM with a scheduler that says: &quot;Ok thread five, you're up, and as far as I'm concerned, you can stay here until you're done, when your <code>run()</code> method completes&quot;）。</p>
<p><img src="images/Ch15_38.png" alt="工作中的线程调度器" /></p>
<p><em>图 38 - 工作中的线程调度器</em></p>
<blockquote>
<p><strong>线程调度器就谁运行谁不运行做出所有决定。他通常会让线程们有着良好的队列。然而对此并无保证。线程调度器可能会让一个线程心满意足地运行的同时，而让其他线程饱受“饥饿”之苦（The thread scheduler makes all the decisions about who runs and who doesn't. He usually makes the threads take turns, nicely. But there's no guarantee about that. He might let one thread run to its heart's content while the other threads 'starve'）</strong>。</p>
</blockquote>
<p>这些东西的秘诀，几乎都在于 <em>睡眠</em>。对的，就是 <em>睡眠</em>。将某个线程置于睡眠中，即使几个毫秒的时间，就可以强制当前正在运行的线程离开运行状态，因此而给到另一线程运行的机会。<code>Thread</code>的静态方法 <code>sleep()</code>，有着 <em>一项</em> 明确的保证：在休眠时间超时之前，休眠中的线程，是不会成为当前运行线程的。比如，在告诉了线程休眠两秒（<code>2000</code>毫秒）后，那么在两秒钟时间过去之前，那个线程就绝不可能再度成为运行线程（The secret to almost everything is <em>sleep</em>. That's right, <em>sleep</em>. Putting a thread to sleep, even for a few milliseconds, forces the currently-running thread to leave the running state, thus giving another thread a chance to run. The <code>Thread</code>'s <code>sleep()</code> method does come with <em>one</em> guarantee: a sleeping thread will <em>not</em> become the currently-running thread before the length of its sleep time has expired. For example, if you tell your thread to sleep for two seconds (<code>2000</code> milliseconds), that thread can never become the running thread again until sometime <em>after</em> the two seconds have passed）。</p>
<h3 id="关于调度器不可预测的示例"><a class="header" href="#关于调度器不可预测的示例">关于调度器不可预测的示例</a></h3>
<blockquote>
<p>此示例即上面的 <code>MyRunable</code> 程序，经测试，在 <code>jdk11</code> 下输出实际上是恒定的。故在此省略。</p>
</blockquote>
<h3 id="为何会有不同的输出"><a class="header" href="#为何会有不同的输出">为何会有不同的输出？</a></h3>
<p><strong>How did we end up with different results</strong>?</p>
<p><strong>有时程序像这样运行（Sometimes it runs like this）</strong>:</p>
<p><img src="images/Ch15_39.png" alt="示例程序线程执行顺序之一" /></p>
<p><em>图 39 - 线程执行顺序之一</em></p>
<p><strong>而有时他会这样运行</strong>：</p>
<p><img src="images/Ch15_40.png" alt="示例程序线程执行顺序之二" /></p>
<h2 id="答疑-19"><a class="header" href="#答疑-19">答疑</a></h2>
<ul>
<li><strong>之前曾看到过一些没有使用单个 <code>Runnable</code> 实现，而是只构造了一个<code>Thread</code>子类并重写了<code>Thread</code>得 <code>run()</code> 方法的示例。那样的话，在构造新线程时，就相当于调用了 <code>Thread</code> 的无参数构造器（I've seen examples that don't use a separate <code>Runnable</code> implementation, but instead just make a subclass of <code>Thread</code> and override the <code>Thread</code>'s <code>run()</code> method. That way, you call the <code>Thread</code>'s no-arg constructor when you make the new thread）</strong>；</li>
</ul>
<pre><code class="language-java">Thread t = new Thread(); // 没有 Runnable
</code></pre>
<blockquote>
<p>是的，这是另一种构造自己的线程的方式，不过请从面向对象角度来思考这个问题。子类化操作的目的何在？请记住这里讲的是两个不同的事情 -- 类 <code>Thread</code> 与线程的 <em>作业（job）</em>。从面向对象视角来看，这二者有着完全不同的性质，且属于不同的类。在打算对类 <code>Thread</code> 进行子类化/扩展时，唯一目的就是要构造一个新的且更具体的<code>Thread</code>。也就是说，在将 <code>Thread</code> 当作工作者（worker）时，除非需要更具体的 <em>工作者（worker）</em> 行为，那么就请不要对 <code>Thread</code> 进行扩展。而在仅需要某个新 <em>作业</em> 由工作线程去运行时，就要对 <code>Runnable</code> 接口，在一个单独的、特定于<em>作业（job）</em> （而非特定于 <em>工作线程</em>） 的类中进行实现（Yes, that <em>is</em> another way of making your own thread, but think about it from an OO perspective. What's the purpose of subclassing? Remember that we're talking about two different things here -- the <code>Thread</code> and the thread's <em>job</em>. From an OO view, those two are very separate activities, and belong in separate classes. The only time you want to subclass/extend the <code>Thread</code> class, is if you are making a new and more specific type of <code>Thread</code>. In other words, if you think of the <code>Thread</code> as the worker, don't extend the <code>Thread</code> class unless you need more specific <em>worker</em> behaviors. But if all you need is a new <em>job</em> to be run by a <code>Thread</code>/worker, then implement <code>Runnable</code> in a separate, <em>job</em>-specific (not <em>worker</em>-specific) class）。</p>
<p>这是个设计问题，而非性能或语言问题。对<code>Thread</code>进行子类化，以及重写 <code>run()</code> 方法，是完全合法的，但这样做只有在极少的情况下，才是不错的主意（This is a design issue and not a performance or language issue. It's perfectly legal to subclass <code>Thread</code> and override the <code>run()</code> method, but it's rarely a good idea）。</p>
</blockquote>
<ul>
<li><strong>可以重用某个<code>Thread</code>对象吗？就是可以交给他一项新的作业，然后通过再次调用 <code>start()</code> 方法来重启他吗</strong>？</li>
</ul>
<blockquote>
<p>不行。一旦线程的 <code>run()</code>方法执行完毕，那么这个线程就再也不能被重启了。事实上，线程在那个时间点就过渡到一种还不曾讲到的状态 -- <em><strong>死亡（dead）</strong></em> 状态。在死亡状态，线程已经完成他的 <code>run()</code> 方法，且绝不可能被重启。那个<code>Thread</code>对象可能仍在内存堆上，作为一个存活的对象，可调用其另外的方法（只有一些适当的方法），然而这个<code>Thread</code>对象已经永远失去了他的 “线程性质”。也就是说，已经没有了单独的调用栈，同事这个 <code>Thread</code> 对象也不在是一个 *线程（thread）*了。这个时候他就仅仅是个对象，与其他对象别无二致（No. Once a thread's <code>run()</code> method has completed, the thread can never be restarted. In fact, at that point the thread moves into a state we haven't talked about -- <em><strong>dead</strong></em>. In the dead state, the thread has finished its <code>run()</code> method and can never be restarted. The <code>Thread</code> object might still be on the heap, as a living object that you can call other methods(if appropriate), but the <code>Thread</code> object has permanently lost its 'threadness'. In other words, there is no longer a separate call stack, and the <code>Thread</code> object is no longer a <em>thread</em>. It's just an object, at that point, like all other objects）。</p>
<p>然而，是有一些构造线程池的设计模式的，在这样的设计模式下，就可以持续使用<code>Thread</code>对象来完成不同作业。但不是通过调用死亡线程上的 <code>restaring()</code> 方法来完成的（But, there are design patterns for making a pool of threads that you can keep using to perform different jobs. But you don't do it by <code>restarting()</code> a dead thread）。</p>
</blockquote>
<h2 id="重点知识"><a class="header" href="#重点知识">重点知识</a></h2>
<ul>
<li>Java中带小写字母 <code>t</code> 的 <code>thread</code>，指的是一条单独的执行线（A thread with a lower-case 't' is a separate thread of execution）；</li>
<li>Java 中所有线程都有自己的调用栈（Every thread in Java has its own call stack）；</li>
<li>带大写字母<code>T</code>的 <code>Thread</code>，指的是类 <code>java.lang.Thread</code>。而<code>Thread</code>对象，则表示一条执行线；</li>
<li><code>Thread</code>对象需要一项去完成的作业。而<code>Thread</code>对象的作业，是某个实现了<code>Runnable</code>接口的东西；</li>
<li><code>Runnable</code>接口只有一个方法，那就是<code>run()</code>方法。这个方法会去往新调用栈的底部。也就是说，这是在新线程中第一个运行的方法；</li>
<li>要启动新线程，就需要将一个<code>Runnable</code>类型的对象，传递给类<code>Thread</code>的构造器；</li>
<li>在已经实例化出一个 <code>Thread</code>对象，而尚未调用该对象的 <code>start()</code> 方法时，线程是在一种 新建（NEW） 状态中的；</li>
<li>在启动了某个线程（通过调用这个 <code>Thread</code> 对象的 <code>start()</code> 方法）时，就创建出了一个新栈，这个新栈的底部，就是 <code>Runnable</code> 类型对象的 <code>run()</code> 方法。这个线程现在处于 可运行（RUNNABLE） 状态，等待着被 JVM 选去运行；</li>
<li>在 JVM 的线程调度器将某个线程选中去作为当前运行线程时，这个线程就被成为 运行中的 线程。在单个处理器的机器上，某个时刻只能有一个当前运行线程；</li>
<li>有的时候线程可从 运行（RUNNING）状态，被移动到 阻塞（临时非可运行，BLOCKING，temporarily non-runnable）状态。线程可能由于等待来自某个流的数据，或由于已进入睡眠，抑或由于等待某个对象的锁，而进入阻塞状态；</li>
<li>线程调度是不保证以某种特定方式去运作的，因此就无法确定线程们会良好地排队。通过将线程间歇地置入睡眠状态，可对调度排队施加影响（Thread scheduling is not guaranteted to work in any particular way, so you cannot be certain that threads will take turns nicely. You can help influence turn-taking by putting your threads to sleep periodically）。</li>
</ul>
<h3 id="将线程置为睡眠状态"><a class="header" href="#将线程置为睡眠状态">将线程置为睡眠状态</a></h3>
<p><strong>Putting a thread to sleep</strong></p>
<p>帮助线程获取运行机会的最佳方式之一，就是将这些线程定期置于睡眠状态。需要做的仅是调用静态的<code>sleep()</code>方法，传递给他以毫秒计算的睡眠时长（One of the best ways to help your threads take turns is to put them to sleep periodically. All you need to do is call the static <code>sleep()</code> method, passing it the sleep duration, in milliseconds）。</p>
<p>比如：</p>
<pre><code class="language-java">Thread.sleep(2000);
</code></pre>
<p>就好将某个线程从运行状态敲出去，然后让其保持在可运行状态之外两秒钟。这样在至少两秒钟时间过去之前，这个线程是无法再度成为运行线程的（will knock a thread out of the running state, and keep it out of the runnable state for two seconds. The thread <em>can't</em> become the running thread again until after at least two seconds have passed）。</p>
<p>有点遗憾的是，这个 <code>sleep()</code> 方法会抛出一个 <code>InterruptedException</code> 异常，这是一个受检查的异常，因此所有对 <code>sleep()</code> 的调用，都必须封装在 <code>try/catch</code> 代码块（或被声明出来）。因此一个真正的 <code>sleep()</code> 调用，看起来是这样的：</p>
<pre><code class="language-java">try {
    Thread.sleep(2000);
} catch (InterruptedException ex) {ex.printStackTrace();}
</code></pre>
<p>线程几乎是绝不会被睡眠中断的；这个异常是在 API 中，为了支持线程通信的机制，而这种机制在现实中几乎不会被用到。不过仍必须遵从异常处理或声明的原则，因此就需要习惯将这个 <code>sleep()</code> 方法，封装在 <code>try/catch</code> 中（Your thread will probably <em>never</em> be interrupted from sleep; the exception is in the API to support a thread communication mechanism that almost nobody uses in the Real World. But, you still have to obey the handle or declare law, so you need to get used to wrapping your <code>sleep()</code> calls in a <code>try/catch</code>）。</p>
<blockquote>
<p><strong>在要确保其他线程获得运行时机时，就把某个线程置于睡眠状态（Put your thread to sleep if you want to be sure that other threads get a chance to run）</strong>。</p>
<p><strong>在线程苏醒时，他回到的总是可运行状态，并等待着线程调度器将其选去再度运行（When the thread wakes up, it always goes back to the runnable state and waits for the thread scheduler to choose it to run again）</strong>。</p>
</blockquote>
<p>既然已经清楚在指定的时长 <em>之前</em> 线程不会苏醒，那么在 “计时器” 超时后的某个时刻，线程就可能会醒过来吗？答案是可能会也可能不会。这并不重要，真的，因为在线程苏醒时，<em><strong>总是会回到可运行状态</strong></em>！线程在指定时间不会自动苏醒并成为当前运行线程。在线程苏醒时，线程仍然是受线程调度器支配的。现在对于那些对分时要求不怎么苛刻的应用，以及那些仅有少数几个线程的应用，其中的线程差不多再苏醒时就会准时（也就是在设定的2000毫秒过后）继续其运行状态。但仍然不能把我们的程序押注在这种可能性上（Now you know that your thread won't wake up <em>before</em> the specified duration, but is it possible that it will wake up some time <em>after</em> the 'timer' has expired? Yes and no. It doesn't matter, really, because when the thread wakes up, <em><strong>it always goes back to the runnable state</strong></em>! The thread won't automatically wake up at the designated time and become the currently-running thread. When a thread wakes up, the thread is once again at the mercy of the thread scheduler. Now, for applications that don't require perfect timing, and that have only a few threads, it might appear as though the thread wakes up and resumes running right on schedule(say, after the <code>2000</code> milliseconds). But don't be your program on it）。</p>
<h3 id="运用睡眠来令到程序更可预测"><a class="header" href="#运用睡眠来令到程序更可预测">运用睡眠来令到程序更可预测</a></h3>
<p><strong>Using sleep to make our program more predictable</strong></p>
<p>还记得先前那个在每次运行时都会给出不同结果的示例吧（注：实际上那个示例不会）？请回顾并对代码和样本输出加以研究。有的时候主线程必须等待那个新线程执行完毕（并打印出“位于栈顶部”），而另一些时候新线程在他执行完毕之前会被送回到可运行状态，而允许主线程回来执行并打印出“回到主线程”。那么该怎样来修复这种不确定性呢？请停下来思考一下，然后回答这个问题：“在那个地方可以放入一个<code>sleep()</code>的调用，从而确保始终在打印出‘位于栈的顶部’之前，先打印出‘回到主线程’”（Remember our earlier example that kept giving us different results each time we ran it? Look back and study the code and the sample output. Sometimes main had to wait until the new thread finished(and printed &quot;top o' the stack&quot;), while other times the new thread would be sent back to runnable before tit was finished, allowing the main thread to come back in and print out &quot;back in main&quot;. How can we fix this? Stop for a moment and answer this question: &quot;Where can you put a <code>sleep()</code> call, to make sure the 'back in main' always prints before 'top o' the stack'&quot;）？</p>
<p>在你得出答案前，这里会等待（当然答案不止一个）。</p>
<p>想到答案了吗？</p>
<pre><code class="language-java">package com.xfoss.learningJava;

public class MyRunnable implements Runnable {
    private String incomingMessage;

    public MyRunnable (String message) {
        incomingMessage = message;
    }

    public void run () {
        go();
    }

    public void go () {
        doMore();
    }

    public void doMore () {
    
        // 在这里调用 sleep() 将强制新线程离开当前运行状态！
        try {
            Thread.sleep(2000);
        } catch (InterruptedException ex) {ex.printStackTrace();}

        // 主线程将再次成为当前运行线程，并打印出 “回到主线程”。随后
        // 在到这条语句打印出“线程栈的顶部......”之前，就会有个
        // 暂停（大概两秒钟时间）了
        System.out.format(&quot;线程栈的顶部，收到主线程的消息：%s\n&quot;, incomingMessage);
    }
}

class ThreadTester {
    public static void main (String[] args) {
        Runnable threadJob = new MyRunnable(&quot;你好，用户线程！&quot;);
        Thread myThread = new Thread(threadJob);

        myThread.start();

        System.out.println(&quot;回到主线程&quot;);
    }
}
</code></pre>
<h2 id="构造并启动两个线程"><a class="header" href="#构造并启动两个线程">构造并启动两个线程</a></h2>
<p><strong>Making and starting two threads</strong></p>
<p>线程是有名称的。可给线程取一个自己选择的名字，或者可以接收线程的默认名称。然而关于线程名称的有趣一面在于，可使用他们来了解哪个线程是在运行中。下面的示例，启动了两个线程。两个线程的作业相同：运行一个循环，每次迭代时打印出当前运行线程的名称（Threads have names. You can give your threads a name of your choosing, or you can accept their default names. But the cool thing about names is that you can use them to tell which thread is running. The following example starts two threads. Each thread has the same job: run in a loop, printing the currently-running thread's name with each iteration）。</p>
<pre><code class="language-java">package com.xfoss.learningJava;

public class RunThreads implements Runnable {
    private Thread alpha;
    private Thread beta;

    public RunThreads () {
        // 构造两个线程，他们有着同样的 Runnable 实例（
        // 即同样的作业 -- 接下来会讲到更多有关 “两个线程与一个
        // Runnable 作业”这种情况）。
        alpha = new Thread(RunThreads.this);
        beta = new Thread(RunThreads.this);

        // 给这两个线程取名字。
        alpha.setName(&quot;Alpha thread&quot;);
        beta.setName(&quot;Beta thread&quot;);
        
        // 启动这两个线程。
        alpha.start();
        beta.start();
    }

    public static void main (String[] args) {
        // 这里构造了一个 Runnable 类型的实例。
        new RunThreads();
    }

    public void run () {
        // 两个线程都会贯通行这个循环，每次迭代
        // 都会打印出线程的名称。
        for (int i = 0; i &lt; 5; i++) {
            String threadName = Thread.currentThread().getName();
            System.out.format(&quot;%s is running.\n&quot;, threadName);
        }
    }
}
</code></pre>
<p>经测试（重复运行 20 遍），上面的代码，运行的结果均为：</p>
<pre><code class="language-console">$ java -jar build/libs/com.xfoss.learningJava-0.0.1.jar 
Alpha thread is running.
Alpha thread is running.
Alpha thread is running.
Alpha thread is running.
Alpha thread is running.
Beta thread is running.
Beta thread is running.
Beta thread is running.
Beta thread is running.
Beta thread is running.
</code></pre>
<p>将上面的 <code>RunThreads</code> 修改为下面这样：</p>
<pre><code class="language-java">package com.xfoss.learningJava;

public class RunThreads implements Runnable {
    private Thread alpha;
    private Thread beta;

    public RunThreads () {
        // 构造两个线程，他们有着同样的 Runnable 实例（
        // 即同样的作业 -- 接下来会讲到更多有关 “两个线程与一个
        // Runnable 作业”这种情况）。
        alpha = new Thread(RunThreads.this);
        beta = new Thread(RunThreads.this);

        // 给这两个线程取名字。
        alpha.setName(&quot;Alpha thread&quot;);
        beta.setName(&quot;Beta thread&quot;);
        
        // 启动这两个线程。
        alpha.start();
        beta.start();
    }

    public static void main (String[] args) {
        // 这里构造了一个 Runnable 类型的实例。
        new RunThreads();
    }

    public void run () {
        for (int i = 0; i &lt; 5; i++) {

            try {
                Thread.sleep(50);
            } catch (InterruptedException ex) {ex.printStackTrace();}

            String threadName = Thread.currentThread().getName();
            System.out.format(&quot;%s is running.\n&quot;, threadName);
        }
    }
}
</code></pre>
<p>运行结果就变成：</p>
<pre><code class="language-console">$ java -jar build/libs/com.xfoss.learningJava-0.0.1.jar 
Alpha thread is running.
Beta thread is running.
Beta thread is running.
Alpha thread is running.
Beta thread is running.
Alpha thread is running.
Beta thread is running.
Alpha thread is running.
Beta thread is running.
Alpha thread is running.
</code></pre>
<pre><code class="language-console">$ java -jar build/libs/com.xfoss.learningJava-0.0.1.jar 
Alpha thread is running.
Beta thread is running.
Alpha thread is running.
Beta thread is running.
Alpha thread is running.
Beta thread is running.
Alpha thread is running.
Beta thread is running.
Alpha thread is running.
Beta thread is running.
</code></pre>
<pre><code class="language-console">$ java -jar build/libs/com.xfoss.learningJava-0.0.1.jar 
Alpha thread is running.
Beta thread is running.
Beta thread is running.
Alpha thread is running.
Alpha thread is running.
Beta thread is running.
Alpha thread is running.
Beta thread is running.
Alpha thread is running.
Beta thread is running.
</code></pre>
<p>可以看出，输出结果具有不确定性了。</p>
<h3 id="将发生什么"><a class="header" href="#将发生什么">将发生什么？</a></h3>
<p><strong>What will happen</strong>?</p>
<p>这两个线程会依次运行吗？会看到线程名称交替出现吗？线程切换有多频繁？循环的每次迭代都会切换吗？还是在五次循环迭代后会发生线程切换？</p>
<p>答案当然是已知的：<em>对这些我们一无所知</em>！这些都取决于调度器。且在指定OS上，以指定JVM，在指定CPU上，每次运行仍会得到极为不同的结果。</p>
<p>在 OS X 10.2（<code>Jaguar</code>）下运行此程序，在五次或五次循环迭代以内，线程 Alpha 就会运行完毕，随后线程 Beta 运行完毕。在不同的此程序执行时，这种结果将极为一致。虽然没有保证，但会极为一致。</p>
<p>但在执行到25次或更多的循环迭代时，情况就开始摇摆不定了。线程 Alpha 可能在还没有执行完 25 次循环迭代时，线程调度器就会将其送回到可执行状态，以让线程 Beta 有机会运行（But when you up the loop to 25 or more iterations, things start to wobble. The Alpha thread might not get to complete all 25 iterations before the scheduler sends it back to runnable to let the Beta thread have a chance）。</p>
<h2 id="多个流程难道不精彩么"><a class="header" href="#多个流程难道不精彩么">多个流程难道不精彩么？</a></h2>
<p><strong>Aren't threads wonderful</strong>?</p>
<p><strong>嗯，是的。（在有多个流程时）存在着一个目前为止尚未揭示的一面。多个线程会导致并发 “问题”（Um, yes. There IS a dark side. Threads can lead to concurrency 'issues'）</strong>。</p>
<p>并发问题导致竞争情形。而竞争情形会导致数据不一致。数据不一致又导致恐惧......你知道接下来会是什么情况了（Concurrency issues lead to race conditions. Race conditions lead to data corruption. Data corruption leads to fear...you know the rest）。</p>
<p>然而这一切都归结于一种潜在的致命场景：两个以上的线程，对同一个对象的 <em>数据</em> 进行访问。也就是执行在两个不同线程栈上的一些方法，都在调用, 比如说，内存堆上同一对象的读取器或设置器（It all comes down to one potentially deadly scenario: two or more threads have access to a single object's <em>data</em>. In other words, methods executing on two different stacks are both calling, says, getters or setters on a single object on the heap）。</p>
<p>这整个就是“左右手互博”的混乱局面。两个线程丝毫不在意对方，欢快地执行着他们各自的那些方法，他们两都以为自己是那个真正的线程。然而他们不知道的是这里有那么一个重要的事情。在他们各自欢快运行之后，在某个线程不在运行中，而处于可运行状态（或阻塞状态）时，这个线程就基本上被线程调度器打入昏迷状态。而当这个线程再度成为当前运行线程是，他是不知道他曾停下来过的（It's a whole 'left-hand-doesn't-know-what-the-right-hand-is-doing thing. Two threads, without a care in the world, humming along executing their methods, each thread thinking that he is the One True Thread. The only one that matters. After all, when a thread is not running, and in runnable(or blocked) it's essentially knocked unconscious. When it becomes the currently-running thread again, it doesn't know that it ever stopped）。</p>
<h3 id="陷入麻烦中的婚姻"><a class="header" href="#陷入麻烦中的婚姻">陷入麻烦中的婚姻</a></h3>
<p><strong>这两口子还有救吗</strong>？</p>
<p><em><strong>接下来，请观看一节非常特别的 Dr. Steve 秀（Next, on a very special Dr. Steve Show）</strong></em></p>
<p>[转载自第 42 集（Transcript from episode #42）]</p>
<p>欢迎来到斯蒂夫博士秀场。</p>
<p>今天的故事，是完全围绕两口子闹掰的两大原因 -- 管钱和睡觉，而展开的（We've got a story today that's centered around the top two reasons why couple split up -- finances and sleep）。</p>
<p>今天的问题夫妻，是 Ryan 和 Monica, 他们睡一张床，把钱放在一起。如果找不到法子，他俩也就长久不下去了。问题是啥？就是那个很悠久的 “两人一个银行账户”的事情。</p>
<p>Monica 是这么跟我讲的：</p>
<p>“Ryan 和我商量好了，谁也不要透支这个银行账户。所以就有这样的手续，不管谁要取钱，都要事先检查一下账户余额。这本来就是个简单的事情。可是突然我们俩都透支了，还被扣了透支费！</p>
<p>我觉得这是不可能的发生的，我觉得我两的手续没有问题。然而下面的事情还是发生了：</p>
<p>Ryan有次需要取 $50，所以他检查了账户余额，看到账户里有 $100。这当然没有问题，他就即将取钱了。<strong>但是这个时候他睡着了</strong>！</p>
<p>就在他睡着的时候，我来了，现在我要取 $100。于是我检查了余额，发现有 $100（因为 Ryan 还在睡觉而没有取出他的 $50），那么我就想，取 $100 没有问题。因此就把那 $100 取出来了，到这里还是没毛病。可是在 Ryan 醒来后，继续了他的取钱，这个时候突然间我们就透支了！他甚至不知道他曾睡着过，所以他就在没有再次检查账户余额的情况下，直接完成了他取钱这个事。你一定得帮帮我们啊，斯蒂夫博士”！</p>
<p>有办法吗？他们就这样完了吗？这里没办法让 Ryan 不睡觉，不过可以确保在 Ryan 醒来之前，不让 Monica 去动银行账户吗？</p>
<p>在切进广告期间，请花点时间来思考这个问题。</p>
<h3 id="ryan-与-monica-问题的代码实现"><a class="header" href="#ryan-与-monica-问题的代码实现">Ryan 与 Monica 问题的代码实现</a></h3>
<p><strong>The Ryan and Monica problem, in code</strong></p>
<p>下面的示例，展示了在 <em>两个</em> 线程共用 <em>同一个</em> 对象时，所发生的事情（The following example show what can happen when <em>two</em> threads(Ryan and Monica) share a <em>single</em> object(the bank account)）。</p>
<p>该代码有两个类，<code>BankAccoutn</code> 与 <code>MonicaAndRyanJob</code>，类 <code>MonicaAndRyanJob</code> 实现了 <code>Runnable</code>，并表示 Ryan 与 Monica 俩都具备的行为 -- 检查账户余额并进行取款操作。然而显然，两个线程在检查余额和真正取钱 <em>之间</em>，会睡过去的。</p>
<p>类<code>MonicaAndRyanJob</code>有个类型为 <code>BankAccount</code>的实例变量，表示他们共用的账户。</p>
<p><img src="images/Ch15_41.png" alt="Ryan和Monica问题代码实现的设计" /></p>
<p><em>图 41 - Ryan和Monica问题代码实现的设计</em></p>
<p>此代码工作原理如下：</p>
<ol>
<li>
<p><strong>构造一个 <code>RyanAndMonicaJob</code>的实例</strong></p>
<p>类<code>RyanAndMonicaJob</code>是 <code>Runnable</code>（即要执行的作业）的，同时 Monica 和 Ryan 都进行同样的事（检查余额与取钱），因此这里只需要一个实例。</p>
<pre><code class="language-java">RyanAndMonicaJob theJob = new RyanAndMonicaJob();
</code></pre>
</li>
<li>
<p><strong>以这同样的 <code>Runnable</code> 实例（即上面那个 <code>RyanAndMonicaJob</code>实例），构造两个线程</strong></p>
<pre><code class="language-java">Thread one = new Thread(theJob);
Thread two = new Thread(theJob);
</code></pre>
</li>
<li>
<p><strong>分别对这两个线程进行命名和启动</strong></p>
<pre><code class="language-java">one.setName(&quot;Ryan&quot;);
two.setName(&quot;Monica&quot;);

one.start();
two.start();
</code></pre>
</li>
</ol>
<p>4） <strong>同时对两个线程执行他们的 <code>run()</code> 方法加以观察</strong>（检查余额并取钱）</p>
<pre><code>一个线程代表 Ryan, 另一个表示 Monica。两个线程都持续对余额进行检查，并随后取出一笔钱，不过只有在不透支的情况下才支取！

```java
if (accout.getBalance() &gt;= amount) {
    try {
        Thread.sleep(500);
    } catch (InterruptedException ex) {ex.printStackTrace();}
}
```
</code></pre>
<p><strong>在方法 <code>run()</code> 里头，完成 Ryan 和 Monica 正要做的 -- 检查账户余额，并在有足够钱的情况下，取出一笔钱</strong>。</p>
<p><strong>这样处理应该可以保护到免受透支的问题</strong>。</p>
<p><strong>除非......Ryan 和 Monica 在检查完余额后、在完成账户支取前，总是会睡过去</strong>。</p>
<h3 id="ryan和monica-示例"><a class="header" href="#ryan和monica-示例">Ryan和Monica 示例</a></h3>
<p><strong>The Ryan and Monica example</strong></p>
<pre><code class="language-java">package com.xfoss.learningJava;

class BankAccount {
    // 账户以余额 100 块开始。
    private int balance = 100;

    public int getBalance () {
        return balance;
    }

    public void withdraw (int amount) {
        balance = balance - amount;
    }
}

public class RyanAndMonicaJob implements Runnable {
    // 只有一个 RyanAndMonicaJob 的实例。这就意味着只有一个
    // 银行账户的实例。两个线程都将对这个账户进行操作。
    private BankAccount account = new BankAccount ();

    // 这是 RyanAndMonicaJob 的构造函数。
    public RyanAndMonicaJob () {
        // 构造两个线程，把同样的这个 Runnable 作业交给这两个
        // 线程。这就意味着两个线程都将对这个Runnable类型类
        // 中的账户实例进行操作。
        Thread one = new Thread(RyanAndMonicaJob.this);
        Thread two = new Thread(RyanAndMonicaJob.this);

        one.setName(&quot;Ryan&quot;);
        two.setName(&quot;Monica&quot;);

        one.start();
        two.start();
    }

    public static void main (String[] args) {
        new RyanAndMonicaJob();
    }

    public void run () {
        // 在这个 run() 方法中，线程会遍历循环，并尝试在
        // 每次迭代中对银行账户进行支取。在每次支取后，会
        // 再次检查余额，看账户是否已经透支。
        for (int x = 0; x &lt; 10; x++) {
            int random;

            while (true) {
                double mathRandom = Math.random();

                if ( mathRandom &lt; 0.1) continue;
                else {
                    random = (int) (mathRandom * 10);
                    break;
                }
            }

            makeWithdrawal(random*10);
            if (account.getBalance() &lt; 0) {
                System.out.format(&quot;账户已透支！余额为 %d\n&quot;, accout.getBalance());
                break;
            }
        }
    }

    private void makeWithdrawal (int amount) {

        String currentThread = Thread.currentThread().getName();

        System.out.format(&quot;%s 即将进行支取，数额为 %d, 此时余额为 %d\n&quot;, 
                currentThread, amount, account.getBalance());

        // 检查余额，在余额不足以进行支取时，只打印一条消息。而有
        // 足够支取的余额时，进入睡眠，随后在醒过来并完成支取，就
        // 跟上面 Ryan 做的那样。
        if (account.getBalance() &gt;= amount){

            try {
                System.out.format(&quot;%s 即将睡过去\n&quot;, currentThread);

                Thread.sleep(500);
            } catch (InterruptedException ex) {ex.printStackTrace();}

            System.out.format(&quot;%s 醒过来了\n&quot;, currentThread);

            account.withdraw(amount);
            System.out.format(&quot;%s 完成了支取，支出数额 %d, 此时账户余额为 %d\n&quot;, 
                    currentThread, amount, account.getBalance());
        }
        else {
            // 程序中放了很多 System.out.format 语句，为的是可以看到在程序
            // 运行时都发生了些什么。
            System.out.format(&quot;抱歉，%s, 已经余额不足\n&quot;, currentThread);
        }
    }
}
</code></pre>
<p>该程序某次运行的输出为：</p>
<pre><code class="language-console">$java -jar build/libs/com.xfoss.learningJava-0.0.1.jar                         ✔ 
Monica 即将进行支取，数额为 80, 此时余额为 100
Ryan 即将进行支取，数额为 30, 此时余额为 100
Ryan 即将睡过去
Monica 即将睡过去
Ryan 醒过来了
Monica 醒过来了
Monica 完成了支取，支出数额 80, 此时账户余额为 -10
Ryan 完成了支取，支出数额 30, 此时账户余额为 70
账户已透支！余额为 -10
账户已透支！余额为 -10
</code></pre>
<p><strong>方法 makeWithdrawal() 始终会在支取一边款项之前，对余额进行检查，然而还是透支了账户</strong>。</p>
<p><strong>这是一种情形</strong>：</p>
<p>Ryan 查看了余额，发现有足够的钱，然后睡了过去。</p>
<p>与此同时，Monica 来了，并查看了余额。她也发现账户里有足够的钱。她不知到Ryan要醒过来并完成支取。</p>
<p>Monica 睡了过去。</p>
<p>Ryan 醒了，并完成了支取。</p>
<p>Monica 醒了，并完成了支取。这里就有个大问题了！在Monica查看余额和取出一笔钱的期间，Ryan 醒过来了并从账户里取走了钱。</p>
<p><strong>Monica 之前对账户的检查，是无效的，这是由于Ryan虽然完成了对账户余额的检查，但Monica 检查的时间，还是在Ryan取钱的过程中（Monica's check of the account was not valid, because Ryan had already checked and was still in the middle of making a withdrawal）</strong>。</p>
<p>那么在 Ryan 醒过来并完成他的支取事务之前，Monica就必须停止触及银行账户。相反在 Monica 醒过来之前，Ryan也必须停止触及银行账户。</p>
<h3 id="他们需要一把账户访问的锁"><a class="header" href="#他们需要一把账户访问的锁">他们需要一把账户访问的锁！</a></h3>
<p><strong>They need a lock for account access</strong>!</p>
<p><strong>该锁像这样运作</strong>：</p>
<p>1） 存在一把与银行账户事务（检查余额并支取款项）关联的锁。锁只有一把钥匙，在没有人要访问银行账户的时候，锁与钥匙是在一起的。</p>
<pre><code>![事务锁的初始状态](images/Ch15_42.png)

*图 42 - 事务锁的初始状态*
</code></pre>
<ol start="2">
<li>
<p>在 Ryan 打算访问银行账户时（去查看余额及支取款项），他就要锁上那把锁并把钥匙揣在自己兜里。现在，在Ryan交出钥匙前，就没有人可以对该账户进行访问了。</p>
<p><img src="images/Ch15_43.png" alt="给事务锁上锁" /></p>
<p><em>图 43 - 给事务锁上锁</em></p>
</li>
<li>
<p><strong>在Ryan完成有关银行账户事务的操作之前，他都是把这把钥匙揣在兜里的</strong>。此时他有着唯一的那把钥匙，因此在 Ryan 解锁账户并退还钥匙之前，Monica 就无法对银行账户（或支票簿）进行访问。</p>
</li>
</ol>
<p>现在，就算Ryan在查看了余额后睡着了，他也得到了在他醒过来后余额与他检查时保持一致的保证，这正是由于他在睡着时，保留着事务锁的钥匙！</p>
<p><img src="images/Ch15_44.png" alt="事务锁的释放" /></p>
<p><em>图 44 - 事务锁的释放</em></p>
<h3 id="这里就需要-makewithdrawal方法以类似原子的方式运行"><a class="header" href="#这里就需要-makewithdrawal方法以类似原子的方式运行">这里就需要 <code>makeWithdrawal()</code>方法以类似原子的方式运行。⚛️</a></h3>
<p><strong>We need the <code>makeWithdrawal()</code> method to run as one <em>atomic</em> thing</strong>.⚛️</p>
<p>这里需要确保一旦某个线程进入了 <code>makeWithdrawal()</code>方法，就要允许这个线程，在其他线程可以进入这个方法之前，执行完这个方法（We need to make sure that once a thread enters the <code>makeWithdrawal()</code> method, <em>it must be allowed to finish the method</em> before any other thread can enter）。</p>
<p>也就是说，这里需要确保一旦某个线程已检查了账户余额，那么那个线程就会被保证，<em>在其他线程可以检查账户余额之前</em>，此线程能够醒过来并完成支取（In other words, we need to make sure that once a thread has checked the account balance, that thread has a guarantee that it can wake up and finish the withdrawal <em>before any other thread can check the account balance</em>）！</p>
<p>那么就要使用关键字 <code>synchronized</code>，来对方法加以修改，如此在某个时刻，就只有一个线程可以方法这个方法了（Use the <code>synchronized</code> keyword to modify a method so that only one thread at a time can access it）。</p>
<p><img src="images/Ch15_45.png" alt="关键字synchronized" /></p>
<p><em>图 45 - 关键字<code>synchronized</code></em></p>
<p><strong>关键字<code>synchronized</code>表示，线程为了访问这些同步代码，是需要一把钥匙的（The <code>synchronized</code> keyword means that a thread needs a key in order to access the synchronized code）</strong>。</p>
<p><strong>为了对数据（好比这里的银行账户）进行保护，就要将对数据进行操作的那些方法，进行同步化处理</strong>。</p>
<p>这就是对银行账户施加保护的措施！不是把锁安在银行账户本身之上；而是给操作银行账户的事务加上锁。这样的话，某个线程就要去完成整个事务，就算线程执行到方法的一半睡了过去，也要有始有终（That's how you protect the bank account! You don't put a lock on the bank accout itself; you lock the method that does the banking transaction. That way, one thread gets to complete the whole transaction, start to finish, even if that thread falls asleep in the middle of the method）！</p>
<p>那么问题来了，既然没有给银行账户加锁，那到底锁了什么呢？是那个方法吗？还是那个 <code>Runnable</code> 对象？还是线程本身？</p>
<p>接下来会讨论整个问题。从代码上看，这是很简单的 -- 只需将 <code>synchronized</code> 修饰符，加到方法声明即可：</p>
<pre><code class="language-java">private synchronized void makeWithdrawal (int amount) {

    String currentThread = Thread.currentThread().getName();

    System.out.format(&quot;---------\n%s 即将进行支取，支取数额为 %d\n&quot;, 
            currentThread, amount, account.getBalance());

    if (account.getBalance() &gt;= amount){
        try {
            System.out.format(&quot;%s 即将睡过去\n&quot;, currentThread);

            Thread.sleep(500);
        } catch (InterruptedException ex) {ex.printStackTrace();}

        System.out.format(&quot;%s 醒过来了\n&quot;, currentThread);

        account.withdraw(amount);
        System.out.format(&quot;%s 完成了支取，支出数额 %d, 此时账户余额为 %d\n&quot;, 
                currentThread, amount, account.getBalance());
    }
    else {
        System.out.format(&quot;抱歉，%s, 已经余额不足, 余额为：%d\n&quot;, currentThread, account.getBalance());
    }
}
</code></pre>
<p>（致那些精通物理的本书读者朋友：是的，此处使用 “原子” 一词的惯例，并未反应整个亚原子的粒子事物。当在线程及事务语境下讲到“原子”时，就要做牛顿，而不是爱因斯坦。嘿，这可不是 写这本书的人 的约定。真要由“我们”来约定的话，就要用海森堡不确定原理，来描述任何与线程相关的东西了。）</p>
<h3 id="运用对象锁"><a class="header" href="#运用对象锁">运用对象锁</a></h3>
<p><strong>Using an object's lock</strong></p>
<p>每个对象都有一把锁。多数时候，那把锁都是开着的，同时可设想对象旁边始终有那么一把钥匙在那里。这些对象锁，只会在有着同步方法时，才生效。在某个对象有着一个或多个同步方法时，<em>线程就只有在可以获取到这个对象的锁时，才能进入到同步方法</em>（Every object has a lock. Most of the time, the lock is unlocked, and you can imagine a virtual key sitting with it. Object locks come into play only when there are synchronized methods. When an object has one or more sychronized methods, <em>a thread can enter a synchronized method only if the thread can get the key to the object's lock</em>）！</p>
<p>这些锁不是基于每个 <em>方法</em> 的，他们是基于每个 <em>对象</em> 的。在某个对象有两个同步方法时，也不是简单表明不可以让两个线程同时进入同一方法。而是表示不能让两个线程，同时进入这两个同步方法的 <em>任意一个</em> （The locks are not per <em>method</em>, they are per <em>object</em>. If an object has two synchronized methods, it does not simply mean that you can't have two threads entering <em>any</em> of the synchronized methods）。</p>
<p>请设想一下这个情况。在有着多个可以潜在对某个对象的多个实例变量，进行操作的方法时，那么全部这些方法，都需要使用 <code>synchronized</code> 保护起来（Think about it. If you have multiple methods that can potentially act on an object's instance variables, all those methods need to be protected with <code>synchronized</code>）。</p>
<p>同步的目的，是要保护重要数据。但请记住，锁住的并非数据本身，而是将那些要 <em>存取</em> 数据的方法，进行了同步化改造（The goal of synchronization is to protect critical data. But remember, you don't lock the data itself, you synchronize the methods that <em>access</em> that data）。</p>
<p><img src="images/Ch15_46.png" alt="关于对象的锁(object's lock)" /></p>
<p><em>图 46 - 关于对象的锁(object's lock)</em></p>
<blockquote>
<p><strong>每个 Java 对象都有一把锁。一把锁也仅有一把钥匙</strong>。</p>
<p><strong>多数时候，对象锁都是开着的，也没有人在乎他开着</strong>。</p>
<p><strong>而在对象有了一些同步方法时，线程就只有在可以拿到对象锁的钥匙时，才能进入到这些同步方法之一中去执行了</strong>。也就是说，只有在另一方法不再持有那把钥匙的时候。</p>
</blockquote>
<p>那么在某个线程自底往上贯穿其调用栈（从线程作业的那个 <code>run()</code> 方法开始），而突然碰到一个同步化方法时，会发生什么呢？这个时候线程就会意识到，他需要在进入这个同步化方法前，获取那个对象的钥匙。他会查找那把钥匙（这都是由JVM处理的；Java中没有访问对象锁的API），并在钥匙可用时，线程就会抓取到钥匙而进入到那个同步方法。</p>
<p>而在这个时间点之前，线程就会纠结于那把锁，就好像线程的存亡，取决于这个锁一样。在线程执行完毕这个同步方法之前，他是不会放弃这把锁的。进而在此线程持有这把锁期间，就不会由其他线程，能够进入到 <em>任何</em> 该对象的那些同步方法，这是由于那个对象的唯一钥匙，已不再可用（From that point forward, the thread hangs on to that key like the thread's life depends on it. The thread won't give up the key until it completes the synchronized method. So while that thread is holding the key, no other threads can enter <em>any</em> of that object's synchronized methods, because the one key for that object won't be available）。</p>
<h3 id="可怕的更新丢失问题"><a class="header" href="#可怕的更新丢失问题">可怕的“更新丢失”问题</a></h3>
<p><strong>The dreaded &quot;Lost Update&quot; problem</strong></p>
<p>这是另外一个经典的、来自于数据库领域的并发问题。这个问题与Ryan和Monica的故事密切相关，不过这里是要用这个示例，来说明几个其他的要点（Here's another classic concurrency problem, that comes from the database world. It's closely related to the Ryan and Monica story, but we'll use this example to illustrate a few more points）。</p>
<p>这里所说的更新丢失，是围绕这样一个过程展开的：</p>
<ul>
<li>步骤一：获取账户中的余额</li>
</ul>
<pre><code class="language-java">int i = balance;
</code></pre>
<ul>
<li>步骤二：给余额加 1</li>
</ul>
<pre><code class="language-java">// 或许这个不是个原子过程（Probably not an atomic process）
balance = i + 1;
</code></pre>
<p>即使这里是要更为常见的语法：<code>balance++;</code> 同样不能确保编译后的代码，将是一个 “原子化的过程（atomic process）”。事实上，这个过程根本就不会是个原子化的过程（In fact, it probably won't）。</p>
<p>在这个“更新丢失”问题中，有着两个线程，他们都尝试要对余额进行递增操作。请阅读下面的代码，然后就会看到真正的问题所在。</p>
<pre><code class="language-java">package com.xfoss.learningJava;

class TestSync implements Runnable {
    private int balance;

    public void run () {
        String threadName = Thread.currentThread().getName();

        for (int i = 0; i &lt; 10; i++){
            increment();
            System.out.format(&quot;%s 存了一块钱，现在余额为 %d\n&quot;, threadName, balance);
        }
    }

    private void increment () {
        int i = balance;
        balance = i + 1;
    }

    public TestSync () {
        Thread a = new Thread(TestSync.this);
        Thread b = new Thread(TestSync.this);

        a.setName(&quot;Ryan&quot;);
        b.setName(&quot;Monica&quot;);

        a.start();
        b.start();
    }

    public static void main (String[] args) {
        new TestSync();
    }
}
</code></pre>
<p>此程序运行结果：</p>
<pre><code class="language-console">&gt; java -jar .\Pictures\com.xfoss.learningJava-0.0.1.jar
Ryan 存了一块钱，现在余额为 1
Ryan 存了一块钱，现在余额为 3
Ryan 存了一块钱，现在余额为 4
Ryan 存了一块钱，现在余额为 5
Ryan 存了一块钱，现在余额为 6
Monica 存了一块钱，现在余额为 2
Monica 存了一块钱，现在余额为 8
Monica 存了一块钱，现在余额为 9
Monica 存了一块钱，现在余额为 10
Monica 存了一块钱，现在余额为 11
Monica 存了一块钱，现在余额为 12
Monica 存了一块钱，现在余额为 13
Monica 存了一块钱，现在余额为 14
Monica 存了一块钱，现在余额为 15
Monica 存了一块钱，现在余额为 16
Ryan 存了一块钱，现在余额为 7
Ryan 存了一块钱，现在余额为 17
Ryan 存了一块钱，现在余额为 18
Ryan 存了一块钱，现在余额为 19
Ryan 存了一块钱，现在余额为 20
</code></pre>
<p>修改为这样后:</p>
<pre><code class="language-java">package com.xfoss.learningJava;

class TestSync implements Runnable {
    private int balance;

    public void run () {
        String threadName = Thread.currentThread().getName();

        // 每个线程循环10次，每次循环将余额递增
        for (int i = 0; i &lt; 10; i++){
            increment();
            System.out.format(&quot;%s 存了一块钱，现在余额为 %d\n&quot;, threadName, balance);
        }
    }

    private void increment () {
        // 这里是重要的地方！对余额的递增，是通过加 1 到之前读取余额时余额
        // 的值上的（而不是加 1 到当前的那个余额值上）
        //
        // Here's the crucial part! We increment the balance by adding
        // 1 to whatever the value of balance was AT THE TIME WE READ
        // IT (rather than adding 1 to whatever the CURRENT value is)
        int i = balance;
        balance = i + 1;
    }
}

public class TestSyncTest {
    public static void main (String[] args) {
        TestSync job = new TestSync();

        Thread a = new Thread(job);
        Thread b = new Thread(job);

        a.setName(&quot;Ryan&quot;);
        b.setName(&quot;Monica&quot;);

        a.start();
        b.start();
    }
}
</code></pre>
<p>运行结果为：</p>
<pre><code class="language-console">&gt; java -jar .\Pictures\com.xfoss.learningJava-0.0.1.jar
Ryan 存了一块钱，现在余额为 1
Ryan 存了一块钱，现在余额为 3
Ryan 存了一块钱，现在余额为 4
Ryan 存了一块钱，现在余额为 5
Ryan 存了一块钱，现在余额为 6
Ryan 存了一块钱，现在余额为 7
Ryan 存了一块钱，现在余额为 8
Ryan 存了一块钱，现在余额为 9
Ryan 存了一块钱，现在余额为 10
Ryan 存了一块钱，现在余额为 11
Monica 存了一块钱，现在余额为 2
Monica 存了一块钱，现在余额为 12
Monica 存了一块钱，现在余额为 13
Monica 存了一块钱，现在余额为 14
Monica 存了一块钱，现在余额为 15
Monica 存了一块钱，现在余额为 16
Monica 存了一块钱，现在余额为 17
Monica 存了一块钱，现在余额为 18
Monica 存了一块钱，现在余额为 19
Monica 存了一块钱，现在余额为 20
</code></pre>
<blockquote>
<p><strong>注</strong>：实际上，上面两种写法，是不是一样的效果呢？</p>
</blockquote>
<h3 id="下面来运行一下这个程序"><a class="header" href="#下面来运行一下这个程序">下面来运行一下这个程序......</a></h3>
<p><strong>Let's run this code...</strong></p>
<ol>
<li>
<p>线程 A 运行一会儿</p>
<pre><code class="language-pseudocode">将余额值放到变量 i 中；
余额为 0，因此 i 现在就是 0；
将余额的值设置为 i+1 的结果；
现在余额为 1；
将余额的值放到变量 i 中；
余额为 1，因此 i 现在就是 1；
将余额值设置为 i+1 的结果；
现在余额为 2；
</code></pre>
</li>
<li>
<p>线程 B 运行一会儿</p>
<pre><code class="language-pseudocode">将余额值放到变量 i 中；
余额为 2，因此 i 现在就是 2；
将余额的值设置为 i+1 的结果；
现在余额为 3；
将余额的值放到变量 i 中；
余额为 1，因此 i 现在就是 3；

[此时，在线程 B 将余额值设置为 4 之前，就从正在运行
被送回到了可运行状态]
</code></pre>
</li>
<li>
<p>线程 A 再度运行，在他之前离开的地方继续（Thread A runs again, picking up where it left off）</p>
<pre><code class="language-pseudocode">将余额值放到变量 i 中；
余额为 3，因此 i 现在就是 3；
将余额的值设置为 i+1 的结果；
现在余额为 4；
将余额的值放到变量 i 中；
余额为 4，因此 i 现在就是 4；
将余额值设置为 i+1 的结果；
现在余额为 5；
</code></pre>
</li>
<li>
<p>线程 B 再度运行，并精确地在他之前离开的地方继续（Thread B runs again, and pickes up exactly where it left off）!</p>
<pre><code class="language-pseudocode">将余额值设置为 i+1 的结果；
// 哎呀！！
//
// 线程 A 将余额更新为了 5，但现在线程 B 回来继续运行，而
// 践踏了线程 A 所做出的更新，就如同线程 A 的更新从来也
// 没发生过一样。
//
// Thread A updated it to 5, but now B came back and stepped
// on top of the update A made, as if A's update never happened.
现在余额为 4；
</code></pre>
</li>
</ol>
<blockquote>
<p><strong>这里就丢失了线程 A 所做出的那些更新！由于线程 B 先前完成了余额的 “读取”，且在线程 B 醒来后，就只是如同他不曾错过一些事情一样，继续运行着（We lost the last updates that Thread A made! Thread B had previously done a 'read' of the value of balance, and when B woke up, it just kept going as if it never missed a beat）</strong>。</p>
</blockquote>
<h3 id="将方法-increment-构造成原子化使其成为同步方法"><a class="header" href="#将方法-increment-构造成原子化使其成为同步方法">将方法 <code>increment()</code> 构造成原子化。使其成为同步方法！⚛️</a></h3>
<p><strong>Make the <code>increment()</code> method atomic. Synchronize it</strong>!⚛️</p>
<p>同步化 <code>increment()</code> 方法，就解决了 “更新丢失” 问题，这是因为同步化就让该方法中的两个步骤，成为了一个不可分割的单元了（Synchronizing the <code>increment()</code> method solves the &quot;Lost Update&quot; problem, because it keeps the two steps in the method as one unbreakable unit）。</p>
<pre><code class="language-java">private synchronized void increment () {
    balance++;
}
</code></pre>
<blockquote>
<p><strong>一旦线程进入到这个方法，就必须确保在其他线程可以进入这个方法之前，其中所有步骤执行完毕（作为一个原子过程）</strong>。</p>
</blockquote>
<h2 id="答疑-20"><a class="header" href="#答疑-20">答疑</a></h2>
<ul>
<li><strong>听起来把万物都同步化是个不错的注意，因为这样就可以实现线程安全了（Sounds like it's a good idea to synchronize everything, just to be thread-safe）。</strong></li>
</ul>
<blockquote>
<p>不是这样的，这不是个好主意。同步化并非没有代价。首先，同步方法是有确切开销的。也就是说，在代码遇到同步方法时，就会存在性能问题（虽然通常不会注意到这样的性能问题），这是由于解决 “对象锁的钥匙是否可用” 的这个问题需要时间（Nope, it's not a good idea. Synchronization doesn't come for free. First, a synchronized method has a certain amount of overhead. In other words, when code hit a synchronized method, there's going to be a performance hit(although typically, you'd never notice it) while the matter of &quot;is the key available?&quot; is resolved）。</p>
<p>其次，由于同步化操作对并发有限制，因此同步方法会减慢程序运行速度。换句话说，同步方法会强制其他线程排队等待他们的运行轮次。这可能在你编写的代码中不成其为问题，但必须考虑到这个问题（Second, a synchronzied method can slow your program down because synchronization restricts concurrency. In other words, a synchronzied method forces other threads to get in line and wait their turn. This might not be a problem in your code, but you have to consider it）。</p>
<p>第三，也是最可怕的，就是同步方法会导致死锁！（请参阅后面的部分，Third, and most frightening, synchronized methods can lead to deadlock）!</p>
<p>有一条良好的经验法则，就是仅做最低限度、对那些确实应该进行同步的方法进行同步化。并且事实上，可以在较方法更小的级别的粒度上，进行同步化操作。虽然在本书中没有用到，但仍然可以使用 <code>synchronize</code> 关键字，在一个或多个语句级别，而不是整个方法层面，进行更细粒度的同步化操作（A good rule of thumb is to synchronize only the bare minimum that should be synchronized. And in fact, you can synchronize at a granularity that's even smaller than a method. We don't use it in the book, but you can use the <code>synchronized</code> keyword to synchronize at the more fine-grained level of one or more statements, rather than at the whole-method level）。</p>
</blockquote>
<pre><code class="language-java">// go() 方法中的 doStuff() 不需要被同步化，因此这里就
// 没有将整个的 go() 方法同步化。
//
// doStuff() doesn't need to be synchronized, so we don't
// synchronize the whole method.
public void go () {
    doStuff();

    // 此时，就只有这其中的两个方法调用被编为一个原子化
    // 单元了。当在某个方法中使用 synchronized 关键字，而
    // 不是在方法声明中使用整个关键字时，就必须给提供一个
    // 参数，这个参数即为线程需要获得对象锁钥匙所对应的对象。
    //
    // Now, only these two method calls are grouped into
    // one atomic unit. When you use the synchronized keyword
    // WITHIN a method, rather than in a method declaration, you
    // have to provide an argument that is the object whose key
    // the thread needs to get.
    //
    // 尽管也有其他实现方式，但几乎总是会在当前对象（this）上
    // 进行同步化。那正是在整个方法被同步时，所要锁上的同一个
    // 对象。
    //
    // Although there are other ways to do it, you will almost
    // always synchronize on the current object(this). That's the
    // same object you'd lock if the whole method were synchronized.
    synchronized (this) {
        criticalStuff();
        moreCriticalStuff();
    }
}
</code></pre>
<ol>
<li>
<p><strong>线程 A 运行一会儿</strong></p>
<pre><code class="language-pseudocode">尝试进入这个 increment() 方法；

这个方法是同步的，因此就要 获取到此对象锁的钥匙
把余额的取值，放入变量 i 中；
余额是 0，因此 i 现在就是 0；
将余额的至，设置为 i+1 的运算结果；
现在余额就是 1；
交回这把钥匙（由于线程A已经完成了 increment() 方法的执行）；
再次进入 increment() 方法并获取到钥匙；
将余额的值放入变量 i 中；
余额为 1，因此 i 现在就是 1；

[现在线程 A 被送回到可运行状态，不过由于他尚未完成这个同步方法的
执行，因此线程 A 仍然拿着那把钥匙]
</code></pre>
</li>
<li>
<p><strong>线程 B 被（线程调度器）选中去运行</strong></p>
<pre><code class="language-psedudocode">尝试进入这个 increment() 方法。该方法是同步的，因此这里就需要获取到锁的钥匙；

钥匙不可用。

[现在线程 B 被送进一个 ‘对象锁不可用’ 类似休息室的
地方（now thread B is sent into a 'object lock not available' lounge）]
</code></pre>
</li>
<li>
<p><strong>线程 A 再度运行，从他上次离开的地方继续运行（请记住，他仍然持有那把对象锁的钥匙）</strong></p>
<p><strong>Thread A runs again, picking up where it left off(remember, it still has the key)</strong></p>
<pre><code class="language-pseudocode">将余额的值设置为 i+1 的运算结果；
现在余额为 2；

线程 A 退回对象锁的钥匙；

[现在线程 A 被送回到可运行状态，但由于他已经完成了这个 increment()
方法的运行，这个线程就不再持有那把对象锁了]
</code></pre>
</li>
<li>
<p><strong>线程 B 被（线程调度器）选中去运行</strong></p>
<pre><code class="language-pseudocode">线程 B 尝试进入这个 increment() 方法。该方法是同步的，因此这里
就需要获取到对象锁的钥匙；

这次这把钥匙是可用的，那么就获取到该钥匙了；

将余额的值放入到变量 i 中；

[继续运行......]
</code></pre>
</li>
</ol>
<h3 id="同步化的致命一面"><a class="header" href="#同步化的致命一面">同步化的致命一面</a></h3>
<p><strong>The deadly side of synchronization</strong></p>
<p>在运用同步代码时要谨慎，这是因为没有什么东西会像线程死锁那样，将程序拖入到动弹不得的地步。在有着同时持有对方所需对象锁钥匙的两个进程时候，就会发生线程死锁。这种情形无可救药，没有解决办法，因此这两个线程就只有坐在那里静静等待。再等待。再等待（Be careful when you use synchronized code, because nothing will bring your program to its knees like thread deadlock. Thread deadlock happens when you have two threads, both of which are holding a key the other thread wants. There's no way out of this scenario, so the two threads will simply sit and wait. And wait. And wait）。</p>
<p>若熟悉数据库或其他一些应用服务器，那么就会明白这个问题；数据库通常有着类似同步化这样的机制。不过一种真正的事务管理系统，一些时候是可以解决死锁问题的。这样的系统会作出假设，比如在两个事务耗费过长时间完成时，就相当于发生了死锁。然而与Java不同，应用服务器是可以执行一次 “事务回滚”，从而将被回滚事务的状态，退回到这个事务（所谓事务，即是指那个原子部分）开始之前（If you're familiar with databases or other application servers, you might recognize the problem; databases often have a locking mechanism somewhat like synchronizaion. But a real transaction management system can sometimes deal with deadlock. It might assume, for example, that deadlock might have occured when two transactions are taking too long to complete. But unlike Java, the application server can do a &quot;transaction rollback&quot; that returns the state of the rolled-back transaction to where it was before the transaction(the atomic part) began）。</p>
<p>Java 不具备处理死锁的机制。他甚至不会 <em>获悉到</em> 死锁的发生。那么就要依赖程序员来精心设计。在发现正写着为数不少的多线程代码时，那么大概就要去研修一下 Scott Oaks 和 Henry Wong 合著的 《Java 线程》（&quot;Java Threads&quot;）一书，以掌握避开死锁的一些设计技巧。这些技巧中最常见的一个，就是要留意涉及到的那些线程启动顺序（Java has no mechanism to handle deadlock. It won't even <em>know</em> deadlock occured. So it's up to you to design carefully. If you find yourself writing much multithreaded code, you might want to study &quot;Java Threads&quot; by Scott Oaks and Henry Wong for design tips on avoiding deadlock. One of the most common tips is to pay attention to the order in which your threads are started）。</p>
<blockquote>
<p><strong>死锁发生的必要条件即是，存在两个对象与两个线程</strong>。</p>
<p><strong>All it takes for deadlock are two objects and two threads</strong>.</p>
</blockquote>
<p><strong>一个简单的死锁场景</strong>：</p>
<ol>
<li>
<p>线程 A 进入到对象 <code>foo</code> 的某个同步方法，同时获取到了该对象锁的钥匙；</p>
<p>然后线程 A 拿着 <code>foo</code> 对象锁的钥匙睡了过去。</p>
</li>
<li>
<p>线程 B 进入到对象 <code>bar</code> 的某个同步方法，同时获取到该 <code>bar</code> 对象锁的钥匙；</p>
<p>线程 <code>B</code> 尝试进入 <code>foo</code> 对象的某个同步方法，然而线程 B 无法获取到那把钥匙（由于线程 A 持有着）。这时线程 B 就会去到等待室，知道那把 <code>foo</code> 的钥匙可用。这时 <code>bar</code> 的钥匙是由线程 B 保留着的。</p>
</li>
<li>
<p>线程 A 醒了过来（仍就持有着 <code>foo</code> 的钥匙），并尝试进入到对象 <code>bar</code> 的某个同步方法，然而线程 A 没法获取到那把钥匙，这时因为线程 B 持有着那把钥匙。这个时候线程 A 就会进入等待室，直到 <code>bar</code> 的钥匙可用（不过这钥匙将永远不会可用！）</p>
<p>线程 A 在获取到 <code>bar</code> 的钥匙之前无法运行，然而这个时候<code>bar</code>的钥匙是在线程 B 手里，同时线程 B 又由于线程 A 持有着 <code>foo</code> 的钥匙也无法运行......</p>
</li>
</ol>
<h2 id="重点-6"><a class="header" href="#重点-6">重点</a></h2>
<ul>
<li>静态方法 <code>Thread.sleep()</code> 会强制线程，在传递给这个 <code>sleep</code> 方法的参数时长之内，离开运行状态。比如<code>Thread.sleep(200)</code>会将线程置于睡眠状态 200 毫秒；</li>
<li><code>sleep()</code>方法会抛出一个受检查的异常（<code>InterruptedException</code>），因此所以对 <code>sleep()</code>方法的调用，都必须封装在 <code>try/catch</code>代码块中，或是被声明出来；</li>
<li>尽管不能保证某个线程在醒来时可以到达可运行行程队列的末尾，但为了有助于确保全部线程都有机会运行，仍就可使用 <code>sleep()</code> 方法。醒来的线程，依然可能会回到可运行队列的前端。在多数情况下，为保持手头的线程良好切换，只需编写一些时间设置恰当的 <code>sleep()</code> 方法即可（You can use <code>sleep()</code> to help make sure all threads get a chance to run, although there's no guarantee that when a thread wakes up it'll go to the end of the runnable line. It might, for example, go right back to the front. In most cases, approciately-timed <code>sleep()</code> calls are all you need to keep your threads switching nicely）；</li>
<li>使用 <code>setName()</code> 方法（是的，又一个惊喜），就可以给某个线程取名字。虽然所有线程都有默认名字，不过给他们一个显式的名字，可以有助于对这些线程加以追踪，尤其是在使用 <code>print</code> 语句进行程序调试的时候；</li>
<li>在运用线程时，而又存在两个或多个线程都对内存堆上的某个对象进行访问时，就会遇到严重问题；</li>
<li>在两个或多个线程同时访问同一对象时，若一个线程在仍处于对某个对象的重要状态进行操作的过程中，就离开了他的正在运行状态，这样就会导致数据损坏（Two or more threads accessing the same object can lead to data corruption if one thread, for example, leaves the running state while still in the middle of manipulating an object's critical state）；</li>
<li>要让对象成为线程安全，就要找出哪些语句应作为原子过程加以对待。也就是说，要找出（线程中的）哪些方法，必须在其他线程进入到这些同一对象上的相同方法之前，就要运行完毕（To make your objects thread-safe, decide which statements should be treated as one atomic process. In other words, decide which methods must run to completion before another thread enters the same method on the same object）；</li>
<li>在要防止有两个线程进入到某个方法时，就要使用关键字 <code>synchronized</code> 来修正这个方法的声明；</li>
<li>每个对象都有唯一一把锁，那把锁的钥匙也只有一把。多数时候不需关心那把锁；只有在对象有着同步方法时，那把锁才会生效；</li>
<li>在线程尝试进入某个同步方法时，该线程必须获取到其所操作对象（线程的方法将尝试操作的对象）的钥匙。在钥匙不可用时（由于另一线程已持有该钥匙），那么线程就会进入到类似等待室的某个地方，直到那把钥匙可用为止；</li>
<li>即使某个对象有着多个同步方法，他仍然只有一把钥匙。一旦有线程进入到那个对象的某个同步方法，就不会有其他线程可以进入到这个对象的其他任何同步方法。这样的限制，实现了通过将那些对该对象数据进行操作的方法，进行同步化而对数据进行保护的目的（Even if an object has more than one synchronized method, there is still only one key. Once any thread has entered a synchronized method on that object, no thread can enter any other synchronized method on the sam object. This restriction lets you protect your data by synchronizing any method that manipulates the data）。</li>
</ul>
<h2 id="新的改进过的-simplechatclient"><a class="header" href="#新的改进过的-simplechatclient">新的改进过的 <code>SimpleChatClient</code></a></h2>
<p>回到本章刚开始的时候，那里构建了可将外送消息发送到服务器，但无法收到任何东西的 <code>SimpleChatClient</code>。还记得吗？由于在那里需要一次干两件事的方法：在将消息发送给服务器（用户与GUI进行交互）的同时，要从服务器读取传入的消息，进而将这些传入消息显式在那个滚动文本区；因此那正是首次涉及到这整个线程问题的地方。</p>
<blockquote>
<p>是的，本章确实有这么一个结尾。然而现在还不是......</p>
<p>Yes, there really IS an end to this chapter. But not yet...</p>
</blockquote>
<pre><code class="language-java">package com.xfoss.SimpleChat;

import java.io.*;
import java.net.*;
import java.util.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SimpleChatClient extends JFrame {
    JTextArea incoming;
    JTextField outgoing;
    BufferedReader reader;
    PrintWriter writer;
    Socket sock;

    public static void main (String[] args) {
        new SimpleChatClient(&quot;简单的聊天客户端&quot;);
    }

    // 这里是 SimpleChatClient 的构造函数，是些已经见到过的 GUI
    // 代码。只是其中增加了两句构造新的 readerThread 并启动这个
    // 线程的语句。
    //
    // This is mostly GUI code you've seen before. Nothing special
    // except the highlighted part where we start the new 'reader'
    // thread.
    public SimpleChatClient (String winTitle) {
        super(winTitle);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JPanel mainPanel = new JPanel();

        incoming = new JTextArea(15, 50);
        incoming.setLineWrap(true);
        incoming.setWrapStyleWord(true);
        incoming.setEditable(false);

        JScrollPane qScroller = new JScrollPane(incoming);
        qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        outgoing = new JTextField(20);

        JButton sendBtn = new JButton(&quot;发送&quot;);
        sendBtn.addActionListener(new SendBtnListener());

        mainPanel.add(qScroller);
        mainPanel.add(outgoing);
        mainPanel.add(sendBtn);

        setUpNetworking();

        // 这里使用一个新的内部类，作为新线程的 Runnable(作业)，启动
        // 了一个新线程。该线程的作业，是从服务器的套接字流进行读取，之后
        // 在滚动文本区显示出全部传入消息。
        //
        // We're starting a new thread, using a new inner class as the 
        // Runnable(job) for the thread. The thread's job is to read 
        // from the server's socket stream, displaying any incoming
        // messages in the scrolling text area.
        Thread readerThread = new Thread(new IncomingReader());
        readerThread.start();

        getContentPane().add(BorderLayout.CENTER, mainPanel);
        setSize(800, 600);
        setVisible(true);
    }

    class SendBtnListener implements ActionListener {
        // 这里没有什么新东西。在用户点击了发送按钮时，这个方法就会
        // 把文本字段的内容，发送到服务器。
        //
        // Nothing new here. When the user clicks the send button, this
        // method sends the contents of the text field to the server.
        public void actionPerformed(ActionEvent ev){
            try {
                writer.println(outgoing.getText());
                writer.flush();
            } catch (Exception ex){ ex.printStackTrace(); }

            outgoing.setText(&quot;&quot;);
            outgoing.requestFocus();
        }
    }

    // 这就是新线程完成的那些操作！！
    //
    // 在这个 run() 方法中，操作位处一个循环里（只要从服务器获取到的东西不是
    // null），一次读取一行文本，并将读取到的各行，添加到那个滚动文本区（再
    // 加上一个新行字符）。
    //
    // This is what the thread does!!
    //
    // In the run() method, it stays in a loop(as long as what it gets from
    // the server is not null), reading a line at a time and adding each line
    // to the scrolling text area(along with a new line characer).
    class IncomingReader implements Runnable {
        public void run () {
            String msg;

            try{
                while ((msg = reader.readLine()) != null) {
                    System.out.format(&quot;读取到消息 %s\n&quot;, msg);
                    incoming.append(String.format(&quot;%s \n&quot;, msg));
                }
            } catch (Exception ex){ex.printStackTrace();}
        }
    }

    public void setUpNetworking () {
        // 这里使用套接字，还获取到输入与输出流. 这个输出流在之前就已被用于往服务器
        // 发送消息了，但现在这里要使用输入流，这样新的 ‘reader’ 线程，才能从服务器
        // 获取到消息。
        //
        // We're using the socket to get the input and output streams. We were already
        // using the output stream to send to the server, but now we're using the input
        // stream so that the new 'reader' thread can get messages from the server.
        try {
            sock = new Socket(&quot;192.168.153.134&quot;, 15000);

            InputStreamReader streamReader = new InputStreamReader(sock.getInputStream(), &quot;UTF-8&quot;);
            reader = new BufferedReader (streamReader);

            writer = new PrintWriter(new OutputStreamWriter(sock.getOutputStream(), &quot;UTF-8&quot;));

            System.out.println(&quot;网络通信已建立&quot;);
        } catch (IOException ex){ex.printStackTrace();}
    }
}
</code></pre>
<h3 id="那个相当相当简单的聊天服务器"><a class="header" href="#那个相当相当简单的聊天服务器">那个相当相当简单的聊天服务器</a></h3>
<p><strong>The really really simple Chat Server</strong></p>
<p>对于之前两个版本的 <code>ChatClient</code>，都可以使用下面这个服务器代码。所宣称过的全部服务器应答，在这里都是有效的。为了将代码裁剪到最基本的功能，这里拿掉了很多令其成一个真正服务器的部分。也就是说，虽然这个服务器可以运行，但至少有上千种方式可以破坏掉他。若在结束本教程后想要一个真正良好的服务器程序，那么请回到这里进行修改，让这个服务器代码更为鲁棒（You can use this server code for both versions of the <code>ChatClient</code>. Every possible disclainer ever disclaimed is in effect here. To keep the code stripped down to the bare essentials, we took out a lot of parts that you'd need to make this a real server. In other words, it works, but there are at least a hundred ways to break it. If you want a Really Good Sharpen Your Pencil for after you've finished this book, come back and make this server code more robust）。</p>
<p>而另一个可能的动手机会，且是一个现在就可以进行的，就是自己来注释这个服务器代码。这样在由自己搞清楚发生了什么的情况下，与由编者来解释相比，可以更好地掌握。还有就是，这是已经编写好的代码，因此真的没有必要掌握他的全部。这个服务器代码只是为了支持上面讲到的两个版本的<code>ChatClient</code>而已。</p>
<blockquote>
<p><strong>要运行 <code>ChatClient</code> 程序，就需要两个终端。首先在一个终端中启动这个服务器，随后在另一终端中启动客户端</strong>。</p>
</blockquote>
<pre><code class="language-java">package com.xfoss.SimpleChat;

import java.io.*;
import java.net.*;
import java.util.*;

public class VerySimpleChatServer {
    ArrayList clientOutputStreams;

    public VerySimpleChatServer () {
        clientOutputStreams = new ArrayList();

        try {
            ServerSocket serverSock = new ServerSocket(15000);

            System.out.println(&quot;聊天服务器已建立&quot;);
            while(true) {
                Socket clientSocket = serverSock.accept();
                PrintWriter writer = new PrintWriter(new OutputStreamWriter(clientSocket.getOutputStream(), &quot;UTF-8&quot;));
                clientOutputStreams.add(writer);

                Thread t = new Thread(new ClientHandler(clientSocket));
                t.start();
                System.out.println(&quot;已获取到一个连接&quot;);
            }
        } catch (Exception ex) {ex.printStackTrace();}
    }

    public class ClientHandler implements Runnable {
        BufferedReader reader;
        Socket sock;

        public ClientHandler (Socket clientSocket) {
            try {
                sock = clientSocket;
                InputStreamReader isReader = new InputStreamReader(sock.getInputStream(), &quot;UTF-8&quot;);
                reader = new BufferedReader(isReader);
            } catch (Exception ex) {ex.printStackTrace();}
        }

        public void run () {
            String message;
            try {
                while ((message = reader.readLine()) != null) {
                    System.out.format(&quot;读取到：%s\n&quot;, message);
                    tellEveryOne(message);
                }
            } catch (Exception ex) {ex.printStackTrace();}
        }
    }
    
    public void tellEveryOne(String message) {
        Iterator it = clientOutputStreams.iterator();

        while(it.hasNext()) {
            try {
                PrintWriter writer = (PrintWriter) it.next();
                writer.println(message);
                writer.flush();
            } catch (Exception ex) {ex.printStackTrace();}
        }
    }

    public static void main(String[] args) {
        new VerySimpleChatServer();
    }
}
</code></pre>
<h2 id="答疑同步的问题"><a class="header" href="#答疑同步的问题">答疑（同步的问题）</a></h2>
<ul>
<li><strong>对于静态变量状态的保护，又是怎样的呢？在有着修改静态变量状态的静态方法时，还仍然可以使用同步化吗（What about protecting static variable state？If you have static methods that chagne the static variable state, can still use synchronization）</strong>？</li>
</ul>
<blockquote>
<p>是的！请记住那些静态方法，是对类运行而非对该类运行的。那么就会想要知道，到底哪些对象的锁，将用在静态方法上呢？毕竟，可能还不曾有那个类的一个实例存在。而幸运的是，就如同每个 <em>类</em> 都有其自己的锁一样，每个已加载的 <em>类</em>，也有着一把锁。那就意味着，在内存堆上存在三个 <code>Dog</code> 对象时，就会有总共四把 <code>Dog</code>相关的锁。其中三把属于这个三个<code>Dog</code>实例，同时有一把属于<code>Dog</code>类本身。在对某个静态方法进行同步化时，Java就会使用类本身的那把锁。因此在对某个类的两个静态方法进行同步化时，线程就需要类的锁，来进入这两个方法（Yes! Remember that static methods run against the class and not against an individual instance of the class. So you might wonder whose object's lock would be used on a static method? After all, there might not even <em>be</em> any instances of that class. Fortunately, just as each <em>object</em> has its own lock, each loaded <em>class</em> has a lock. That means that if you have three <code>Dog</code> objects on your heap, you have a total of four <code>Dog</code>-related locks. Three belonging to the three <code>Dog</code> instances, and one belonging to the <code>Dog</code> class itself. When you synchronize a static method, Java uses the lock of the class itself. So if you synchronize two static methods in a single class, a thread will need the class lock to enter <em>either</em> of the methods）。</p>
</blockquote>
<ul>
<li><strong>那什么是线程优先级呢？我曾听说那是一种可以对调度施加控制的方式（What are thread priorities? I've heard that's a way you can control scheduling）</strong>。</li>
</ul>
<blockquote>
<p>线程优先级 <em>可能</em> 有助于对调度器施加影响，但他们仍就不会提供到任何的保证。线程优先级是开发者就某个线程的重要性，而向调度器进行通知（也仅是在调度器确实有线程优先级实现的情况下）的一些数字。大体上，在某个具有较高优先级的线程，突然变成可运行状态时，调度器会将较低优先级的线程踢出正在运行状态。然而......再次声明，“并无保证”。建议只有在打算对 <em>性能</em> 施加影响时，才使用优先级的设置，但绝不要依赖线程优先级去保证程序正确（Thread priorities <em>might</em> help you influence the schedular, but they still don't offer any guarantee. Thread priorities are numerical values that tell the scheduler（if it cares） how important a thread is to you. In general, the scheduler will kick a lower priority thread out of the running state if a higher priority thread suddenly becomes runnable. But...one more time, say it with me now, &quot;there is no guarantee.&quot; We recommend that you use priorities only if you want to influence <em>performance</em>, but never, ever rely on them for program correctness）。</p>
</blockquote>
<ul>
<li><strong>为何不是仅仅将要对数据加以保护的类中所有读取器与设置器进行同步化呢？比如对于类 <code>BankAccount</code>，为何不可以只同步 <code>checkBalance()</code> 和 <code>withdraw()</code>，而是同步了 <code>Runnable</code> 类的 <code>makeWithdrawal()</code> 方法呢（Why don't you just synchronize all the getters and setters from the class with the data you're trying to protect? Like, why couldn't we have synchronized just the <code>checkBalance()</code> and <code>withdraw()</code> methods from class <code>BankAccount</code>, instead of synchronizing the <code>makeWithdrawal()</code> method from the <code>Runnable</code>s class）</strong>？</li>
</ul>
<blockquote>
<p>事实上，这里就 <em>应该</em> 把这些方法同步化，以阻止其他线程以别的方式来访问这些方法。由于这里的示例并没有其他代码会读写到银行账户，因此就没有那样做（Actually, we <em>should</em> have synchronized those methods, to prevent other threads from accessing those methods in other ways. We didn't bother, because our example didn't have any other code accessing the account）。</p>
<p>不过需要补充的是，对读取器与设置器（或者说这个示例中的 <code>checkBalance()</code> 与 <code>withdraw()</code>）的同步化，是不充分的。请记住，同步化的点位，是要令到某个特定代码部分以 <strong>原子方式</strong> 工作。也就是说，同步化不光是所要关注的一些单个方法，而是那些要求 <strong>多个步骤去完成</strong> 的方法！请稍加思考。假如这里没有将 <code>makeWithdrawl()</code>方法同步化，Ryan 就会检查完账户余额（通过调用同步化的 <code>checkBalance()</code> 方法），然后立即退出该方法并交回那把钥匙（But synchronizing the getters and setters(or in this case the <code>checkBalance()</code> and <code>withdraw()</code>) isn't enough. Remember, the point of sysnchronization is to make a specific section of code work ATOMICALLY. In other words, it's not just the individual methods we care about, it's methods that requires <em><strong>more than one step to complete</strong></em>! Think about it. If we had not synchronized the <code>makeWithdrawal()</code> method, Ryan would have checked the balance(by calling the synchronized <code>checkBalance()</code>), and then immediately exited the method and returned the key）！</p>
<p>当然他就在他醒来后，再度取得那把钥匙，这样他就可以调用那个同步的 <code>withdraw()</code>方法，然而这样做仍留下了在同步化之前曾遇到过的同样问题！Ryan能够检查余额、睡过去，然后 Monica 就可以进入并在 Ryan 有机会醒来且完成他的提取之前，对余额进行检查（Of course he would grad the key again, after he wakes up, so that he can call the synchronized <code>withdraw()</code> method, but this still leaves us with the same problem we had before synchronization! Ryan can check the balance, go to sleep, and Monica can come in and also check the balance before Ryan has a chance to wakes up and completes his withdrawal）。</p>
<p>因此将全部存取方法进行同步化，从而阻止其他线程介入，可能是个不错的主意，但仍需把那些具有必须以一个原子单元方式执行语句的方法，加以同步化（So synchronizing all the access methods is probably a good idea, to prevent other threads from getting in, but you still need to synchronizing the methods that have statements that must execute as one atomic unit）。</p>
</blockquote>
<h2 id="代码厨房code-kitchen"><a class="header" href="#代码厨房code-kitchen">代码厨房（Code Kitchen）</a></h2>
<p><strong>这是最后一版的 <code>BeatBox</code>了</strong>！</p>
<p><strong>他将连接到一个简单的 <code>MusicServer</code>，从而就能与其他 <code>BeatBox</code>客户端，相互发送和接收节拍编排</strong>。</p>
<p><strong>代码是相当长的，因此完整代码清单实际上是在附录A里头</strong>。</p>
<h3 id="最终的-beatbox客户端程序"><a class="header" href="#最终的-beatbox客户端程序">最终的 <code>BeatBox</code>客户端程序</a></h3>
<p>此代码的绝大部分，与先前几章的代码厨房的代码是一样的，因此就不再全部注释了。新的几个部分包括：</p>
<ul>
<li>
<p>图形用户界面GUI -- 增加了显示传入消息（实际上是个滚动清单）文本区组件和一个文本字段组件；</p>
</li>
<li>
<p>网络通信NETWORKING -- 与本章中的 <code>SimpleChatClient</code> 一样，<code>BeatBox</code>现在会连接到服务器，并获取到一个输入与输出流；</p>
</li>
<li>
<p>线程THREADS -- 又一次与 <code>SimpleChatClient</code>类似，这里启动了一个 <code>reader</code> 类来保持对来自服务器的传入消息的找寻。不过这里的传入消息不光是文本，而是包含了 <strong>两个</strong> 对象：<code>String</code>的消息和序列化的<code>ArrayList</code>（the serialized <code>ArrayList</code>即保存所有勾选框状态的那个东西。）</p>
</li>
</ul>
<pre><code class="language-java">package com.xfoss.BeatBox;

import java.awt.*;
import javax.swing.*;
import java.io.*;
import javax.sound.midi.*;
import java.util.*;
import java.awt.event.*;
import java.net.*;
import javax.swing.event.*;
import com.xfoss.Utils.XPlatformThings;

public class BeatBoxFinal extends JFrame{
    JPanel mainPanel;
    JList incomingList;
    JTextField userMessageBox;
    ArrayList&lt;JCheckBox&gt; checkboxList;
    int nextNum;
    Vector&lt;String&gt; listVector = new Vector&lt;String&gt;();
    String userName;
    ObjectOutputStream out;
    ObjectInputStream in;
    HashMap&lt;String, boolean[]&gt; otherSeqsMap = new HashMap&lt;String, boolean[]&gt;();

    Sequencer s;
    Sequence seq;
    Sequence mySeq = null;
    Track t;
    JLabel tempoLabel = null;

    String [] instrumentNames = {
        &quot;贝斯鼓（低音鼓）&quot;, 
        &quot;闭镲（闭合击镲）&quot;,
        &quot;空心钹（开音踩钹）&quot;, 
        &quot;小鼓（军鼓）&quot;, 
        &quot;双面钹（强音钹）&quot;, 
        &quot;拍手（拍掌声）&quot;,
        &quot;高音鼓（高音桶鼓）&quot;, 
        &quot;高音圆鼓（高音小鼓）&quot;, 
        &quot;沙锤（沙铃）&quot;, 
        &quot;口哨&quot;, 
        &quot;低音手鼓&quot;,
        &quot;牛铃（牛颈铃）&quot;, 
        &quot;颤音叉&quot;, 
        &quot;中低音桶鼓&quot;, 
        &quot;高音撞铃&quot;,
        &quot;开音高音手鼓&quot;};

    int [] instruments = {35, 42, 46, 38, 49, 39, 50, 60, 70, 72, 64, 56, 58, 47, 67, 63};

    public static void main (String[] args) {
        // args[0] 即是用户 ID/显示名字
        //
        // 这里增加了一个作为显示名字的命令行参数。
        // 比如：%java -jar build/libs/com.xfoss.learningJava.0.0.1.jar theFlash
        new BeatBoxFinal(args[0]);
    }

    public BeatBoxFinal (String name) {
        super(&quot;赛博 BeatBox&quot;);

        userName = name;
        // 没什么新的东西......设置网络通信、I/O及构造（并启动）
        // 那个 reader 线程。
        try {
            Socket sock = new Socket(&quot;127.0.0.1&quot;, 14242);
            out = new ObjectOutputStream(sock.getOutputStream());
            in = new ObjectInputStream(sock.getInputStream());
            Thread remote = new Thread(new RemoteReader());
            remote.start();
        } catch (Exception ex) {
            System.out.println(&quot;无法连接 -- 你只能自己一个人玩了。&quot;);
            ex.printStackTrace();
        }

        setUpMidi();

        // 下面这些是 GUI 代码，没什么新东西
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        URL icoURI = getClass().getResource(&quot;/images/ico.png&quot;);
        ImageIcon ico = new ImageIcon(icoURI);
        setIconImage(ico.getImage());

        BorderLayout l = new BorderLayout();
        JPanel bg = new JPanel(l);
        bg.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        checkboxList = new ArrayList&lt;JCheckBox&gt; ();

        Box btnBox = new Box(BoxLayout.Y_AXIS);

        JButton btnS = new JButton(&quot;开始▶&quot;);
        btnS.addActionListener(new StartListener());
        btnBox.add(btnS);

        JButton btnStop = new JButton(&quot;停止◾&quot;);
        btnStop.addActionListener(new StopListener());
        btnBox.add(btnStop);

        JButton btnReset = new JButton(&quot;重置🔄&quot;);
        btnReset.addActionListener(new ResetListener());
        btnBox.add(btnReset);

        JButton btnSerializeIt = new JButton(&quot;保存（序列化）💾&quot;);
        btnSerializeIt.addActionListener(new SavePatternListener());
        btnBox.add(btnSerializeIt);

        JButton btnRestore = new JButton(&quot;恢复🔙&quot;);
        btnRestore.addActionListener(new ReadInPatternListener());
        btnBox.add(btnRestore);

        btnBox.add(Box.createHorizontalStrut(1));
        btnBox.add(new JSeparator(SwingConstants.HORIZONTAL));

        JButton btnUpTempo = new JButton(&quot;加速&gt;&gt;&quot;);
        btnUpTempo.addActionListener(new UpTempoListener());
        btnBox.add(btnUpTempo);

        JButton btnDownTempo = new JButton(&quot;减慢&lt;&lt;&quot;);
        btnDownTempo.addActionListener(new DownTempoListener());
        btnBox.add(btnDownTempo);

        tempoLabel = new JLabel(String.format(&quot;速度因子：%.2f&quot;, 1.00f)); 
        btnBox.add(tempoLabel);

        JButton sendItBtn = new JButton(&quot;发出🚀&quot;);
        sendItBtn.addActionListener(new SendListener());
        btnBox.add(sendItBtn);

        userMessageBox = new JTextField();
        btnBox.add(userMessageBox);

        // JList 是个之前不曾使用过的GUI部件。这正是传入消息得以显示
        // 的地方。与一般聊天那种只是查看传入消息所不同，在这个app中
        // 是可以从传入消息清单中选择一条消息，来加载并演奏出所附带
        // 的节拍编排。
        incomingList = new JList();
        incomingList.addListSelectionListener(new IncomingListSelectionListener());
        incomingList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

        JScrollPane theList = new JScrollPane(incomingList);
        btnBox.add(theList);

        incomingList.setListData(listVector);

        // 这以后就没什么新东西了。
        Box nameBox = new Box(BoxLayout.Y_AXIS);
        for (int i = 0; i &lt; 16; i++) {
            nameBox.add(new Label(instrumentNames[i]));
        }

        bg.add(BorderLayout.EAST, btnBox);
        bg.add(BorderLayout.WEST, nameBox);

        getContentPane().add(bg);

        GridLayout g = new GridLayout(16, 16);
        g.setVgap(1);
        g.setHgap(2);

        mainPanel = new JPanel(g);
        bg.add(BorderLayout.CENTER, mainPanel);

        for (int i = 0; i &lt; 256; i++) {
            JCheckBox c = new JCheckBox();
            c.setSelected(false);
            checkboxList.add(c);
            mainPanel.add(c);
        }

        setBounds(50, 50, 640, 480);
        pack();
        setVisible(true);
    }

    // 这就是那个线程作业 -- 从服务器读入数据。在该代码中，“数据”
    // 将始终是两个序列化的对象：字符串的消息以及节拍编排（一个那些
    // 勾选框状态值的 ArrayList）
    //
    // 在消息传入进来时，这里就会读取（解序列化）那两个对象（消息与
    // 那些布尔值的勾选框状态的 ArrayList 对象），并把他添加到那个 JList
    // 组件。添加到 JList 是通过两步完成的：设置了一个该清单数据的矢量值（
    // Vector, 矢量类型就是一种老式的 ArrayList），并在随后告诉那个 JList 去
    // 使用那个矢量值，作为在那个清单中显式内容的源。
    //
    // When a message comes in, we read(deserialize) the two objects(the
    // message and the ArrayList of Boolean checkbox state values) and 
    // add it to the JList component. Adding to a JList is a two-step
    // thing: you keep a Vector of the lists data(Vector is an old-fashioned
    // ArrayList), and then tell the JList to use that Vector as it's source for
    // what to display in the list.
    public class RemoteReader implements Runnable {
        boolean[] checkboxState = null;
        String nameToShow = null;
        Object obj = null;
        public void run() {
            try {
                while((obj=in.readObject()) != null) {
                    System.out.format(&quot;已从服务器获取到一个对象\n%s\n&quot;, obj.getClass());
                    String nameToShow = (String) obj;
                    checkboxState = (boolean[]) in.readObject();
                    otherSeqsMap.put(nameToShow, checkboxState);
                    listVector.add(nameToShow);
                    incomingList.setListData(listVector);
                }
            } catch (Exception ex) {ex.printStackTrace();}
        }
    }

    public class PlayMineListener implements ActionListener {
        public void actionPerformed (ActionEvent ev) {
            if(mySeq != null) {
                // 恢复到自己原先的编排
                seq = mySeq;
            }
        }
    }

    // 全部有关 MIDI 的代码，都跟之前的版本一模一样。
    //
    // 获取音序器，构造一个音序，还构造了一个音轨
    public void setUpMidi () {
        try {
            s = MidiSystem.getSequencer();
            s.open();
            seq = new Sequence(Sequence.PPQ, 4);
            t = seq.createTrack();
            s.setTempoInBPM(120);
        } catch (Exception e) {e.printStackTrace();}
    }

    public void buildTrackAndStart () {
        int [] trackList = null;

        seq.deleteTrack(t);
        t = seq.createTrack();

        // 通过遍历这些勾选框而获取到他们的状态，并将这些状态
        // 映射到某种乐器（还构造了该乐器的 MidiEvent），从而
        // 构造出一个音轨。此操作相当复杂，不过也就只是在之前的
        // 章节中那样，因此请参考之前的代码厨房，以再度获得完整
        // 的说明。
        for (int i = 0; i &lt; 16; i++){
            trackList = new int[16];

            int key = instruments[i];

            for (int j = 0; j &lt; 16; j++) {
                JCheckBox jc = checkboxList.get(j + 16*i);
                if (jc.isSelected()) {
                    trackList[j] = key;
                } else {
                    trackList[j] = 0;
                }
            }

            makeTracks(trackList);
            t.add(makeEvent(176, 1, 127, 0, 16));
        }

        t.add(makeEvent(192, 9, 1, 0, 15));
        try {
            s.setSequence(seq);
            s.setLoopCount(Sequencer.LOOP_CONTINUOUSLY);
            s.start();
            s.setTempoInBPM(120);
        } catch(Exception e) {e.printStackTrace();}
    }

    // 以下是一些 GUI 的事件收听器。这些与先前章中的版本一致。
    //
    // 这几个GUI事件收听器是新加入的。
    //
    // 这也是个新的东西......这是一个新的 ListSelectionListener 事件收听器，在
    // 用户在消息清单上做出了一个选择时，该事件就会通知我们。在用户选中了一条
    // 消息时，这里就会立即加载与该消息相关联的节拍编排（在一个名为 otherSeqsMap 的
    // HashMap中），并开始演奏这个节拍编排。由于在获取 ListSelectionEvent 事件
    // 时存在一些古怪的事情，因此这里有多个 if 条件测试。
    class IncomingListSelectionListener implements ListSelectionListener {
        public void valueChanged(ListSelectionEvent ev){
            if(!ev.getValueIsAdjusting()){
                String selected = (String) incomingList.getSelectedValue();
                if(selected != null) {
                    // 现在去到乐器图谱，并修改其音序
                    boolean[] selectedState = (boolean[]) otherSeqsMap.get(selected);
                    changeSequence(selectedState);
                    s.stop();
                    buildTrackAndStart();
                }
            }
        }
    }

    // 在用户选择了传入消息清单中的某条消息时，便会调用此方法。这里会
    // 立即将编排修改为用户选中的那个编排。
    public void changeSequence(boolean[] state){
        for (int i = 0; i &lt; 256; i++) {
            JCheckBox check = (JCheckBox) checkboxList.get(i);
            if (state[i]) check.setSelected(true);
            else check.setSelected(false);
        }
    }

    class StartListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            buildTrackAndStart();
        }
    }

    // 这是个新的事件收听器......这里与发送一条字符串消息不同，是
    // 将两个对象（字符串消息与节拍编排对象）进行序列化，并将这两
    // 个对象写到那个套接字输出流（到服务器的）。
    class SendListener implements ActionListener {
        public void actionPerformed(ActionEvent ev){
            // 构造一个只保存那些勾选框状态的 ArrayList
            boolean[] checkboxState = new boolean[256];
            for (int i = 0; i &lt; 256; i++) {
                JCheckBox check = (JCheckBox) checkboxList.get(i);
                if(check.isSelected()) checkboxState[i] = true;
            }

            try {
                out.writeObject(String.format(&quot;%s%d: %s&quot;, userName, nextNum, userMessageBox.getText()));
                out.writeObject(checkboxState);
            } catch(Exception ex) {
                System.out.println(&quot;抱歉兄弟。无法将其发送到服务器。&quot;);
                ex.printStackTrace();
            }
            userMessageBox.setText(&quot;&quot;);
        }
    }

    class SavePatternListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            boolean[] checkboxesState = new boolean[256];

            for (int i = 0; i &lt; 256; i++){
                JCheckBox check = (JCheckBox) checkboxList.get(i);

                if (check.isSelected()) checkboxesState[i] = true;
            }

            JFileChooser fileChooser = new JFileChooser();
            fileChooser.showSaveDialog(BeatBoxFinal.this);
            File fileChoice = fileChooser.getSelectedFile();

            if (fileChoice != null) {
                try {
                    FileOutputStream fileStream = new FileOutputStream(fileChoice);
                    ObjectOutputStream os = new ObjectOutputStream(fileStream);
                    os.writeObject(checkboxesState);
                    os.close();
                }catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        }
    }

    class ReadInPatternListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            boolean[] checkboxesState = null;

            JFileChooser fileChooser = new JFileChooser();
            fileChooser.showOpenDialog(BeatBoxFinal.this);

            File fileSelected = fileChooser.getSelectedFile();

            if (fileSelected != null) {
                try {
                    FileInputStream fileIn = new FileInputStream(fileSelected);
                    ObjectInputStream is = new ObjectInputStream(fileIn);
                    checkboxesState = (boolean[]) is.readObject();
                    is.close();
                } catch (Exception ex) {
                    System.out.println(&quot;打开编曲出错&quot;);
                    ex.printStackTrace();
                }
            }

            // 这里有可能未选择文件，而导致checkboxesState 为 null
            if (checkboxesState != null) {
                for (int i = 0; i &lt; 256; i++) {
                    JCheckBox check = (JCheckBox) checkboxList.get(i);
                    if(checkboxesState[i]) check.setSelected(true);
                    else check.setSelected(false);
                }

                s.stop();
                buildTrackAndStart();
            }
        }
    }

    class StopListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            s.stop();
        }
    }

    class ResetListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            for(int i = 0; i &lt; 256; i++) {
                checkboxList.get(i).setSelected(false);
            }
        }
    }

    class UpTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            s.setTempoFactor(s.getTempoFactor() + 0.03f);
            tempoLabel.setText(String.format(&quot;速度因子：%.2f&quot;, s.getTempoFactor()));
        }
    }

    class DownTempoListener implements ActionListener {
        public void actionPerformed(ActionEvent ev) {
            s.setTempoFactor(s.getTempoFactor() - 0.03f);
            tempoLabel.setText(String.format(&quot;速度因子：%.2f&quot;, s.getTempoFactor()));
        }
    }

    public void makeTracks(int [] list) {
        for(int i = 0; i &lt; 16; i++) {
            int k = list[i];

            if(k != 0) {
                t.add(makeEvent(144, 9, k, 100, i));
                t.add(makeEvent(128, 8, k, 100, i+1));
            }
        }
    }

    public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick){
        MidiEvent ev = null;
        try {
            ShortMessage a = new ShortMessage();
            a.setMessage(comd, chan, one, two);
            ev = new MidiEvent(a, tick);
        } catch (Exception e) {e.printStackTrace();}
        return ev;
    }
}
</code></pre>
<p><strong>自己动手写代码</strong></p>
<p>关于这个程序，有些什么方式可以加以改进呢？</p>
<p>可从下面的几个方面着手：</p>
<ol>
<li>
<p>现在这个程序，一旦点选了某个编排，那么不管正在演奏的当前编排是什么，都会消失不见。那么如果正在制作的编排是个新的（或者是对另一编排的修改），这就不好了。这里或许应该弹出一个对话框，询问用户是否想要保存当前的编排；</p>
</li>
<li>
<p>在没有输入命令行参数时，那么运行这个程序就会收到一个异常。那么就应当在那个检查是否传入一个命令行参数的 <code>main</code> 方法里，放入一些代码。在用户没有提供参数时，要么选择一个默认的用户名，要么打印一条消息出来，告诉用户需要再次提供一个用于显示名字的参数，运行此程序。</p>
</li>
<li>
<p>若能够提供一个按钮，在点击这个按钮时程序会生成一个随机编排，这样的特性一定大受欢迎。这样生成的随机编排，说不定就是用户喜欢的呢。更为可取的是，若能让用户加载一些既有的“基础性”编排，比如一些 Jazz、Rock、Reggae等的编排，用户可在这些基础性编排上再添加。那就更好了。</p>
</li>
</ol>
<p>在 Head First Java 网站上，就能找到这样的基础性编排。</p>
<h3 id="最终的beatbox服务器程序"><a class="header" href="#最终的beatbox服务器程序">最终的<code>BeatBox</code>服务器程序</a></h3>
<p><strong>Final <code>BeatBox</code> server program</strong></p>
<p>下面的代码，绝大部分都跟在 “网络通信及线程” 那一章中构造的相同。事实上唯一区别在于，这个服务器程序会接收、并重新发送两个序列化对象，而不是之前的普通字符串了（尽管其中一个序列化对象是个字符串）。</p>
<pre><code class="language-java">package com.xfoss.BeatBox;

import java.io.*;
import java.net.*;
import java.util.*;

public class MusicServer {

    ArrayList&lt;ObjectOutputStream&gt; clientOutputStreams;

    public MusicServer () {
        clientOutputStreams = new ArrayList&lt;ObjectOutputStream&gt; ();

        try {
            ServerSocket serverSock = new ServerSocket(14242);

            while(true) {
                Socket clientSock = serverSock.accept();
                ObjectOutputStream out = new ObjectOutputStream(clientSock.getOutputStream());
                clientOutputStreams.add(out);

                Thread t = new Thread(new ClientHandler(clientSock));
                t.start();

                System.out.println(&quot;已获取到一个连接&quot;);
            }
        } catch(Exception ex) {ex.printStackTrace();}
    }

    public class ClientHandler implements Runnable {

        ObjectInputStream in;
        Socket clientSock;

        public ClientHandler (Socket s) {
            try {
                clientSock = s;
                in = new ObjectInputStream(clientSock.getInputStream());
            } catch (Exception ex) {ex.printStackTrace();}
        }

        public void run () {
            Object o2 = null;
            Object o1 = null;

            try {
                while ((o1 = in.readObject()) != null) {
                    o2 = in.readObject();
                    System.out.println(&quot;已读取到两个对象&quot;);
                    tellEveryone(o1, o2);
                }
            } catch (Exception ex) {ex.printStackTrace();}
        }
    }

    public void tellEveryone(Object o1, Object o2) {
        Iterator it = clientOutputStreams.iterator();
        while(it.hasNext()) {
            try {
                ObjectOutputStream out = (ObjectOutputStream) it.next();
                out.writeObject(o1);
                out.writeObject(o2);
            } catch (Exception ex) {ex.printStackTrace();}
        }
    }

    public static void main (String[] args) {
        new MusicServer();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合与泛型数据结构"><a class="header" href="#集合与泛型数据结构">集合与泛型：数据结构</a></h1>
<p><strong>Collections and Generics: Data Structure</strong></p>
<p><strong>在 Java 里头，排序就是小菜一碟</strong>。无需编写自己的排序算法，就有了收集与操纵数据的全部工具（除非在阅读本章时，正坐在计算机科学101, CS 101 课程的教室里，那么在我们Java程序员简单地调用一个Java API中方法时，你就要去编写那个排序方法了）。Java 的集合框架，有着一种几乎全部需要完成事情的数据结构（The Java Collections Framework has a data structure that should work for virtually anything you'll ever need to do）。想要有个可轻易持续地往其上添加的清单吗？想要通过名字来找到某个物件吗？想要创建一个可自动排除所有重复项目的清单吗？要按照对你背后捅刀次数，对你的同事们排个序吗？把你的宠物，按照他们掌握的把戏排个序怎么样？本章就是关于这些的......</p>
<h2 id="追踪自动唱机上歌曲流行度"><a class="header" href="#追踪自动唱机上歌曲流行度">追踪自动唱机上歌曲流行度</a></h2>
<p><strong>Tracking song popularity on your jukebox</strong></p>
<p>恭喜你获得了新的任务--管理楼氏餐厅的自动唱机系统。这自动唱机里头，本身并没有Java，不过在每次有人点播了一首歌时，歌曲数据就会被追加到一个简单的文本文件。</p>
<p>你的任务，就是对这个数据进行管理，从而跟踪到歌曲流行度，生成一些报告，进而修改那些播放清单。这里并非要编写整个的 app -- 别的一些软件开放者/侍应生也会参与进来，你所要负责的，仅是对整个Java app内的数据加以管理和排序。而由于楼老板抵触数据库，因此数据是严格来说是个内存中的数据集（an in-memory data collection）。所得到的全部，就是那个自动唱机持续添加数据的文件。你的任务，就是从那里取得数据。</p>
<p>先前我们已经掌握了怎样读取和解析该文件，并且到目前位置，都是将数据保管在一个 <code>ArrayList</code> 中的。</p>
<p><strong>#1 挑战</strong></p>
<p><strong>对这些歌曲，按照字母顺序排序</strong></p>
<p>在某个文件中，有着一个歌曲的清单，其中各行分别表示一首歌曲，且歌曲标题与艺人，是以正斜杠分开的。那么对这样的行进行解析，进而把全部歌曲放入到一个 <code>ArrayList</code> 里头就简单了。</p>
<p><img src="images/Ch16_01.png" alt="SongList.txt" /></p>
<p><em>图 1 - SongList.txt</em></p>
<blockquote>
<p><em>这就是那个自动点唱机设备所写入的文件。这里的代码必须读取整个文件，随后对歌曲数据进行操作</em>。</p>
</blockquote>
<p>老板只对歌曲标题感兴趣，因此现在就可以简单地构造一个只有歌曲标题的清单就行。</p>
<p>然而会发现整个清单不是以字母顺序的......这里可以做点什么呢？</p>
<p>我们知道对于一个 <code>ArrayList</code> 来说，那些元素保持着将其插入到清单中的顺序，那么把这些元素放入到 <code>ArrayList</code> 中，就不会留意到他们的字母排序的，除非......<code>ArrayList</code>类中，有着一个<code>sort()</code>方法。</p>
<p><strong>下面就是到目前为止，不带排序的样子</strong>：</p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;
import java.io.*;
import com.xfoss.Utils.XPlatformThings;

public class JukeBox1 {

    // 这里将把那些歌曲标题保管在一个字符串的 ArrayList 中。
    ArrayList&lt;String&gt; songList = new ArrayList&lt;String&gt; ();

    String wDir = XPlatformThings.getWorkingDir(&quot;learningJava&quot;);

    // 启动加载文件并打印那个 songList 的 ArrayList 的构造函数。
    public JukeBox1 () {
        getSongs();
        System.out.println(songList);
    }

    public static void main(String[] args){
        new JukeBox1();
    }

    // 这里并无什么特别之处......只是读取文件并针对各行调用 addSong() 方法。
    void getSongs() {
        try {
            File file = new File(String.format(&quot;%s/SongList.txt&quot;, wDir));
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String line = null;
            while ((line = reader.readLine()) != null) {
                addSong(line);
            }
        } catch (IOException ex) {ex.printStackTrace();}
    }

    // 这个 addSong 方法就如同 I/O 章中 QuizCard 一样 -- 运用 split() 方法
    // 将行（有着歌曲标题与艺人）拆开为两个片段（令牌）。
    void addSong(String lineToParse) {
        String [] tokens = lineToParse.split(&quot;/&quot;);
        // 这里只要歌曲标题，因此只将第一个令牌添加到 songList（即那个 ArrayList）。
        songList.add(tokens[0]);
    }
}
</code></pre>
<p><img src="images/Ch16_02.png" alt="JukeBox1" /></p>
<p><em>图 2 - JukeBox1</em></p>
<blockquote>
<p><em>songList 会以这些歌曲标题被添加到这个 <code>ArrayList</code> （其中的顺序与这些歌曲在原始文本文件中的顺序相同）的顺序，打印出这些歌曲标题</em>。</p>
<p>显然这不是以字母顺序排序的！</p>
</blockquote>
<h3 id="然而类-arraylist-并没有sort-方法"><a class="header" href="#然而类-arraylist-并没有sort-方法">然而类 <code>ArrayList</code> 并没有<code>sort()</code> 方法！</a></h3>
<p>在检视 <code>ArrayList</code> 时，看起来那里是没有任何有关排序的方法。即便往上检索他的继承树也毫无助益--明显 <em><strong>在 <code>ArrayList</code> 上是无法调用到某个排序方法的</strong></em>。</p>
<p><img src="images/Ch16_03.png" alt="Java API - ArrayList" /></p>
<p><em>图 3 - Java API - ArrayList</em></p>
<blockquote>
<p><em><code>ArrayList</code> 有着很多方法，不过却没有可用于排序的</em>......</p>
</blockquote>
<h3 id="arraylist-并非唯一的集合"><a class="header" href="#arraylist-并非唯一的集合"><code>ArrayList</code> 并非唯一的集合</a></h3>
<p><strong><code>ArrayList</code> is not the only collection</strong></p>
<blockquote>
<p><em>我的确见到过一个名为 <code>TreeSet</code> 的集合类......并且文档讲到这个集合类保持着排序后的数据。我就想知道是不是应该使用<code>TreeSet</code>而非<code>ArrayList</code>......（I do see a collection class called <code>TreeSet</code>...and the docs say that it keeps your data sorted. I wonder if I should be using a <code>TreeSet</code> instead of an <code>ArrayList</code>...）</em></p>
</blockquote>
<p>虽然<code>ArrayList</code>是在今后会用到最多的集合类，对于特殊情形，还是有一些其他的集合类。其中一些关键集合类，包括以下几个：</p>
<blockquote>
<p><em>请不要急于去了解别的那些集合类。稍后会涉及到更多的细节</em>。</p>
</blockquote>
<ul>
<li>
<p><strong><code>TreeSet</code></strong></p>
<p>让元素保持排序并防止重复（Keeps the elements sorted and prevents duplicates）。</p>
</li>
<li>
<p><strong><code>HashMap</code></strong></p>
<p>实现了名称/值对方式的元素存储与访问（Let you store and access elements as name/value pairs）。</p>
</li>
<li>
<p><strong><code>LinkedList</code></strong></p>
<p>令到诸如栈与队列等数据结构的创建容易起来（Make it easy to create structures like stacks or queues）。</p>
</li>
<li>
<p><strong><code>HashSet</code></strong></p>
<p>去除集合中的重复，同时对于给定元素，可快速在集合中找出来（Prevents duplicates in the collection, and given an element, can find that element in the collection quickly）。</p>
</li>
<li>
<p><strong><code>LinkedHashMap</code></strong></p>
<p>与常规 <code>HashMap</code> 类似，但他可以记住其中元素（名/值对）插入的顺序，也可以被配置为记住那些最近被访问过元素的顺序（Like a regular <code>HashMap</code>, except it can remember the order in which elements(name/value pairs) were inserted, or it can be configured to remember the order in which elements were last accessed）。 </p>
</li>
</ul>
<h3 id="可以使用treeset也可以使用collectionssort方法"><a class="header" href="#可以使用treeset也可以使用collectionssort方法">可以使用<code>TreeSet</code>......，也可以使用<code>Collections.sort()方法</code></a></h3>
<p>在将全部字符串（即那些歌曲标题）放入到一个 <strong><code>TreeSet</code></strong> 而非 <code>ArrayList</code>中时，这些字符串就会自动以正确位置，即字母顺序着地。之后无论何时打印出这个清单，这些元素都会始终以字母顺序输出。</p>
<p>在需要一个 <em>集合（set）</em>（接下来就会讲到什么是集合），或可以肯定清单必须 <em>始终</em> 保持字母排序时，这样处理是相当不错的。</p>
<p>不过在别的情况下，在不需要清单保持排序时，相比这样的需求，使用<code>TreeSet</code>就显得有些代价高昂 -- <em><strong>在每次往<code>TreeSet</code>插入元素时，<code>TreeSet</code>都必须花时间去找出应在何处插入这个元素</strong></em>。而使用 <code>ArrayList</code>，由于新元素只会在清单末尾加入，那么元素插入就可以快得让人窒息。</p>
<p><img src="images/Ch16_04.png" alt="Java API java.util.Collections" /></p>
<p><em>图 4 - Java API <code>java.util.Collections</code></em></p>
<blockquote>
<p><em>嗯......在 <code>Collections</code> 类中确实有个 <code>sort()</code> 方法。他会取得一个 <code>List</code>，同时由于<code>ArrayList</code>实现了 <code>List</code> 接口，因此 <code>ArrayList</code> <code>IS-A</code> <code>List</code>。归功于多态机制，就可以将<code>ArrayList</code>传递给声明了取得 <code>List</code> 的方法</em>。</p>
<p><em>请注意</em>：这并非是一个真正的 <code>Collections</code> 类的API文档；这里通过省略有关泛型（the generic type, 将在本章后面讲到）的信息，而对其进行了简化。</p>
</blockquote>
<h3 id="答疑-21"><a class="header" href="#答疑-21">答疑</a></h3>
<ul>
<li><strong>不是可以把元素添加到<code>ArrayList</code>的特定索引处，而不是他的末尾的吗 -- 确实有一个过载的<code>add()</code>方法，连同要添加的元素一道，还取得一个整型参数呢。那么这样就不会比直接插入到清单末尾更慢吗</strong>？</li>
</ul>
<blockquote>
<p>是的，在 <code>ArrayList</code> 末尾插入元素，在其他地方是要慢一些的。因此使用过载的<code>add(index, element)</code> 方法，就不如调用 <code>add(element)</code> -- 这会把添加的元素放在清单末尾，这样来得快。然而在大部分用到<code>ArrayList</code>的时候，是无需将某个元素放在指定索引处的。</p>
</blockquote>
<ul>
<li><strong>我看见那里有一个 <code>LinkedList</code> 类，那么是不是使用 <code>LinkedList</code>，就可以更好地实现在清单中间插入元素呢？至少我还记得大学时学过的数据结构课</strong>......</li>
</ul>
<blockquote>
<p>是的，讲得不错。在从清单中中间插入或移除元素时，<code>LinkedList</code>要快一些，然而对于大多数应用，除非是在处理 <em>巨量</em> 的元素，那么往 <code>LinkedList</code> 与 <code>ArrayList</code> 的中间插入的区别，通常不足以纳入考量。后面很快就会深入了解 <code>LinkedList</code> 类。</p>
</blockquote>
<h3 id="把collectionssort-方法添加到-jukebox-代码"><a class="header" href="#把collectionssort-方法添加到-jukebox-代码">把<code>Collections.sort()</code> 方法添加到 <code>JukeBox</code> 代码</a></h3>
<blockquote>
<p><strong><code>Collections.sort()</code> 方法，会将字符串清单，以字母顺序进行排序</strong>。</p>
</blockquote>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;
import java.io.*;
import com.xfoss.Utils.XPlatformThings;

public class JukeBox1 {
    ArrayList&lt;String&gt; songList = new ArrayList&lt;String&gt; ();
    String wDir = XPlatformThings.getWorkingDir(&quot;learningJava&quot;);

    public JukeBox1 () {
        getSongs();
        System.out.println(songList);

        // 对静态类 `Collections` 的 `sort()` 方法进行调用，并
        // 再次打印处这个清单。这第二个打印输出，就是以字母顺序的了！
        Collections.sort(songList);
        System.out.println(songList);
    }

    public static void main(String[] args){
        new JukeBox1();
    }

    void getSongs() {
        try {
            File file = new File(String.format(&quot;%s/SongList.txt&quot;, wDir));
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String line = null;
            while ((line = reader.readLine()) != null) {
                addSong(line);
            }
        } catch (IOException ex) {ex.printStackTrace();}
    }

    void addSong(String lineToParse) {
        String [] tokens = lineToParse.split(&quot;/&quot;);
        songList.add(tokens[0]);
    }
}
</code></pre>
<p><img src="images/Ch16_05.png" alt="加入了 Collections.sort() 方法后的 JukeBox1 程序" /></p>
<p><em>图 5 - 加入了 <code>Collections.sort()</code> 方法后的 <code>JukeBox1</code> 程序</em></p>
<h3 id="然而现在需要的是-song-对象而不是那些简单的字符串"><a class="header" href="#然而现在需要的是-song-对象而不是那些简单的字符串">然而现在需要的是 <code>Song</code> 对象，而不是那些简单的字符串</a></h3>
<p>现在老板想要清单中的那些具体 <code>Song</code> 类实例，而不仅仅是一些字符串，那么每个 <code>Song</code> 就要有更多的数据了。新的自动点唱机装置输出了更多的信息，那么这次这个文件就会有 <em>四个</em> 片段（令牌），而不再仅仅两个了。</p>
<p>类 <code>Song</code> 是相当简单的，仅有一个感兴趣的特性 -- 一个重写了的 <code>toString()</code> 方法。请记住，这个 <code>toString()</code>方法，是在类 <code>Object</code> 中定义的，因此Java 中的每个类，都继承了这个方法。同事由于在打印某个对象（<code>System.out.println(anObject)</code>）时，会调用到这个对象上的 <code>toString()</code> 方法，因此就应该对其进行重写，来打印出一些比起默认唯一识别符代码，更具可读性的东西。在打印某个歌曲对象清单时，将调用到各个 <code>Song</code> 对象上的这个 <code>toString()</code> 方法。</p>
<pre><code class="language-java">class Song {

    // 这四个实例变量表示文件中的四个歌曲属性。
    private String title;
    private String artist;
    private String rating;
    private String bpm;

    // 这些变量都是在新的 Song 对象被创建时，在构造器中设置的。
    Song (String t, String a, String r, String b) {
        title = t;
        artist = a;
        rating = r;
        bpm = b;
    }

    // 这些是四个属性的获取器方法。
    public String getTitle () {
        return title;
    }

    public String getArtist () {
        return artist;
    }

    public String getRating () {
        return rating;
    }

    public String getBpm () {
        return bpm;
    }

    // 由于在执行 System.out.println(aSongObject)时，希望看到歌曲标题，因此
    //  这里重写了 toString() 方法。在执行 System.out.println(aListOfSongs) 
    //  时，就会调用清单中各个元素的这个 toString() 方法。
    public String toString () {
        return title;
    }
}
</code></pre>
<h3 id="将-jukebox-代码修改为使用-song-对象而非那些字符串"><a class="header" href="#将-jukebox-代码修改为使用-song-对象而非那些字符串">将 <code>JukeBox</code> 代码修改为使用 <code>Song</code> 对象而非那些字符串</a></h3>
<p>代码只会修改很少 -- 文件 I/O 代码还是一样，且解析代码也一样（<code>String.split()</code>静态方法），这次不一样的，是每行/每首歌曲将有 <em>四个</em> 令牌，同时全部四个都将用于构造一个新的 <code>Song</code> 对象。同时理所应当的这个 <code>ArrayList</code> 将是类型 <code>&lt;Song&gt;</code> 而非 <code>&lt;String&gt;</code> 了。</p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;
import java.io.*;
import com.xfoss.Utils.XPlatformThings;

public class JukeBox3 {

    // 这里将这个 ArrayList 从 String 修改为了 Song 对象。
    ArrayList&lt;Song&gt; songList = new ArrayList&lt;Song&gt; ();
    String wDir = XPlatformThings.getWorkingDir(&quot;learningJava&quot;);

    public JukeBox3 () {
        getSongs();
        System.out.println(songList);

        Collections.sort(songList);
        System.out.println(songList);
    }

    public static void main(String[] args){
        new JukeBox3();
    }

    void getSongs() {
        try {
            File file = new File(String.format(&quot;%s/SongListMore.txt&quot;, wDir));
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String line = null;
            while ((line = reader.readLine()) != null) {
                addSong(line);
            }
        } catch (IOException ex) {ex.printStackTrace();}
    }

    void addSong(String lineToParse) {

        // 这里使用四个令牌（也就是歌曲文件中这一行的四个信息片段）创建
        // 出一个新的 Song 对象，并将该 Song 对象添加到那个清单。
        String [] tokens = lineToParse.split(&quot;/&quot;);

        Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);
        songList.add(nextSong);
    }
}
</code></pre>
<h3 id="然而这代码不会被编译出来"><a class="header" href="#然而这代码不会被编译出来">然而这代码不会被编译出来！</a></h3>
<pre><code class="language-console">/home/peng/eclipse-workspace/learningJava/src/main/java/com/xfoss/CollectionAndGenerics/JukeBox3.java:17:
    error: no suitable method found for sort(ArrayList&lt;Song&gt;)
           Collections.sort(songList);
                      ^
       method Collections.&lt;T#1&gt;sort(List&lt;T#1&gt;) is not applicable
         (inference variable T#1 has incompatible bounds
           equality constraints: Song
           lower bounds: Comparable&lt;? super T#1&gt;)
       method Collections.&lt;T#2&gt;sort(List&lt;T#2&gt;,Comparator&lt;? super T#2&gt;) is not applicable
         (cannot infer type-variable(s) T#2
           (actual and formal argument lists differ in length))
  where T#1,T#2 are type-variables:
    T#1 extends Comparable&lt;? super T#1&gt; declared in method &lt;T#1&gt;sort(List&lt;T#1&gt;)
    T#2 extends Object declared in method &lt;T#2&gt;sort(List&lt;T#2&gt;,Comparator&lt;? super T#2&gt;)
Note: Some input files use unchecked or unsafe operations.
</code></pre>
<p>某个地方出错了......那个 <code>Collections</code> 类明明是有个取<code>List</code> 做参数的 <code>sort()</code> 方法的。</p>
<p><code>ArrayList</code> 确实是一个 <code>List</code>，因为 <code>ArrayList</code> 实现了接口 <code>List</code>，那么......这代码 <em>应该</em> 跑起来的。</p>
<p><em><strong>然而这代码并没有跑起来</strong></em>!</p>
<p>编译器说，他无法找到适当的、取一个 <code>ArrayList&lt;Song&gt;</code> 作参数的 <code>sort</code> 方法，那么或许是这个 <code>sort()</code> 方法不喜欢一个 <code>Song</code>对象构成的 <code>ArrayList</code>？不过这个 <code>Collections.sort()</code> 方法又并不介意一个 <code>ArrayList&lt;String&gt;</code>，那么 <code>Song</code> 与 <code>String</code> 之间，到底有什么重要的区别呢？是什么差异导致了编译器的失败呢？</p>
<p>当然你或许已经想到，“排序的 <em>依据</em> 到底是什么？” 这个 <code>sort</code> 方法是怎样知道，是什么造成一个 <code>Song</code> 大于 另一<code>Song</code> 对象的？显然在希望歌曲标题作为判断这些歌曲排序方式时，就需要某种方式，来告知这个 <code>sort</code> 方法，他需要使用标题，而非比如说每分钟的拍数（the beats per minute, bpm）。</p>
<p>关于这点，正是这里接下来几页要讨论的问题，不过首先，让我们搞清楚，为何编译器甚至不会允许将一个 <code>Song</code> 的 <code>ArrayList</code> 传递给这个 <code>sort()</code> 方法。</p>
<h3 id="collectionssort-方法的声明"><a class="header" href="#collectionssort-方法的声明"><code>Collections.sort()</code> 方法的声明</a></h3>
<p><img src="images/Ch16_06.png" alt="Java API Collections.sort()" /></p>
<p><em>图 6 - Java API <code>Collections.sort()</code></em></p>
<blockquote>
<p><em>WTF? 我都不知道该怎么去看这个方法声明。他讲了 <code>sort()</code> 要取一个 <code>List&lt;T&gt;</code> 的参数，然而 <code>T</code> 是个啥？还有在返回值类型前那一大坨又是啥</em>？</p>
</blockquote>
<p>从 API 文档（找找 <code>java.util.Collections</code> 类，然后滚动 <code>sort()</code> 方法），似乎这个 <code>sort()</code> 方法声明得...... <em>有些奇怪</em>。或者至少不同于先前见到的任何一个。</p>
<p>那是因为，这个 <code>sort()</code> 方法（连同Java中整个集合框架中的其他东西），重度运用了 <em>泛型（generics）</em>。不论何时，但凡在 Java 源码或文档中，见到某个东西带有尖括号，那就意味着泛型 -- 一个添加到 Java 5.0 版本中的特性。因此在搞清楚为何可以对 <code>ArrayList</code> 中的字符串对象进行排序，而无法对 <code>Song</code> 对象的<code>ArrayList</code> 进行排序之前，这里就不得不掌握如何去理解文档。</p>
<h2 id="泛型意味着更好的类型安全"><a class="header" href="#泛型意味着更好的类型安全">泛型意味着更好的类型安全</a></h2>
<p><strong>Generics means more type-safety</strong></p>
<p>这里就会讲到这个 -- <em>我们所写的全部涉及到泛型的代码，实际上都将是有关集合的代码（virtually all of the code you write that deals with generics will be collection-related code）</em>。虽然泛型可以其他一些方式使用，但泛型的要点，是可以写出类型安全的集合。也就是那些可以令到编译器阻止我们把一个 <code>Dog</code> 对象，放入到一个 <code>Duck</code> 清单里去的代码。</p>
<blockquote>
<p><strong>注</strong>：<em>关于 Collection 与 Set 的区别，请参考 <a href="https://www.quora.com/What-is-the-difference-between-a-set-and-a-collection-in-Java">What is the difference between a set and a collection in Java?</a></em></p>
</blockquote>
<p>在泛型之前（即在 Java 5.0 之前），由于所有集合实现，都被声明为保存类型 <code>Object</code>，因此编译器不会在乎放入到某个集合的为何物。那时可将 <em>任何东西</em> 都放入到所有 <code>ArrayList</code>；这就好比所有 <code>ArrayList</code> 都被声明为了 <code>ArrayList&lt;Object&gt;</code>。</p>
<blockquote>
<p><strong>有了泛型，就可以创建类型安全的集合，其中在编译时，而不是运行时就可以发现更多的问题</strong>。</p>
<p><strong>若没有泛型，那么编译器会痛快地允许将 <code>Pumpkin</code> 放入到本被假定为仅保管 <code>Cat</code> 对象的 <code>ArrayList</code></strong>。</p>
</blockquote>
<p><img src="images/Ch16_07.png" alt="没有泛型与带有泛型的对比" /></p>
<p><em>图 7 - 没有泛型与带有泛型的对比</em></p>
<blockquote>
<p><em>现在有了泛型，就只能将 <code>Fish</code> 对象放入到这个 <code>ArrayList&lt;Fish&gt;</code> 中，因此那些从这个清单中取出的对象，就是些<code>Fish</code> 引用变量了。不必担心有人会把一个 <code>Volkswagen</code> 放在那里面，或者担心从那里取出的对象，不会确实是个兼容 <code>Fish</code> 的引用变量</em>。</p>
</blockquote>
<h3 id="了解泛型"><a class="header" href="#了解泛型">了解泛型</a></h3>
<p><strong>Learning generics</strong></p>
<p>关于泛型，有很多需要掌握的东西，对于大多数程序员，则只需要了解下面三个：</p>
<ol>
<li>
<p>创建一些泛化类的实例（creating instances of generified classess, 比如 <code>ArrayList</code>）</p>
<p><code>new ArrayList&lt;Song&gt; ()</code></p>
<p>在构造一个 <code>ArrayList</code> 时，就必须告诉这个 <code>ArrayList</code> 类型的变量，这个清单中将允许的对象类型，这就跟原先那些普通数组一样。</p>
</li>
<li>
<p>声明并赋值一些泛型的变量（declaring and assigning variables of generic types）</p>
<p><code>List&lt;Song&gt; songList = new ArrayList&lt;Song&gt; ()</code></p>
<p>多态机制与泛型到底是怎样一起生效的呢？在有着一个 <code>ArrayList&lt;Animal&gt;</code> 的引用变量时，可以将一个 <code>ArrayList&lt;Dog&gt;</code> 的变量赋值给他吗？对于一个 <code>List&lt;Animal&gt;</code> 的引用变量又如何呢？可以将一个 <code>ArrayList&lt;Animal&gt;</code> 对象，赋值给他吗？接下来就会看到.......</p>
</li>
<li>
<p>声明（及触发）那些取泛型作参数的方法（declaring(and invoking) methods that take generic types）</p>
<pre><code class="language-java">void foo(List&lt;Song&gt; list)
x.foo(songList)
</code></pre>
</li>
</ol>
<blockquote>
<p><em><strong>注</strong></em>：关于 call 与 invoke 的区别，请参考：<a href="https://www.quora.com/What-is-the-difference-between-call-and-invoke">what is the difference between 'call' and 'invoke'?</a></p>
</blockquote>
<p>在有着某个取一个参数，即 <code>Animal</code> 类型对象的 <code>ArrayList</code> 的方法时，到底那意味着什么呢？可否传递给这个方法一个 <code>Dog</code> 类型对象的 <code>ArrayList</code> 呢？后面就会讨论到与先前那种取老式普通数组作参数的方法相比，一些微妙而棘手的问题。</p>
<p>（这实际上与上面第二点相同，但这正好说明多态与泛型在一起时的重要性。）</p>
<h2 id="运用泛型类using-generic-classes"><a class="header" href="#运用泛型类using-generic-classes">运用泛型类（using generic CLASSES）</a></h2>
<p>由于 <code>ArrayList</code> 是这里最常用到的泛化类型，那么这里将以他的文档开始。要注意到泛化类的以下两个关键点：</p>
<ol>
<li>
<p>这个 <em>类</em> 的声明（The <em>class</em> declaration）</p>
</li>
<li>
<p>那些实现元素添加的 <em>方法</em> 的声明（The <em>method</em> declarations that let you add elements）</p>
</li>
</ol>
<p><img src="images/Ch16_08.png" alt="Java API - ArrayList" /></p>
<p><em>图 8 - Java API - ArrayList</em></p>
<h3 id="理解-arraylist-的文档"><a class="header" href="#理解-arraylist-的文档">理解 <code>ArrayList</code> 的文档</a></h3>
<p>（或者说，这里 <code>E</code> 的真正意义为何？）</p>
<blockquote>
<p><strong>请将这里的 “E”，当作 “希望这个集合所保留与返回的元素类型”。（E 就是元素 Element 中的 E。）</strong></p>
<p><strong>Think of &quot;E&quot; as a stand-in for &quot;the type of element you want this collection to hold and return.&quot; (<ins>E</ins> is for <ins>E</ins>lement.)</strong></p>
</blockquote>
<pre><code class="language-java">// 这个 “E” 是在声明和创建某个 ArrayList 时，所用到具体
// 类型的占位符。
public class ArrayList&lt;E&gt;
// ArrayList 是 AbstractList 的一个子类，因此不论指定了
// 何种类型给这个 ArrayList, 都会自动用到类型 AbstractList 上。
extends AbstractList&lt;E&gt;
// 这个类型（即 &lt;E&gt; 的取值）同时将成为 List 接口的类型。
implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable {
    // 这里是重点！这里的 “E” 决定了所能添加到这个 ArrayList
    // 的物件类别。
    public boolean add (E o)
    // 其他代码
}
</code></pre>
<p>这个 <code>E</code> 表示用于创建 <code>ArrayList</code> 实例的类型，在见到 <code>ArralyList</code> 文档中的 <code>E</code> 时，就可以暗自将其查找/替换为用于初始化 <code>ArrayList</code> 的那个 <code>&lt;type&gt;</code>。</p>
<p>那么那个新的 <code>ArrayList&lt;Song&gt;</code> 就表示，在所有用到 <code>E</code> 的方法或变量声明中的 <code>E</code> 成为了 <code>Song</code>。</p>
<h3 id="在-arraylist-下使用类型参数"><a class="header" href="#在-arraylist-下使用类型参数">在 <code>ArrayList</code> 下使用类型参数</a></h3>
<p><strong>Using type parameters with <code>ArrayList</code></strong></p>
<p>这段代码：</p>
<pre><code class="language-java">ArrayList&lt;String&gt; thisList = new ArrayList&lt;String&gt;
</code></pre>
<p>意味着 <code>ArrayList</code>:</p>
<pre><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; ... {

    public boolean add(E o) {...}
    // 其他代码
}
</code></pre>
<p>是被编译器这样来对待的：</p>
<pre><code class="language-java">public class ArrayList&lt;String&gt; extends AbstractList&lt;String&gt; ... {

    public boolean add(String o) {...}
    // 其他代码
}
</code></pre>
<p>也就是说，这里的 <code>E</code> 被那个在创建该 <code>ArrayList</code> 时所使用的 <em>具体</em> 类型（也被称为 <em>类型参数（type parameter）</em>）取代了。同时也是为何<code>ArrayList</code>的<code>add()</code> 方法不会允许将除了与这个 <code>E</code> 类型兼容的引用变量类型变量的对象之外，其他任何对象加以添加的原因。因此在构造了一个 <code>ArrayList&lt;String&gt;</code> 时，这个<code>add()</code>方法，突然间就变成了 <code>add(String o)</code>。在创建了类型为 <code>Dog</code> 的 <code>ArrayList</code> 时，那个 <code>add()</code> 就突然成为了 <code>add(Dog o)</code>。</p>
<h3 id="答疑-22"><a class="header" href="#答疑-22">答疑</a></h3>
<ul>
<li><strong>这里就只能放一个 <code>E</code> 吗？因为 <code>sort</code> 的文档还使用了 <code>T</code>......</strong></li>
</ul>
<blockquote>
<p>只要是合法的 Java 标识符，都可以使用。那就意味着所有可用于方法或变量名称的东西，都会用作类型参数（a type parameter）。不过有个约定，就是要使用单个字母（那么就应该使用单个字母），同时进一步的约定，就是除非专门编写了一个集合类，那么在使用 <code>E</code> 来表示 “集合将保留元素的类型”的地方，就要使用 <code>T</code>（You can use anything that's a legal Java identifier. That means anything that you could use for a method or variable name will work as a type parameter. But the convention is to use a single letter(so that's what you shold use), and a further convention is to use <code>T</code> unless you're specifically writing a collection calss, where you'd use <code>E</code> to represent the &quot;type of the Element the collection will hold&quot;）。</p>
</blockquote>
<h3 id="运用泛型方法"><a class="header" href="#运用泛型方法">运用泛型方法</a></h3>
<p><strong>Using generic METHODS</strong></p>
<p>泛型 <em>类</em> 意味着 <em>类的声明</em> 包含了类型参数。而泛型 <em>方法</em>，表示方法声明在他的签名中，用到了一个类型参数（A generic <em>class</em> means that the <em>class declaration</em> includes a type parameter. A generic <em>method</em> means that the method declaration uses a type parameter in its signature）。</p>
<p>在方法中使用类型参数的几种不同方式：</p>
<ol>
<li>
<p>使用在类声明中定义的类型参数（using a type parameter defined in the class declaration）</p>
<pre><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; ... {
    // 之所以可以在这里使用 &quot;E&quot;, 完全是因为这个 &quot;E&quot; 已经作为
    // 这个类的一部分被定义了。
    public boolean add(E o)
}
</code></pre>
<p>在声明类的某个类型参数时，就可以像使用某个 <em>具体</em> 类或接口类型那样，在任意地方使用这个类型了。于方法参数中声明的类型，就会被那个在初始化这个类时用到的类型所取代（When you declare a type parameter for the class, you can simply use that type any place that you'd use a <em>real</em> class or interface type. The type declared in the method argument is essentially replaced with the type you use when you instantiate the class）。</p>
</li>
<li>
<p>使用未在类声明中定义的某个类型参数（using a type parameter that was NOT defined in the class declaration）</p>
<pre><code class="language-java">// 后面方法参数中之所以可以使用 &lt;T&gt;，是由于前面在方法声明中
// 声明过 “T”。
public &lt;T extends Animal&gt; void takeThing (ArrayList&lt;T&gt; list)
</code></pre>
<p>在类本身未用到类型参数时，仍然可以通过在一个相当不寻常的（不过仍然可行）的地方 -- <em>在返回值类型之前</em>，声明一个类型参数，从而给某个方法指定一个类型参数。上面这个方法，表示那个 <code>T</code> 可以是 “任何的<code>Animal</code>类型”（If the class itself doesn't use a type parameter, you can still specify one for a method, by declaring it in a really unusual(but available) space -- <em>before the return type</em>. This method says that <code>T</code> can be &quot;any type of <code>Animal</code>&quot;）。</p>
</li>
</ol>
<h3 id="这里有点玄乎了"><a class="header" href="#这里有点玄乎了">这里有点玄乎了......</a></h3>
<p><strong>Here's where it gets weird...</strong></p>
<blockquote>
<p><em>等下......这里一定有什么问题。既然可以取一个 <code>Animal</code> 的清单作参数，那么为什么不直接用 <code>ArrayList&lt;Animal&gt;</code> 呢？直接用 <code>takeThing(ArrayList&lt;Animal&gt; list)</code> 有什么问题</em>？</p>
<p><em>Wait...that can't be right. If you can take a list of <code>Animal</code>, why don't you just SAY that? what's wrong with just <code>takeThing(ArrayList&lt;Animal&gt; list)</code></em>?</p>
</blockquote>
<p>这个：</p>
<pre><code class="language-java">public &lt;T extends Animal&gt; void takeThing(ArrayList&lt;T&gt; list)
</code></pre>
<p>与下面这个 <strong>并不</strong> 一样：</p>
<pre><code class="language-java">public void takeThing(ArrayList&lt;Animal&gt; list)
</code></pre>
<p>这两个都是合法的，但他们是 <em>不一样的</em>！</p>
<p>第一个，其中的 <code>&lt;T extends Animal&gt;</code> 是方法声明的组成部分，表示了所有声明了类型为 <code>Animal</code> 或 <code>Animal</code>的子类型（比如<code>Dog</code> 或 <code>Cat</code>） 的 <code>ArrayList</code>, 都是合法的。那么就可以使用 <code>ArrayList&lt;Dog&gt;</code>、<code>ArrayList&lt;Cat</code> 或 <code>ArrayList&lt;Animal</code>，来运行上面的那个方法。</p>
<p>然而......对于下面的那个方法，其中的方法参数（<code>ArrayList&lt;Animal&gt;</code>）则表示，<em>只有</em> <code>ArrayList&lt;Animal&gt;</code> 是合法的。也就是说，相比于头个版本取任何<code>Animal</code>类型（<code>Animal</code>、<code>Dog</code>、<code>Cat</code>等待）的 <code>ArrayList</code>，这第二个版本，就 <em>只会</em> 取类型为 <code>Animal</code> 的 <code>ArrayList</code>。不能取 <code>ArrayList&lt;Dog&gt;</code>，或 <code>ArrayList&lt;Cat&gt;</code>，只能是 <code>ArrayList&lt;Animal&gt;</code>。</p>
<p>同时这似乎确实会破坏多态机制的要素。在本章结束时再回头来看仔细回顾到这一点，就会更加清楚分明。至于现在，请记住由于此刻仍在致力于搞清楚怎样对那个 <code>SongList</code> 进行排序，而这又将我们带入了对有着奇怪的泛型声明 <code>sort()</code> 方法文档的审视，因此对于泛型与多态机制的关系，还只是点到为止的（And yes, it does appare to voilate the point of polymorphism. But it will become clare when we revisit this in detail at the end of the chapter. For now, remember that we're only looking at this because we're still trying to figure out how to <code>sort()</code> that <code>SongList</code>, and that led us into looking at the API for the <code>sort()</code> method, which had this strange generic type declaration）。</p>
<p><em><strong>此刻来讲，所要明白的，仅是上面那个版本是合法的，同时那意味着可将一个作为<code>Animal</code>或任何的<code>Animal</code>子类型的<code>ArrayList</code>传入进去</strong></em>。</p>
<p>那么现在就要回到那个 <code>sort()</code> 方法了......</p>
<h3 id="还记得前面中断的地方吧"><a class="header" href="#还记得前面中断的地方吧">还记得前面中断的地方吧......</a></h3>
<blockquote>
<p><em>这仍然解释不了为什么那个 <code>sort</code> 方法在 <code>Song</code> 的 <code>ArrayList</code> 上失效，而在 <code>String</code> 的 <code>ArrayList</code> 上没有问题</em>......</p>
</blockquote>
<h3 id="重新审视这个-sort-方法"><a class="header" href="#重新审视这个-sort-方法">重新审视这个 <code>sort()</code> 方法</a></h3>
<p>那么就来试着读读这个 <code>sort()</code> 方法的文档，找出为何他对字符串清单排序没有问题，而不能对 <code>Song</code> 对象清单进行排序。看起来答案似乎是......</p>
<p><img src="images/Ch16_09.png" alt="Java API - Collections.sort()" /></p>
<p><em>图 9 - Java API - <code>Collections.sort()</code></em></p>
<p><strong><code>sort()</code> 方法只能接收那些是 <code>Comparable</code> 对象的清单</strong>。</p>
<p><strong><code>Song</code> 不是 <code>Comparable</code> 的子类型，因此就不能对 <code>Song</code> 清单进行 <code>sort()</code></strong>。</p>
<p><strong>至少现在是不行的</strong>......</p>
<pre><code class="language-java">// 这里返回值前面声明的泛型参数，表示 “T” 必须是类型 Comparable。
//
// 请暂时忽略这里的 &lt;? super T&gt;。若真要问这是是什么，那么他表示
// Comparable 类的类型参数，必须是类型 T，或 T 的一个子类型。
//
// 后面的那个 &lt;T&gt;，表示了 sort 函数仅可传入一个使用了参数化的、“对Comparable
// 进行了扩展”的类型的清单（或清单的子类型，比如ArrayList）
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)
</code></pre>
<blockquote>
<p><em>嗯......我刚查看了一下 <code>String</code> 的文档，发现 <code>String</code> 并没有 <em>扩展</em> <code>Comparable</code> -- 他 <em>实现了</em> <code>Comparable</code>。</em></p>
<p><em><em><code>Comparable</code> 是个接口</em>。因此如果写 <code>T extends Comparable</code> 简直就是胡说八道</em>。</p>
</blockquote>
<p><img src="images/Ch16_10.png" alt="Java API - String" /></p>
<p><em>图 10 - Java API - <code>String</code></em></p>
<h3 id="在泛型语境下扩展-指的是-扩展或实现"><a class="header" href="#在泛型语境下扩展-指的是-扩展或实现">在泛型语境下，“扩展” 指的是 “扩展或实现”</a></h3>
<p><strong>In generics, <code>extends</code> means &quot;<code>extends</code> or <code>implements</code>&quot;</strong></p>
<p>Java 工程师们必须要给到一种在参数化类型上施加约束的方式，从而才能对这个参数化类型加以限制，比如仅那些 <code>Animal</code> 的子类。然而还会需要将某个类型，约束到仅允许实现了某个特定接口的那些类。因此，就会存在这样的情形，其中需要一种语法，来让上述两种条件生效--继承与实现。也就是说，一种可以同时工作于 <em>扩展</em> 和 <em>实现</em> 语法（The Java engineers had to give you a way to put a constaint on a parameterized type, so that you can restrict it to, say, only subclasses of <code>Animal</code>. But you also need to constrain a type to allow only classes that implement a particular inteface. So here's a situation where we need one kind of syntax to work for both situations -- inheritance and implementation. In other words, that works for both <code>extends</code> and <code>implements</code>）。</p>
<p>而胜出的词语就是...... <code>extends</code>。不过他所表达的真正意思是 <code>is-a</code>，且不管他右边的类型是接口还是类，<code>extends</code>都是有效的（And the winning word was... <code>extends</code>. But it really means <code>is-a</code>, and works regardless of whether the type on the right is an interface or a class）。</p>
<blockquote>
<p><em><strong>在泛型中，关键字<code>extends</code>的意思就是 <code>is-a</code>，并同时对类和接口生效</strong></em>。</p>
<p><em><strong>In generics, the keyword <code>extends</code> really means <code>is-a</code>, and works for BOTH classes and interfaces</strong></em>.</p>
</blockquote>
<pre><code class="language-java">// Comparable 是个接口，因此这里实际上应该读作，“T 必须是一个实现
// 了 Comparable 接口的类型”。
//
// extends 右边的那个，具体是个类还是接口并不重要......这里总是要写
// extends。
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)
</code></pre>
<h3 id="答疑-23"><a class="header" href="#答疑-23">答疑</a></h3>
<ul>
<li><strong>为啥 Java 工程师们不造一个新关键字，<code>is</code></strong>?</li>
</ul>
<blockquote>
<p>由于往语言添加一个新关键字，破坏了以较早版本编写Java代码，因此这样做是件相当大的事情。请设想一下 -- 可能使用了一个变量<code>is</code>（本书中确实使用了这个变量来表示输入流）。而由于将关键字用作代码标识符是不被允许的，那就意味着在这个关键字成为保留字之前，全部将其用作变量标识符的那些代码，就会失效。因此只要 Sun 公司的工程师有机会重用一个既有关键字，就比如这里的 <code>extends</code>，他们通常会选择重用这个既有关键字。然而这些工程师有时候别无选择......</p>
<p>少数（极少）关键字就已被添加到这门语言了，比如在 Java 1.4 中的 <code>assert</code> 及 Java 1.5 中的 <code>enum</code>（附录就会讲到<code>enum</code>）。而这样做并不会破坏人们的代码，尽管有时会选择 <em>新</em> 版本的Java来编译和运行，那么这些代码就会跟较旧版本的Java下表现得一样。通过在命令行给编译器或JVM传递一个特别参数，比如，“是的，是的，我知道这是 Java 1.4，但请假装成 1.3， 因为在我的代码中使用了名为 <em>assert</em> 的变量，我之所以这样写，是因为你们这些Java工程师早先说这样写是没问题的......”，就可以实现此目的。</p>
<p>（可通过在命令行敲入 <code>javac</code> （对于编译器）或 <code>java</code> （对于 JVM），其后不带任何东西，来检查这样的命令参数是否可用，随后就可以看到一个可用选项清单。关于这些 <code>javac</code> 及 <code>java</code> 命令的参数选项，在后面的部署章节会涉及。）</p>
</blockquote>
<h3 id="终于知道哪里错了那个-song-类需要实现-comparable"><a class="header" href="#终于知道哪里错了那个-song-类需要实现-comparable">终于知道哪里错了......那个 <code>Song</code> 类需要实现 <code>Comparable</code></a></h3>
<p>只有在 <code>Song</code> 类实现了 <code>Comparable</code> 时，才能把那个 <code>ArrayList&lt;Song&gt;</code> 传递给那个 <code>sort()</code> 方法，这是由于 <code>sort()</code> 方法被声明的方式决定的。快速查看一下 API 文档，就会发现 <code>Comparable</code> 接口是相当简单的，只有一个方法要实现：</p>
<pre><code class="language-java">// java.lang.Comparable
public interface Comparable &lt;T&gt; {
 int compareTo(T o);
}
</code></pre>
<p>而这个<code>compareTo()</code>方法的文档，又讲到：</p>
<pre><code class="language-console">Returns:

a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.
</code></pre>
<blockquote>
<p><strong>关键在于：到底是什么让一首歌曲小于、等于，或者大于另一首歌曲</strong>？</p>
<p><strong>在没有搞清楚这个问题之前，是无法实现这个 <code>Comparable</code> 接口的</strong>。</p>
</blockquote>
<p>看起来似乎这个 <code>compareTo()</code> 方法将在某个 <code>Song</code> 对象上调用，将另一个对象的索引，传递给那个 <code>Song</code> 对象。运行<code>compareTo()</code>方法的那个对象，必须得出传递给他的那个<code>Song</code>，在清单中是要排在他自己前面、后面，还是与他一样的位置。</p>
<p>现在首要工作，就是确定是什么使得一首歌曲高于另一歌曲，然后实现这个<code>compareTo()</code>方法来反应这一点。负数（任何负数）意味着被传递的 <code>Song</code> 对象高于运行此方法的<code>Song</code>对象。返回一个正数，则表明运行此方法的<code>Song</code>对象，高于传递给<code>compareTo()</code>方法的<code>Song</code>对象。返回零意味着这两个<code>Song</code>对象相等（至少在排序上来说是相等的......但不表示他们是同样的对象）。或许，有着两首标题相同的歌曲呢。</p>
<p>（后面就会看到，这将带来非常多的可能......Which brings up a whole different can of worms we'll look at later...）</p>
<blockquote>
<p>动手写代码
请写下你的想法和实现这个将按照歌曲标题，对这些<code>Song</code>对象进行排序的<code>compareTo()</code> 方法伪代码（或者更佳的是写出具体代码）。</p>
<p>提示：在循着正轨的情形下，代码将少于 3 行！</p>
</blockquote>
<h3 id="新的改进过的可比较的-song-类"><a class="header" href="#新的改进过的可比较的-song-类">新的、改进过的、可比较的 <code>Song</code> 类</a></h3>
<p><strong>The new, improved, comparable <code>Song</code> class</strong></p>
<p>这里决定希望以歌曲标题来排序，你们就要将 <code>compareTo()</code>方法实现为，把传递给这个方法的<code>Song</code>的标题，与运行这个<code>compareTo()</code>方法的<code>Song</code>对象的标题进行比较。也就是说，运行这个方法的<code>Song</code>对象必须判断出他的标题，与该方法参数的<code>Song</code>对象标题相比起来如何。</p>
<p>嗯......既然这个<code>Collections.sort()</code>方法在<code>String</code>类型的清单上是生效的，那么就知道 <code>String</code> 类一定是清楚字母排序的。我们又知道 <code>String</code> 类有一个 <code>compareTo()</code> 方法，那为什么不调用这个方法呢？那样的话，就可以简单地拿一个歌曲标题的字符串，将其自己和另一个歌曲标题比较就行了，还避开了比较，或者说字母排序算法呢！</p>
<pre><code class="language-java">// 通常前一个 Song 与 Comparable&lt;T&gt; 中的 Song 是匹配的......这里
// 指定了实现 Comparable 接口类可与之比较的类型。
//
// 这表示为排序目的， Song 对象可与其他 Song 对象比较。
class Song implements Comparable&lt;Song&gt; {

    private String title;
    private String artist;
    private String rating;
    private String bpm;

    Song (String t, String a, String r, String b) {
        title = t;
        artist = a;
        rating = r;
        bpm = b;
    }

    // Collections.sort() 方法，会将一个 Song 对象，发送给 compareTo()
    // 方法，来查看那个 Song 对象与运行这个方法的 Song 相比会怎样。
    //
    // 很简单！由于知道 String 有一个 compareTo() 方法，因此
    // 这里只要把比较工作，传递给歌曲标题的 String 对象即可。
    public int compareTo(Song s) {
        return title.compareTo(s.getTitle());
    }

    public String getTitle () {
        return title;
    }

    public String getArtist () {
        return artist;
    }

    public String getRating () {
        return rating;
    }

    public String getBpm () {
        return bpm;
    }

    public String toString () {
        return String.format(&quot;%s - %s&quot;, title, rating);
    }
}
</code></pre>
<p>现在，这个 <code>JukeBox3</code> 程序就工作了。他会打印出这个清单，随后调用 <code>Collections.sort()</code>，这个方法会将这些歌曲，按照歌曲标题的字母顺序排序。</p>
<p><img src="images/Ch16_11.png" alt="新的、改进后的可比较 Song 类" /></p>
<p><em>图 11 - 新的、改进后的可比较<code>Song</code>类</em></p>
<h3 id="这里能够对清单排序了然而"><a class="header" href="#这里能够对清单排序了然而">这里能够对清单排序了，然而......</a></h3>
<p>有了个新问题 -- 楼老板要的是这个歌曲清单的两种不同视图，一个以歌曲标题排序，一个以歌曲的艺人排序！</p>
<p>但是在令到集合元素可比较（通过让<code>Song</code>类实现 <code>Comparable</code> 接口）时，只有一次机会来实现那个<code>compareTo()</code>方法。那么能做些什么呢？</p>
<p>糟糕的做法，就是可以在 <code>Song</code> 类里头使用一个标志变量（a flag variable），然后在 <code>compareTo()</code> 中执行一个 <code>if</code> 测试，并根据这个标志变量是被设置为使用歌曲标题，还是歌曲艺人进行比较，而给出不同结果。</p>
<p>然而那是个可怕又脆弱的办法，并且有更佳的做法。在希望对同一事物按多种方式排序时，有API内建的东西来实现此目的。</p>
<p><strong>来再看看 <code>Collections</code> 类的文档。那里有另外一个过载的<code>sort()</code>方法（a overloaded <code>sort()</code> method） -- 这个会取一个 <code>Comparator</code> 类型的参数</strong>。</p>
<pre><code class="language-java">public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)
</code></pre>
<blockquote>
<p><em>这个 <code>sort()</code> 方法，是过载来取得一个叫做 <code>Comparator</code> 的参数的</em>。</p>
<p>提醒一下：请想想该怎样得到/构造出一个可对这些歌曲按照艺人而非歌曲标题进行排序的 <code>Comparator</code> 来。</p>
</blockquote>
<h3 id="使用定制的-comparator"><a class="header" href="#使用定制的-comparator">使用定制的 <code>Comparator</code></a></h3>
<p>清单中的元素，可将其 <em>自身</em> 与他类型的另一元素，使用他的<code>compareTo()</code>方法以某种方式进行比较。但 <code>Comparator</code> 相对于这个元素的类型，是外部的东西--<code>Comparator</code>是个单独类。那么想要构造多少个 <code>Comparator</code> 类都可以！要以歌曲艺人来比较歌曲？那么就构造一个<code>ArtistComparator</code>类。要按照每分钟节拍数来比较？就构造一个 <code>BPMComparator</code>类。</p>
<pre><code class="language-java">// java.util.Comparator
public interface Comparator&lt;T&gt; {
    int compare(T o1, T o2);
}
</code></pre>
<blockquote>
<p><em><strong>在将一个 <code>Comparator</code> 传递给这个 <code>sort()</code> 方法时，排序就由这个<code>Comparator</code>，而不是元素本书的 <code>compareTo()</code> 方法来确定了</strong></em>。</p>
</blockquote>
<p>然后只需调用那个过载的、取 <code>List</code> 及帮助将清单中物件进行排序的 <code>sort()</code> 就可以了。</p>
<p>取了 <code>Comparator</code> 参数的 <code>sort()</code> 方法，在将那些元素进行排序时，将使用这个 <code>Comparator</code> 参数，而不是元素本身的 <code>compareTo()</code> 方法。也就是说，在<code>sort()</code>方法获得了一个 <code>Comparator</code>时，这个方法就不会 <em>调用（call）</em> 那些清单中元素的 <code>compareTo()</code> 方法了。相反，这个<code>sort()</code>方法，会 <em>运行（invoke）</em> <code>Comparator</code> 上的 <strong><code>compare()</code></strong> 方法。</p>
<p>因此，有下面的规则：</p>
<ul>
<li>
<p><strong>运行单个参数的 <code>sort(List o)</code> 方法，表示清单元素的 <code>compareTo()</code> 方法决定了排序顺序。因此清单中那些元素，必须要实现 <code>Comparable</code> 接口</strong>。</p>
</li>
<li>
<p><strong>运行过载的 <code>sort(List o, Comparator c)</code></strong> 表示清单元素的<code>compareTo()</code>方法不会被调用，而将使用这个 <code>Comparator</code> 的 <code>compare()</code> 方法。那就意味着清单中的元素，没有必要取实现 <code>Comparable</code> 接口***。</p>
</li>
</ul>
<h3 id="答疑-24"><a class="header" href="#答疑-24">答疑</a></h3>
<ul>
<li><strong>那么这意味着在某个类没有实现 <code>Comparable</code>，且没有源代码的情况下，仍然可以通过构造一个 <code>Comparator</code>，将这个类类型的物件进行排序了吗</strong>？</li>
</ul>
<blockquote>
<p>对的，可以那样做。另一个选项（在可行的情况下）则是对这个类进行子类化，而让子类去实现 <code>Comparable</code> 接口。</p>
</blockquote>
<ul>
<li><strong>那为什么不是 <em>每个</em> 类都实现 <code>Comparable</code> 接口</strong>？</li>
</ul>
<blockquote>
<p>你真的以为 <em>万事万物</em> 皆可排序？在有着一些不以任何自然方式排序的元素类型时，这个时候如果实现了 <code>Comparable</code> 接口，那么就会误导别的程序员了。且由于某位程序员可以他自己的定制 <code>Comparator</code>，来以他选择的方式加以比较，所以即使没有实现 <code>Comparable</code>接口，也不会有什么大的风险。</p>
</blockquote>
<h3 id="将-jukebox-更新为使用-comparator"><a class="header" href="#将-jukebox-更新为使用-comparator">将 <code>JukeBox</code> 更新为使用 <code>Comparator</code></a></h3>
<p>这个代码中完成了三个新东西：</p>
<ol>
<li>
<p>创建了一个实现 <code>Comparator</code> 的内部类（进而因此那个<code>compare()</code>方法会完成之前由<code>compareTo()</code>方法完成的工作）；</p>
</li>
<li>
<p>构造了这个 <code>Comparator</code> 内部类的实例；</p>
</li>
<li>
<p>调用了那个过载的 <code>sort()</code> 方法，同时给到他歌曲清单与这个 <code>Comparator</code> 内部类的实例。</p>
</li>
</ol>
<p>请注意：这里还更新了这个 <code>Song</code> 类的 <code>toString()</code> 方法，以同时打印出歌曲标题与艺人。（不管清单如何排序，新 <code>toString()</code> 方法都会打印出 <code>title: artist</code>。）</p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;
import java.io.*;
import com.xfoss.Utils.XPlatformThings;

public class JukeBox4 {

    // 这里将这个 ArrayList 从 String 修改为了 Song 对象。
    ArrayList&lt;Song&gt; songList = new ArrayList&lt;Song&gt; ();
    String wDir = XPlatformThings.getWorkingDir(&quot;learningJava&quot;);

    public JukeBox4 () {
        getSongs();
        System.out.println(songList);

        Collections.sort(songList);
        System.out.println(songList);

        // 这里构造了那个 Comparator 内部类的一个实例。
        ArtistCompare artistCompare = new ArtistCompare();
        // 这里运行了 sort() 方法，传递给他了这个歌曲清单和到上面新的定制
        // Comparator 类型的一个对象。
        Collections.sort(songList, artistCompare);
        System.out.println(songList);
    }

    public static void main(String[] args){
        new JukeBox4();
    }

    // 这里创建了一个新的、实现 Comparator 的内部类（请留意他的类型参数是与即将
    // 比较的 -- 即这个实例中的 Song 的那些对象）是一致的。
    class ArtistCompare implements Comparator&lt;Song&gt; {
        public int compare(Song one, Song two) {
            // 这里的 one.getArtist() 将成为一个字符串（即歌曲艺人）
            //
            // 由于字符串本身已经知道他们该怎样按字母排序，因此这里是
            // 让这两个字符串变量（表示歌曲艺人）执行的具体比较。
            return one.getArtist().compareTo(two.getArtist());
        }
    }

    void getSongs() {
        try {
            File file = new File(String.format(&quot;%s/SongListMore.txt&quot;, wDir));
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String line = null;
            while ((line = reader.readLine()) != null) {
                addSong(line);
            }
        } catch (IOException ex) {ex.printStackTrace();}
    }

    void addSong(String lineToParse) {

        // 这里使用四个令牌（也就是歌曲文件中这一行的四个信息片段）创建
        // 出一个新的 Song 对象，并将该 Song 对象添加到那个清单。
        String [] tokens = lineToParse.split(&quot;/&quot;);

        Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);
        songList.add(nextSong);
    }
}
</code></pre>
<p><img src="images/Ch16_12.png" alt="java.util.Comparator 接口的引入" /></p>
<p><em>图 12 - <code>java.util.Comparator</code> 接口的引入</em></p>
<blockquote>
<p>请注意：通过保留先前在 <code>Song</code> 类中的 <code>compareTo()</code> 方法，这里仍将按歌曲标题排序作为了默认排序。另一种实现这两种排序的方法，就是同时将歌曲标题排序和艺人排序，以<code>Comparator</code>内部类的方式加以实现，从而完全不让 <code>Song</code> 去实现 <code>Comparable</code>接口。那就意味着全都要使用两参数版本的 <code>Collections.sort()</code>。</p>
</blockquote>
<h3 id="动手写代码"><a class="header" href="#动手写代码">动手写代码</a></h3>
<pre><code>package com.xfoss.CollectionAndGenerics;

import java.io.*;
import java.util.*;

public class SortMountains {
    LinkedList&lt;Mountain&gt; mtn = new LinkedList&lt;Mountain&gt; ();

    class NameCompare implements Comparator&lt;Mountain&gt; {
        public int compare (Mountain one, Mountain two) {
            return one.getName().compareTo(two.getName());
        }
    }

    class HeightCompare implements Comparator&lt;Mountain&gt; {
        public int compare (Mountain one, Mountain two) {
            return one.getHeight() - two.getHeight();
        }
    }

    public SortMountains () {
        mtn.add(new Mountain(&quot;Longs&quot;, 14255));
        mtn.add(new Mountain(&quot;艾伯特&quot;, 14433));
        mtn.add(new Mountain(&quot;玛努恩&quot;, 14156));
        mtn.add(new Mountain(&quot;Castle&quot;, 14265));

        System.out.format(&quot;输入的是：\n%s\n&quot;, mtn);

        NameCompare nc = new NameCompare();
        Collections.sort(mtn, nc);
        System.out.format(&quot;依名称排序：\n%s\n&quot;, mtn);

        HeightCompare hc = new HeightCompare();
        Collections.sort(mtn, hc);
        System.out.format(&quot;依高度排序：\n%s\n&quot;, mtn);
    }

    public static void main (String[] args) {
        new SortMountains();
    }
}

class Mountain {
    private String name;
    private int height;

    public String getName () {
        return name;
    }

    public int getHeight () {
        return height;
    }

    public Mountain (String n, int h) {
        name = n;
        height = h;
    }

    public String toString () {
        return String.format(&quot;%s: %d&quot;, name, height);
    }
}
</code></pre>
<p><img src="images/Ch16_13.png" alt="SortMountains" /></p>
<p><em>图 13 - <code>SortMountains</code></em></p>
<h3 id="好耶排序全都工作起来了不过现在有些重复的元素"><a class="header" href="#好耶排序全都工作起来了不过现在有些重复的元素">好耶。排序全都工作起来了，不过现在有些重复的元素......</a></h3>
<p>排序已经运作得相当好了，现在已经掌握了怎样同时以 <em>歌曲标题</em> （使用那些 <code>Song</code> 对象的 <code>compareTo()</code> 方法）和 <em>歌曲艺人</em>（使用<code>Comparator</code>类的 <code>compare()</code> 方法）进行排序。然而这里有个之前未曾注意到的、那个自动点唱机文本文件中的新问题 -- <em><strong>排序后的清单中包含了重复元素</strong></em>。</p>
<p>看起来不论同一首歌是否已经被播放（并由此已被写入）到那个文本文件，那台晚餐点唱机都在持续地往那个文件写入。这个 <code>SongListMore.txt</code> 的点唱机文件，是已被播放过的全部歌曲的完整记录，并且有可能多次包含了同一首歌曲。</p>
<pre><code class="language-console">// SongListMore.txt
Pink Moon/Nick Drake/5/80
Somersault/Zero 7/4/84
Shiva Moon/Prem Joshua/6/120
Circles/BT/5/110
爱你一万年/Andy LAU/5/142
Deep Channel/Afro Celts/4/120
Passenger/Headmix/4/100
Listen/Tahiti 80/5/90
Listen/Tahiti 80/5/90
Listen/Tahiti 80/5/90
Circles/BT/5/110
</code></pre>
<blockquote>
<p><em>现在由于自动点唱机正依序持续写入其所播放的每首歌曲，因此这个 <code>SongListMore</code> 的文本文件中，就有了重复项目。有人曾决定连续播放了三次 &quot;Listen&quot; 那首歌，接着又播放了 “Circles” 那首早先曾被播放的歌曲</em>。</p>
<p><em>因为有时会需要文本文件的全部信息，因此这里无法改变文本文件被写入的方式。那么就只有对 Java 代码进行修改了</em>。</p>
</blockquote>
<h2 id="这里要的是-set-而不再是-list-了"><a class="header" href="#这里要的是-set-而不再是-list-了">这里要的是 <code>Set</code> 而不再是 <code>List</code> 了</a></h2>
<p>从 <code>Collection</code> 的API文档，可以找出三个主要的接口，分别是**<code>List</code><strong>、</strong><code>Set</code>** 与 <strong><code>Map</code></strong>。<code>ArrayList</code> 是一种 <code>List</code>，但似乎 <em><code>Set</code></em> 才是这里所需要的。</p>
<ul>
<li>
<p><strong>清单（LIST）</strong> - 用在顺序为要的时候（when <em>sequence</em> matters）</p>
<p>是那些掌握了 <em><strong>索引位置</strong></em> 的集合（Collections that know about <em><strong>index position</strong></em>）。</p>
<p>清单对某个元素在清单中的位置有所掌握。多个元素可引用同一对象（Lists know where something is in the list. You can have more than one element referencing the same object）。</p>
</li>
</ul>
<p><img src="images/Ch16_14.png" alt="LIST 图解" /></p>
<p><em>图 14 - <code>LIST</code> 图解</em></p>
<ul>
<li>
<p><strong>数据集（SET）</strong> - 用在独特性为要的时候（when <em>uniqueness</em> matters）</p>
<p>是那些 <em><strong>不允许重复元素出现</strong></em> 的集合（Collections tht <em><strong>do not allow duplicates</strong></em>）。</p>
<p>数据集知道哪些元素已经是在集合中了（<code>Set</code>s know whether something is already in the collection）。</p>
<p>在数据集中，是绝不可能有多个元素对同一对象进行引用的（或者多个元素引用被认为是相等的两个对象 -- 后面就会涉及何为对象相等的概念）。</p>
</li>
</ul>
<p><img src="images/Ch16_15.png" alt="数据集 Set" /></p>
<p><em>图 15 - 数据集 <code>Set</code></em></p>
<ul>
<li>
<p><strong>映射（MAP）</strong> - 用在要通过键来找到某个物件时（when <em>finding something by key</em> matters）</p>
<p>用到 <em><strong>键-值对</strong></em> 的集合（Collections that use <em><strong>key-value pairs</strong></em>）。</p>
<p>映射知悉值是与给定的键关联起来的。两个键可以引用同样的值，但不能有重复的键。尽管这些键通常都是<code>String</code> 类类型的名字（因此就可以构造出比如名称/值这样的一些清单），但键也可以是别的对象。</p>
</li>
</ul>
<p><img src="images/Ch16_16.png" alt="映射Map" /></p>
<p><em>图 16 - 映射 <code>Map</code></em></p>
<h3 id="collection-的api文档部分"><a class="header" href="#collection-的api文档部分"><code>Collection</code> 的API文档（部分）</a></h3>
<p>请注意虽然 <code>Map</code> 接口并没有真正对 <code>Collection</code> 接口进行扩展，但<code>Map</code>仍被看着是 “集合框架（Collection Frame）”（也被成为“集合API（Collections API）”）的一部分。因此即便映射没有将 <code>java.util.Collection</code> 包含在他们的继承树中，他们也仍然是集合。</p>
<p>（请注意：下面的图并非整个的集合 API；还有一些其他的类和接口，不过列出来的是我们最为关心的一些。）</p>
<p><img src="images/Ch16_17.png" alt="Collection 继承树（部分）" /></p>
<p><em>图 17 - <code>Collection</code> 继承树（部分）</em></p>
<p><img src="images/Ch16_18.png" alt="键（KEY）" /></p>
<p><em>图 18 - 键（KEY）</em></p>
<p><img src="images/Ch16_19.png" alt="映射（Map）继承树" /></p>
<p><em>图 19 - 映射（<code>Map</code>）继承树</em></p>
<h3 id="使用-hashset而不再是-arraylist"><a class="header" href="#使用-hashset而不再是-arraylist">使用 <code>HashSet</code>而不再是 <code>ArrayList</code></a></h3>
<p>这里给 <code>JukeBox</code> 程序进行了增补，把这些歌曲放入到一个 <code>HashSet</code> 中。（请注意：这里省去了一些 <code>JukeBox</code> 的代码，省去的代码可从先前版本中拷出来。而为了更容易的查阅输出，这里也对先前版本的 <code>Song</code> 类中的 <code>toString()</code> 方法进行了修改，让其只输出歌曲标题，而不再同时输出歌曲标题 <em>和</em> 艺人。）</p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;
import java.io.*;
import com.xfoss.Utils.XPlatformThings;

public class JukeBox6 {

    // 这里将这个 ArrayList 从 String 修改为了 Song 对象。
    ArrayList&lt;Song&gt; songList = new ArrayList&lt;Song&gt; ();
    String wDir = XPlatformThings.getWorkingDir(&quot;learningJava&quot;);

    public JukeBox6 () {
        getSongs();
        System.out.format(&quot;原本的 songList: \n%s\n&quot;, songList);

        Collections.sort(songList);
        System.out.format(&quot;排序后的 songList: \n%s\n&quot;, songList);

        // 在这里，创建了一个新的参数化的 HashSet，来存储那些歌曲。
        HashSet&lt;Song&gt; songSet = new HashSet&lt;Song&gt; ();
        // HashSet 有着一个简单的 addAll() 方法，可取得另一集合并运用该
        // 集合来生成这个 HashSet. 他跟每次添加一个`Song`对象是同样得（
        // 只是更简单了）。
        songSet.addAll(songList);
        System.out.format(&quot;作为 HashSet 的 songSet: \n%s\n&quot;, songSet);
    }

    public static void main(String[] args){
        new JukeBox6();
    }

    class ArtistCompare implements Comparator&lt;Song&gt; {
        public int compare(Song one, Song two) {
            return one.getArtist().compareTo(two.getArtist());
        }
    }

    class TitleCompare implements Comparator&lt;Song&gt; {
        public int compare (Song one, Song two) {
            return one.getTitle().compareTo(two.getTitle());
        }
    }

    void getSongs() {
        try {
            File file = new File(String.format(&quot;%s/SongListMore.txt&quot;, wDir));
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String line = null;
            while ((line = reader.readLine()) != null) {
                addSong(line);
            }
        } catch (IOException ex) {ex.printStackTrace();}
    }

    void addSong(String lineToParse) {

        // 这里使用四个令牌（也就是歌曲文件中这一行的四个信息片段）创建
        // 出一个新的 Song 对象，并将该 Song 对象添加到那个清单。
        String [] tokens = lineToParse.split(&quot;/&quot;);

        Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);
        songList.add(nextSong);
    }
}
</code></pre>
<p><img src="images/Ch16_20.png" alt="引入HashSet后的 JukeBox 运行结果" /></p>
<p><em>图 19 - 引入<code>HashSet</code>后的 <code>JukeBox</code> 运行结果</em></p>
<blockquote>
<p><em>看来 <code>Set</code> 并没有什么帮助啊！这里仍然有那些全部的重复元素</em>！</p>
<p>（<em>并且在把那个清单放入到 <code>HashSet</code> 中去时，还把顺序给搞没了，尽管后面会再去管这个顺序的事情</em>......）</p>
</blockquote>
<h3 id="哪些东西会造成两个对象相等"><a class="header" href="#哪些东西会造成两个对象相等">哪些东西会造成两个对象相等？</a></h3>
<p><strong>What makes two objects equal</strong>?</p>
<p>首先，就必须要问这个问题 -- 什么会造成两个 <code>Song</code> 的引用变量重复？答案就是他们必须是 <em><strong>相等的</strong></em>。这两个引用变量是简单地指向完全是同一个对象？还是两个单独对象只是有着同样 <em>标题</em> 而已呢？</p>
<p>这就引出了一个关键的话题：<em>引用</em> 等价与 <em>对象</em> 等价（<em>reference</em> equality vs. <em>object</em> equality）。</p>
<blockquote>
<p><strong>再两个对象 <code>foo</code> 和 <code>bar</code> 相等时，那么 <code>foo.equals(bar)</code> 就一定是 <code>true</code>，且 <code>foo</code> 和 <code>bar</code> 的 <code>hashCode()</code> 方法返回值一定会返回同样的值。要让数据集<code>Set</code>将两个对象视为重复，那么就必须重写继承自类 <code>Object</code> 的 <code>hashCode()</code> 和 <code>equals()</code> ** 方法，如此就可以让两个不同的对象，被视为相等</strong>。</p>
</blockquote>
<ul>
<li>
<p><strong>引用变量（Reference）等价</strong></p>
<p><strong>两个引用变量，对应内存堆上一个对象</strong>。</p>
<p>两个引用了内存堆上同一对象的引用变量，是相等的。这一点无可置疑。当于这两个引用变量上同时调用 <strong><code>hashCode()</code></strong>，会得到同样结果。在没有重写 <code>hashCode()</code> 方法时，这个方法的默认行为（请记住，这个方法是从类 <code>Object</code> 继承到的），即为每个对象将获取到一个唯一编号（多数版本的Java，都会给每个对象根据其在内存堆上的内存地址，而指派给各个对象一个哈希编码，因此不会有两个对象有同样的哈希编码）。</p>
<p>在想要知道两个引用变量是否引用了同一对象时，就要使用 <code>==</code> 运算符，这个运算符（请记住）比较的是变量中的二进制位。在两个引用变量都指向同一对象时，他们的二进制位是一致的。</p>
</li>
</ul>
<p><img src="images/Ch16_21.png" alt="引用变量（Reference） 相等" /></p>
<p><em>图 21 - 引用变量（Reference） 相等</em></p>
<ul>
<li>
<p><strong>对象（Object）等价</strong></p>
<p><strong>两个引用变量，分别指向内存堆上的两个对象，但这两个对象被认为是 <em>具有等同的意义（meaningfully equivalent）</em></strong>。</p>
<p>在希望将两个不同<code>Song</code>对象视为相等（比如决定了在两首歌曲同时有着一致的 <em>标题</em> 变量时），那么就必须 <em>同时</em> 重写从类 <code>Object</code> 继承的 <strong><code>hashCode()</code></strong> 和 <strong><code>equals()</code></strong> 两个方法。</p>
<p>就如同上面所讲的，若没有重写 <code>hashCode()</code>，那么对象默认行为（来自 <code>Object</code> 类）就要给各个对象一个独特的哈希编码值。因此为确保两个等价对象返回同样哈希编码，就必须重写 <code>hashCode()</code> 方法。若要在 <em>两个</em> 对象上都调用 <code>equals()</code>，就还必须重写这个 <code>equals()</code> 方法，在传递给他另一对象时，总是让其返回 <code>true</code> 。</p>
</li>
</ul>
<p><img src="images/Ch16_22.png" alt="对象（Object）相等" /></p>
<p><em>图 22 - 对象（Object）相等</em></p>
<h3 id="hashset-检查重复的机制hashcode-与-equals"><a class="header" href="#hashset-检查重复的机制hashcode-与-equals"><code>HashSet</code> 检查重复的机制：<code>hashCode()</code> 与 <code>equals()</code></a></h3>
<p>在将对象放入到某个 <code>HashSet</code> 中时，就会使用该对象的哈希编码值，来判断把这个对象放在该数据集的何处。同时还会将该对象的哈希编码，与当前 <code>HashSet</code> 中全部其他对象的哈希编码进行比较，并在没有匹配的哈希编码时，这个 <code>HashSet</code> 就假定这个新的对象，不重复。</p>
<p>也就是说，只要那些哈希编码各不相同，那么这个 <code>HashSet</code> 就假定这些对象不会相等！</p>
<p>因此就必须重写 <code>hashCode()</code>，已确保这些对象，都有相同的值。</p>
<p>然而两个有着同样 <code>hashCode()</code> 的对象，却又可能 <em>不</em> 相等（稍后就会讨论到这个问题），因此在 <code>HashSet</code> 找到两个哈希编码匹配的对象 -- 一个是正要插入的，另一个是已在这个数据集中的 -- 那么这时 <code>HashSet</code> 就会调用对象上的 <code>equals()</code> 方法之一，来检查这两个哈希编码一致的对象，是否真正 <em>是</em> 相等的。</p>
<p>而在他们相等时，<code>HashSet</code>就知道，尝试添加的对象是数据集中某个对象的重复，因此这个添加就不会发生了。</p>
<p>此时是收不到异常的，但<code>HashSet</code>类型的 <code>add()</code> 方法会返回一个布尔值，告知（在关切时）这个新对象是否已被添加。因此如果这个 <code>add()</code> 方法返回了 <code>false</code>，那么就知道这个新对象，就是数据集中已有的某个对象的重复。</p>
<p><img src="images/Ch16_23.png" alt="对象重复检查机制：hashCode() 与 equals()" /></p>
<p><em>图 23 - 对象重复检查机制：<code>hashCode()</code> 与 <code>equals()</code></em></p>
<h3 id="重写了-hashcode-与-equals-方法的song类"><a class="header" href="#重写了-hashcode-与-equals-方法的song类">重写了 <code>hashCode()</code> 与 <code>equals()</code> 方法的<code>Song</code>类</a></h3>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;
import java.io.*;

public class Song implements Comparable&lt;Song&gt; {

    // 这四个实例变量表示文件中的四个歌曲属性。
    private String title;
    private String artist;
    private String rating;
    private String bpm;

    // 这些变量都是在新的 Song 对象被创建时，在构造器中设置的。
    Song (String t, String a, String r, String b) {
        title = t;
        artist = a;
        rating = r;
        bpm = b;
    }

    public int compareTo(Song s) {
        return title.compareTo(s.getTitle());
    }

    // 这些是四个属性的获取器方法。
    public String getTitle () {
        return title;
    }

    public String getArtist () {
        return artist;
    }

    public String getRating () {
        return rating;
    }

    public String getBpm () {
        return bpm;
    }

    // 由于在执行 System.out.println(aSongObject)时，希望看到歌曲标题，因此
    //  这里重写了 toString() 方法。在执行 System.out.println(aListOfSongs) 
    //  时，就会调用清单中各个元素的这个 toString() 方法。
    public String toString () {
        return title;
    }

    // HashSet（或者别的其他会调用到此方法的东西） 会将这里的
    // 参数 Object aSong（），发送给另一 `Song` 对象。
    //
    // 好消息是歌曲标题是个 `String`，而字符串是有一个重写的 equals() 
    // 方法的。因此这里只要询问一个标题，他是否与另外一个标题相等即可。
    public boolean equals(Object aSong) {
        Song s = (Song) aSong;
        return getTitle().equals(s.getTitle());
    }

    // 这里采取了与上面同样的处理......`String` 类已有一个重写的 hashCode() 
    // 方法，因此只要标题上调用 hashCode() 方法的返回值就行了。请
    // 注意这里的 hashCode() 与 equals() 是如何运用同一个实例变量。
    public int hashCode () {
        return title.hashCode();
    }
}
</code></pre>
<p><img src="images/Ch16_24.png" alt="修改 Song 类后的 HashSet 输出" /></p>
<p><em>图 24 - 修改 <code>Song</code> 类后的 <code>HashSet</code> 输出</em></p>
<blockquote>
<p><em>现在修改生效了！在打印输出那个 <code>HashSet</code> 时就不再有重复了。但这里并没有再次调用 <code>sort()</code> 方法，其在将那个 <code>ArrayList</code> 放到 <code>HashSet</code> 中时，那个<code>HashSet</code>并没有保留排序</em>。</p>
</blockquote>
<h3 id="java-对象-hashcode-与-equals-相关的法则"><a class="header" href="#java-对象-hashcode-与-equals-相关的法则">Java 对象 <code>HashCode()</code> 与 <code>equals()</code> 相关的法则</a></h3>
<p><strong>类 <code>Object</code> 的API文档，指明了以下必须遵守的法则</strong>：</p>
<ul>
<li><strong>在两个对象相等时，那么他们就肯定有着一致的哈希码</strong>；</li>
<li><strong>两个对象相等时，在二者之一的任何一个上调用 <code>equals()</code> 方法，肯定都会返回 <code>true</code>。也就是说，<code>if (a.equals(b)) then (b.equals(a))</code></strong>；</li>
<li><strong>两个对象有着同样哈希码是，他们不必相等。但如果他们相等，那么他们必定有着同样的哈希码</strong>；</li>
<li><strong>因此，在重写 <code>equals()</code> 方法时，就必须重写 <code>hashCode()</code></strong>;</li>
<li><strong><code>hashCode()</code> 的默认行为，是给内存堆上的每个对象生成一个唯一的整数。因此若没有重写类的 <code>hashCode()</code>，那么那个类类型下的两个对象，用于不会相等</strong>；</li>
<li><strong><code>equals()</code> 的默认行为，为执行一次 <code>==</code> 的比较。也就是说，要测试两个引用变量是否引用了内存堆上的同一个对象。因此在没有重写类中的 <code>equals()</code> 方法时，由于引用不同对象的引用变量总会包含不同的二进制位模式，那么这两个引用变量就绝不会被认为是相等的（The default behavior of <code>equals()</code> is to do an <code>==</code> comparison. In other words, to test whether the two references refer to a single object on the heap. So if you don't override <code>equals()</code> in a class, no two objects can EVER be considered equal since references to two different objects will always contain a different bit pattern）</strong>；</li>
</ul>
<p><strong><code>a.equals(b)</code> 必须同时意味着 <code>a.hashCode() == b.hashCode()</code></strong>。</p>
<p><strong>但 <code>a.hashCode() == b.hashCode()</code> 却并不一定表示 <code>a.equals(b)</code></strong>。</p>
<h3 id="答疑-25"><a class="header" href="#答疑-25">答疑</a></h3>
<ul>
<li><strong>既然两个对象不相等，他们的哈希码又怎么会相同呢</strong>？</li>
</ul>
<blockquote>
<p><code>HashSet</code> 使用哈希码，来以一种实现元素更快访问的方式存储这些元素。在通过将一个对象拷贝（与索引值相反）给到 <code>ArrayList</code>，来尝试从这个 <code>ArrayList</code> 里找到那个对象时，这个<code>ArrayList</code>就必须从其开头开始搜寻，逐个查看该清单中的每个元素，以检查是否与要查找的对象匹配。而由于 <code>HashSet</code> 使用哈希码作为存储其元素的“桶”上某种形式的标签，那么他就可以更加快速地找到某个对象。因此在讲到“我希望你找出这个数据集中与这个对象完全一样的那个对象......”时，<code>HashSet</code> 就会从这个给到他的 <code>Song</code> 对象拷贝，获取到一个哈希码取值（比如，<code>742</code>），随后这个 <code>HashSet</code> 就会说，“噢，我准确地知道带有哈希码<code>#742</code> 的那个对象存储在哪里了.......”，这个时候他就直接前往那个 <code>#742</code> 的桶那里了。</p>
<p>虽然这不是在计算机科学课程中学到的那么全，但对有效运用<code>HashSet</code>已经足够了。实际上，许多博士论文的题目，就是开发一种良好的哈希码算法，且比这本书想要要涵盖的内容还要多。</p>
<p>重点在于，由于在 <code>hashCode()</code> 中使用的“哈希算法”，可能发生多个对象返回同一个值的情况，因此哈希码无需在两个对象相等时，也可以相同。当然那就意味着这多个对象就会落在<code>HashSet</code>中的同一个桶上（因为每个桶表示的是单个哈希码值），但这并非世界末日。这可能意味着此 <code>HashSet</code> 并不那么高效而已（或者说该 <code>HashSet</code> 已填充了数量极为巨大的元素），而假如这个 <code>HashSet</code> 在同一哈希码桶中找到多个对象，此时这个 <code>HashSet</code> 就会直接使用 <code>equals()</code> 方法，来检查是否有一个完全匹配的对象。也就是说，哈希码值有时是用于缩小搜索范围，而不是用于找出那个准确匹配的对象，<code>HashSet</code> 仍然必须取得那个桶（即有着同样哈希值的对象所在的桶）中的全部对象，然后在这些对象上调用 <code>equals()</code> 方法，来检查他们是不是 <code>HashSet</code> 正在该桶中所要找的对象。</p>
</blockquote>
<h3 id="在希望数据集得以排序时就要用到-treeset"><a class="header" href="#在希望数据集得以排序时就要用到-treeset">在希望数据集得以排序时，就要用到 <code>TreeSet</code></a></h3>
<p><strong>And if we want the set to stay sorted, we've got <code>TreeSet</code></strong></p>
<p>与<code>HashSet</code>类似，<code>TreeSet</code>也可以防止重复。不过<code>TreeSet</code>还可以让清单 <em>保持</em> 排序。在使用 <code>TreeSet</code> 数据集不带参数的构造器来构造一个 <code>TreeSet</code> 时，那么这个 <code>TreeSet</code> 就会像 <code>Collections.sort()</code> 方法一样运作，该 <code>TreeSet</code> 运用其各个元素的 <code>compareTo()</code> 方法进行排序。还可以选择将一个 <code>Comparator</code> 对象，传递给 <code>TreeSet</code> 的构造器，让这个 <code>TreeSet</code> 使用传入的 <code>Comprator</code> 对象，取代前面提到的 <code>compareTo()</code> 方法。<code>TreeSet</code> 的不足之处在于，即使无需排序，人就要为这种数据集类型付出少量的性能代价。不过这少量的性能代价对大多数 apps 来说，都是难以觉察到的。</p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;
import java.io.*;
import com.xfoss.Utils.XPlatformThings;

public class JukeBox8 {

    // 这里将这个 ArrayList 从 String 修改为了 Song 对象。
    ArrayList&lt;Song&gt; songList = new ArrayList&lt;Song&gt; ();
    String wDir = XPlatformThings.getWorkingDir(&quot;learningJava&quot;);

    public JukeBox8 () {
        getSongs();
        System.out.format(&quot;原本的 songList: \n%s\n&quot;, songList);

        Collections.sort(songList);
        System.out.format(&quot;依标题排序后的 songList: \n%s\n&quot;, songList);

        HashSet&lt;Song&gt; songSet = new HashSet&lt;Song&gt; ();
        songSet.addAll(songList);
        System.out.format(&quot;作为 HashSet 的 songSet: \n%s\n&quot;, songSet);

        // 这里初始化了一个 TreeSet。调用不带参数的 TreeSet 构造器表示
        // 这个数据集将使用 Song 对象的 compareTo() 方法来排序。
        //
        // （这里也可以传入一个 Comparator 对象。）
        TreeSet&lt;Song&gt; songTreeSet = new TreeSet&lt;Song&gt; ();
        // 这里可以像 HashSet 那样，使用 addAll() 命令来添加所有歌曲。
        //
        // （也可以像之前在 ArrayList 中那样，使用 songTreeSet.add() 来单个地
        // 添加那些歌曲。）
        songTreeSet.addAll(songList);
        System.out.format(&quot;作为 TreeSet 的 songTreeSet:\n%s\n&quot;, songTreeSet);
    }

    public static void main(String[] args){
        new JukeBox8();
    }

    class ArtistCompare implements Comparator&lt;Song&gt; {
        public int compare(Song one, Song two) {
            return one.getArtist().compareTo(two.getArtist());
        }
    }

    class TitleCompare implements Comparator&lt;Song&gt; {
        public int compare (Song one, Song two) {
            return one.getTitle().compareTo(two.getTitle());
        }
    }

    void getSongs() {
        try {
            File file = new File(String.format(&quot;%s/SongListMore.txt&quot;, wDir));
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String line = null;
            while ((line = reader.readLine()) != null) {
                addSong(line);
            }
        } catch (IOException ex) {ex.printStackTrace();}
    }

    void addSong(String lineToParse) {

        // 这里使用四个令牌（也就是歌曲文件中这一行的四个信息片段）创建
        // 出一个新的 Song 对象，并将该 Song 对象添加到那个清单。
        String [] tokens = lineToParse.split(&quot;/&quot;);

        Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);
        songList.add(nextSong);
    }
}
</code></pre>
<h3 id="treeset-应知必会"><a class="header" href="#treeset-应知必会"><code>TreeSet</code> 应知必会</a></h3>
<p><strong>What you MUST know about <code>TreeSet</code></strong> ......</p>
<p>虽然 <code>TreeSet</code>看起来简单，但请一定要搞清楚，运用他是要做什么。为了让你对 <code>TreeSet</code> 重要性有所思考，这里准备了一个练习。在完成这个练习之前，请勿继续往后阅读。这里是 <em>认真的</em>。</p>
<h3 id="动手写代码-1"><a class="header" href="#动手写代码-1">动手写代码</a></h3>
<p>请看看这个代码。认真理解这个代码，然后回答下面的问题。（请注意：这段代码是没有语法错误的。）</p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;

public class TestTree {

    public TestTree () {
        Book b1 = new Book (&quot;How Cats Work&quot;);
        Book b2 = new Book (&quot;Remix your Body&quot;);
        Book b3 = new Book (&quot;Finding Emo&quot;);

        TreeSet&lt;Book&gt; tree = new TreeSet&lt;Book&gt; ();
        tree.add(b1);
        tree.add(b2);
        tree.add(b3);

        System.out.println(tree);
    }
}

class Book {
    private String title;
    public Book (String t) {
        title = t;
    }
}
</code></pre>
<ol>
<li>
<p>在编译此代码时会有什么样的结果？</p>
</li>
<li>
<p>在编译成功时，那么运行这个 <code>TestTree</code> 类，会有什么样的结果？</p>
</li>
<li>
<p>假如这段代码有个问题（编译时或运行时），那么该怎样来修改这个问题呢？</p>
</li>
</ol>
<blockquote>
<p>这段代码可通过编译，但会出现运行时错误：</p>
</blockquote>
<pre><code class="language-console">Exception in thread &quot;main&quot; java.lang.ClassCastException: class com.xfoss.CollectionAndGenerics.Book cannot be cast to class java.lang.Comparable (com.xfoss.CollectionAndGenerics.Book is in unnamed module of loader 'app'; java.lang.Comparable is in module java.base of loader 'bootstrap')
        at java.base/java.util.TreeMap.compare(TreeMap.java:1291)
        at java.base/java.util.TreeMap.put(TreeMap.java:536)
        at java.base/java.util.TreeSet.add(TreeSet.java:255)
        at com.xfoss.CollectionAndGenerics.TestTree.&lt;init&gt;(TestTree.java:13)
        at com.xfoss.CollectionAndGenerics.TestTree.main(TestTree.java:21)
shell returned 1
</code></pre>
<blockquote>
<p>但在给 <code>Book</code> 类加上 <code>implements Comparable&lt;Book&gt;</code> 及 <code>public int compareTo(Book b)</code> 后，输出即为：</p>
</blockquote>
<pre><code class="language-console">[com.xfoss.CollectionAndGenerics.Book@44e81672, com.xfoss.CollectionAndGenerics.Book@60215eee, com.xfoss.CollectionAndGenerics.Book@4ca8195f]
</code></pre>
<blockquote>
<p>此输出没有可读性可言。仍需重写 <code>Book</code> 类的 <code>toString()</code> 方法，重写该方法后的输出为：</p>
</blockquote>
<pre><code class="language-console">[Finding Emo, How Cats Work, Remix your Body]
</code></pre>
<h3 id="treeset-的元素-务必-要是可比较的"><a class="header" href="#treeset-的元素-务必-要是可比较的"><code>TreeSet</code> 的元素 <em>务必</em> 要是可比较的</a></h3>
<p><strong><code>TreeSet</code> elements MUST be comparable</strong></p>
<p><code>TreeSet</code> 可不会读心术，他没办法凭空搞清楚那些对象该怎么排序。因此就必须告诉 <code>TreeSet</code> 该怎么去对添加的对象 <em>怎样</em> 排序。</p>
<p><strong>要使用 <code>TreeSet</code>，就要满足下面二者其一的要求</strong>：</p>
<ul>
<li>
<p><strong>清单中的元素，务必为实现了 <em><code>Comparable</code> 类型的元素</em></strong></p>
<p>前面的 <code>Book</code> 类没有实现 <code>Comparable</code> 接口，因此在运行时，那段代码不会运作。请设想一些，可怜的<code>TreeSet</code>在现实中唯一目的，就是令到其中的那些元素保持排序，并且有一次的 -- <code>TreeSet</code> 对如何排序这些 <code>Book</code> 对象毫无概念！因为 <code>TreeSet</code> 的 <code>add()</code> 方法没有取一个 <code>Comparable</code> 类型，这个<code>add()</code>方法取的是在创建该 <code>TreeSet</code> 时用到的类型，因此那段代码在编译时不会失败。也就是说，在前面写下了 <code>new TreeSet&lt;Book&gt; ()</code> 时，那么这个 <code>add()</code> 方法，也就成了 <code>add(Book)</code> 了。而那里又没有要求那个 <code>Book</code> 类要实现 <code>Comparable</code>！这样在把第二个元素添加到这个数据集时，程序就会失败。添加第二个元素的时候，正是这个数据集尝试调用其中一个对象的 <code>compareTo()</code> 方法的时候，然而.......调用不到（The <code>Book</code> class on the previous page didn't implement <code>Comparable</code>, so it wouldn't work at runtime. Think about it, the poor <code>TreeSet</code>'s sole purpose in life is to keep your elements sourted, and once again -- it had no idea how to sort <code>Book</code> objects! It doesn't fail at compile-time, because the <code>TreeSet</code> <code>add()</code> method dosen't take a <code>Comparable</code> type, the <code>TreeSet</code> <code>add()</code> method takes whatever type you used when you created the <code>TreeSet</code>. In other workds, if you say <code>new TreeSet&lt;Book&gt;()</code> the <code>add()</code> method is essentially <code>add(Book)</code>. And there's no requirement that the <code>Book</code> class implement <code>Comparable</code>! But it fials at runtime when you add the second element to the set. That's the first time the set tries to call one of the objects's <code>compareTo()</code> methods and... can't）。</p>
</li>
</ul>
<pre><code class="language-java">class Book implements Comparable&lt;Book&gt; {
    private String title;
    private String writer;

    public Book (String t, String w) {
        title = t;
        writer = w;
    }

    public String getTitle () {
        return title;
    }

    public String getWriter () {
        return writer;
    }

    public int compareTo(Book b) {
        return title.compareTo(b.getTitle());
    }

    public String toString() {
        return String.format(&quot;%s: %s&quot;, title, writer);
    }
}
</code></pre>
<ul>
<li>
<p><strong>使用取 <code>Comparator</code> 参数的、过载的<code>TreeSet</code> 构造器</strong></p>
<p><code>TreeSet</code> 与 <code>Collections.sort()</code> 方法的工作方式很像 -- 假设元素类型实现了 <code>Comparable</code> 接口时，可选择使用元素的 <code>compareTo()</code> 方法；而在知道怎样对数据集中的元素进行排序时，亦可使用一个定制的 <code>Comparator</code> 对象。而要使用一个定制的 <code>Comparator</code> 对象，就要调用那个取一个 <code>Comparator</code> 对象作参数的 <code>TreeSet</code> 的构造器。</p>
</li>
</ul>
<pre><code class="language-java">public class TestTree {

    public TestTree () {
        Book b1 = new Book (&quot;How Cats Work&quot;, &quot;Lenny Peng&quot;);
        Book b2 = new Book (&quot;Remix your Body&quot;, &quot;Echo Feng&quot;);
        Book b3 = new Book (&quot;Finding Emo&quot;, &quot;Rose Peng&quot;);

        TreeSet&lt;Book&gt; tree = new TreeSet&lt;Book&gt; (new CompareWriter());
        tree.add(b1);
        tree.add(b2);
        tree.add(b3);

        System.out.println(tree);
    }

    class CompareWriter implements Comparator&lt;Book&gt; {
        public int compare(Book b1, Book b2) {
            return b1.getWriter().compareTo(b2.getWriter());
        }
    }

    public static void main (String[] args) {
        new TestTree();
    }
    
}
</code></pre>
<p><img src="images/Ch16_26.png" alt="TreeSet 排序的两种不同方式：实现 Comparable 接口与使用 Comparator 作为构造器参数" /></p>
<p><em>图 26 - <code>TreeSet</code> 实现排序的两种不同方式：实现 <code>Comparable</code> 接口与使用 <code>Comparator</code> 作为构造器参数</em></p>
<h2 id="已经见识了清单与数据集那么现在就要用到映射-map-"><a class="header" href="#已经见识了清单与数据集那么现在就要用到映射-map-">已经见识了清单与数据集，那么现在就要用到映射（ <code>Map</code> ）</a></h2>
<p><strong>We've seen <code>List</code>s and <code>Set</code>s, now we'll use a <code>Map</code></strong></p>
<p>清单与数据集都是极好的，但有的时候映射（a <code>Map</code>）则是最佳的集合（注意这里不是大写字母 <code>C</code> 的 <code>Collection</code> -- 请记住映射属于Java集合，但他们没有实现 <code>Collection</code>接口）。</p>
<p>设想想要一个像属性清单一样行事的集合，在那里给到一个名称，他就会给出与这个名称关联的值回来。虽然这些作为名称的键，通常是字符串，但他们也可以是任何的Java对象（或者也可以是，经由 <a href="Ch10_Numbers_and_Statics_Numbers_Matter.html#autoboxing">自动打包的原生值</a>）。</p>
<p><img src="images/Ch16_27.png" alt="Java 中的映射" /></p>
<p><em>图 27 - Java 中的映射</em></p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;

public class TestMap {
    public TestMap () {
        // HashMap 需要 两个 类型参数 -- 一个用于键，另一个用于值。
        HashMap&lt;String, Integer&gt; scores = new HashMap&lt;String, Integer&gt; ();

        // 这里使用 put() 而不是 add() 方法，同时这里理所应当要取两个参数 (key, value)。
        scores.put(&quot;Lenny&quot;, 42);
        scores.put(&quot;Echo&quot;, 343);
        scores.put(&quot;Rose&quot;, 420);

        System.out.println(scores);
        // 这个 get() 方法，要取一个键参数，并返回值（在此示例中，即为一个整数 Integer）。
        System.out.println(scores.get(&quot;Echo&quot;));
    }


    public static void main (String[] args) {
        new TestMap();
    }
}
</code></pre>
<p><img src="images/Ch16_28.png" alt="Java 映射示例" /></p>
<p><em>图 28 - Java 映射示例</em></p>
<blockquote>
<p>在打印映射时，会给出花括弧 <code>{}</code> ，而非在打印清单与数据集时方括弧 <code>[]</code> ，所包围起来的 <code>key=value</code> 键值对。</p>
</blockquote>
<h2 id="最后回到泛型上来"><a class="header" href="#最后回到泛型上来">最后，回到泛型上来</a></h2>
<p><strong>Finally, back to generics</strong></p>
<p>还记得本章早先曾谈到，方法取用那些带有泛型参数，会有多么的......<em>奇怪</em>。而这里所说的奇怪，是在多态语境下的。若觉得这里的东西变得离奇，那么只要继续往下看就好 -- 要讲清楚这个，还得要数页篇幅（Remember earlier in the chapter we talked about how methods that take arguments with generic types can be... <em>weird</em>. And we mean weird in the polymorphic sense. If things start to feel strane here, just keep going--it takes a few pages to really tell the whole story）。</p>
<p>这里将从揭示一个 <em>数组</em> 参数，按多态方式运作的原理开始，随后就会看看类似的多态下泛型清单是如何工作的。以下代码编译和运行都不会有错误：</p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;

public class TestGenerics1 {
    public TestGenerics1 () {
        // 这里声明并创建了一个同时保存狗子和猫猫的 Animal 的数组。
        Animal[] animals = {
            new Dog(),
            new Cat(),
            new Dog()
        };

        // 这里声明并创建了一个仅保存 Dog 对象的 Dog 数组（编译器不会
        // 允许把一个 Cat 对象放进去的）。
        Dog[] dogs = {
            new Dog(),
            new Dog(),
            new Dog()
        };

        // 这里使用了上面两种数组类型作为参数，对 takeAnimals() 方法
        // 进行调用......
        takeAnimals(animals);
        takeAnimals(dogs);
    }

    // 这里的重点在于，由于 Dog IS-A Animal，因此 takeAnimals() 方法既可以取 Animal[] 做参数，也可以取
    // Dog[] 做参数。可以看出多态机制发挥了作用。
    public void takeAnimals(Animal[] animals) {
        for (Animal a: animals) {
            // 请记住，由于这里的参数 animals 是类型 Animal 的数组，并且这里没有执行任何
            // 强制类型转换，因此这里能调用的，只能是在类型 Animal 中声明的方法。（这里又能将
            // a 强制转换为什么呢？数组 animals 可能同时保存了 Dog 和 Cat 对象。）
            a.eat();
        }
    }

    public static void main (String[] args){
        new TestGenerics1();
    }
}


// 以下是简化了的 Animal 类继承层次。
abstract class Animal {
    void eat() {System.out.println(&quot;动物进食&quot;);}
}

class Dog extends Animal {
    void bark (){ System.out.println(&quot;汪汪......&quot;);}
}

class Cat extends Animal {
    void meow () {System.out.println(&quot;喵喵......&quot;);}
}
</code></pre>
<p><img src="images/Ch16_29.png" alt="TestGenerics1 运行结果" /></p>
<p><em>图 29 - <code>TestGenerics1</code> 运行结果</em></p>
<h3 id="运用多态参数与泛型"><a class="header" href="#运用多态参数与泛型">运用多态参数与泛型</a></h3>
<p><strong>Using polymophic arguments and generics</strong></p>
<p>通过上面的示例，这里就见识了多态下的数组是如何工作的了，那么在从数组切换到 <code>ArrayList</code> 时，多态机制还生效吗？听起来理由充分，不是吗？</p>
<p>首先，来试试只有 <code>Animal</code> 类型的 <code>ArrayList</code>。这里只对其中的构造函数稍加改动：</p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;

// 这里简单地将 Animal[] 修改为了 ArrayList&lt;Animal&gt;。
public class TestGenerics2 {
    public TestGenerics2 () {
        ArrayList&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt; ();
        // 由于 ArrayList 没有像数组创建那样的简便方式，因此这里
        // 必须一次一个地添加 ArrayList 元素。
        animals.add(new Dog());
        animals.add(new Cat());
        animals.add(new Dog());

        // 这里的代码没变，只是现在的 animals 变量，引用的是 ArrayList 而
        // 不再是之前的数组了。
        takeAnimals(animals);
    }

    // 这个方法现在取用的是一个 ArrayList 类型的参数，而不再是之前的数组参数了，不过
    // 其余的部分还是一样的。请记住，对于数组与集合，for 循环都是有效的。
    public void takeAnimals(ArrayList&lt;Animal&gt; animals) {
        for (Animal a: animals) {
            a.eat();
        }
    }

    public static void main (String[] args){
        new TestGenerics2();
    }
}
</code></pre>
<p><img src="images/Ch16_30.png" alt="修改为 ArrayList 的 TestGenerics2 的运行结果" /></p>
<p><em>图 30 - 修改为 <code>ArrayList</code> 的 <code>TestGenerics2</code> 的运行结果</em></p>
<h3 id="那么对于-arraylistdog-也行吗"><a class="header" href="#那么对于-arraylistdog-也行吗">那么对于 <code>ArrayList&lt;Dog&gt;</code> 也行吗？</a></h3>
<p>由于多态机制的原因，编译器是允许将一个 <code>Dog</code> 数组，传递给有着<code>Animal</code>数组参数的方法的（正如<code>TestGenerics1</code>中那样）。当然这没有问题。同样一个 <code>ArrayList&lt;Aniaml&gt;</code>的参数，也可以传递给带有 <code>ArrayList&lt;Animal&gt;</code>参数的方法。因此这里一个大问题即是，这个 <code>ArrayList&lt;Animal&gt;</code> 参数，会接受一个 <code>ArrayList&lt;Dog&gt;</code>吗？既然在数组下可行，这里会不会也行呢？</p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;

public class TestGenerics2 {
    public TestGenerics2 () {
        ArrayList&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt; ();
        animals.add(new Dog());
        animals.add(new Cat());
        animals.add(new Dog());
        // 我们知道这一行是没问题的。
        takeAnimals(animals);

        // 现在构造一个 Dog 类型的 ArrayList 并放入两个 Dog 对象进去。
        ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt; ();
        dogs.add(new Dog());
        dogs.add(new Dog());
        // 现在这行将数组修改为 ArrayList 的代码会工作吗？
        takeAnimals(dogs);
    }

    public void takeAnimals(ArrayList&lt;Animal&gt; animals) {
        for (Animal a: animals) {
            a.eat();
        }
    }

    public static void main (String[] args){
        new TestGenerics2();
    }
}
</code></pre>
<pre><code class="language-console">.../src/main/java/com/xfoss/CollectionAndGenerics/TestGenerics2.java:17: error: incompatible types: ArrayList&lt;Dog&gt; cannot be converted to ArrayList&lt;Animal&gt;
        takeAnimals(dogs);
                    ^
</code></pre>
<blockquote>
<p>这代码看起来是那么的正确，但却错得离谱......（It looked so right, but went so wrong...）</p>
</blockquote>
<blockquote>
<p><em>我还以为这代码应该没问题的呢？那就完全破坏了正在写的动物模拟应用，其中有一个取任意 <code>Animal</code> 类型的清单作参数的兽类程序，这样的话狗窝就可以交出一个狗子的清单，而猫窝就可以交出一个猫猫的清单......现在你跟我说不能这样，不能用集合来代替数组</em>？
<em>And I'm supposed to be OK with this? That totally screws my animal simulation where the veterinary program takes a list of any type of aniaml, so that a dog kennel can send a list of dogs, and a cat kennel can send a list of cats...now you're saying I can't do that if I use collections instead of arrays</em>?</p>
</blockquote>
<h3 id="如果允许这样做会怎样呢"><a class="header" href="#如果允许这样做会怎样呢">如果允许这样做，会怎样呢？</a></h3>
<p><strong>What could happen if it were allowed</strong>...</p>
<p>请设想一下如果编译器允许避开那个报错。那就是允许将一个 <code>ArrayList&lt;Dog&gt;</code> 传递给这样声明的一个方法了：</p>
<pre><code class="language-java">public void takeAnimals(ArrayList&lt;Animal&gt; animals) {
    for (Animal a: animals) {
        a.eat();
    }
}
</code></pre>
<p><em>看起来</em> 这方法中是相当无害的，对吧？归根结底，多态机制的要义，就是 <code>Animal</code> 可以完成的所有事情（在此示例中，就是<code>eat()</code>方法），<code>Dog</code> 也是可以完成的。那么到底在那些<code>Dog</code>引用变量上的 <code>eat()</code> 方法调用有什么问题呢？</p>
<p><em>不存在</em>。什么问题也没有。</p>
<p><em>那段</em> 代码本身没有任何问题。然而请设想下面 <em>这段</em> 代码：</p>
<pre><code class="language-public void takeAnimals(ArrayList&lt;Animal&gt; animals) {">    // 糟糕！这里恰好把一个 Cat 对象，给添加到了一个可能是个仅 Dog 类型的 ArrayList 中了。
    animals.add(new Cat());
}
</code></pre>
<p>那么这就是问题所在了。将一个<code>Cat</code>对象添加到一个<code>ArrayList&lt;Animal&gt;</code>确实没什么问题，并且这这正是之所以运用有着诸如<code>Aniaml</code>这样超类型<code>ArrayList</code>的要义所在--如此就可以把所有<code>Aniaml</code>子类型，都放在单个的<code>Animal</code>类型的<code>ArrayList</code>中（So that's the problem. There's certainly nothing wrong with adding a <code>Cat</code> to an <code>ArrayList&lt;Animal&gt;</code>, and that's the whole point of having an <code>ArrayList</code> of a supertype like <code>Animal</code>--so that you can put all types of animals in a single <code>Animal</code> <code>ArrayList</code>）。</p>
<p>然而在将一个<code>Dog</code>类型的<code>ArrayList</code>--一个表示仅保存<code>Dog</code>对象的<code>ArrayList</code>--传递给这个取<code>Animal</code>类型的<code>ArrayList</code>参数的方法后，那么就会立即以出现在<code>Dog</code>类型清单中的<code>Cat</code>对象而告终。编译器知道如果允许将一个<code>Dog</code>类型<code>ArrayList</code>传入到那样的方法，就会有人在运行时，把一个<code>Cat</code>对象添加到那个<code>Dog</code>类型的清单。因此编译器就直接不会让你冒这个风险了。</p>
<p><em><strong>在申明了一个取<code>ArrayList&lt;Animal&gt;</code>参数的方法时，这个方法便只能取<code>ArrayList&lt;Animal&gt;</code>参数，对于<code>ArrayList&lt;Dog&gt;</code>或<code>ArrayList&lt;Cat&gt;</code>，都是不可以的</strong></em>。</p>
<blockquote>
<p><em>等一下......若这就是为何编译器不允许将 <code>Dog</code> 类型 <code>ArrayList</code>， 传入到以<code>Animal</code> 类型 <code>ArrayList</code>做参数的方法的原因--为阻止可能的将<code>Cat</code>对象放入到实际为<code>Dog</code>类型清单，那为何数组上为什么又可行呢？难道对于数组就没有这同样的问题吗？难道也不能把<code>Cat</code>对象添加到 <code>Dog[]</code>吗</em>？</p>
</blockquote>
<h3 id="array-数组类型是在运行时检查但数据集类型的检查是在编译时就发生了"><a class="header" href="#array-数组类型是在运行时检查但数据集类型的检查是在编译时就发生了"><code>Array</code> 数组类型，是在运行时检查，但数据集类型的检查，是在编译时就发生了</a></h3>
<p><strong><code>Array</code> types are checked again at runtime, but collection type checks happen only when you compile</strong></p>
<p>假设像下面这样，<em>确实</em> 将一个 <code>Cat</code> 对象添加给了一个声明为 <code>Dog[]</code> 的数组（一个传入到声明为<code>Animal[]</code>的方法参数的数组，下面的写法，是一种相当合法的数组赋值；<em>注意</em>：Java 中的数组，是固定长度的，因此没有<code>append()</code>方法）。</p>
<pre><code class="language-java">package com.xfoss.CollectionAndGenerics;

import java.util.*;

public class TestGenerics3 {
    public TestGenerics3 () {
        Dog[] dogs = {
            new Dog(),
            new Dog(),
            new Dog()
        };

        takeAnimals(dogs);
    }

    public void takeAnimals(Animal[] animals) {
        // 这里将一个`Cat`对象放入到了一个 `Dog` 数组。由于编译器知道，这里
        // 传递该方法的可能是个`Cat`数组或`Animal`数组，因此编译器是允许这样写
        // 的，那么对于编译器来说，这可能是正确的。
        animals[2] = new Cat();
    }

    public static void main (String[] args){
        new TestGenerics3();
    }
}
</code></pre>
<p>这段代码可以编译，但在运行时，会抛出异常：</p>
<pre><code class="language-console">$ java -jar build/libs/com.xfoss.learningJava-0.0.1.jar
Exception in thread &quot;main&quot; java.lang.ArrayStoreException: com.xfoss.CollectionAndGenerics.Cat
        at com.xfoss.CollectionAndGenerics.TestGenerics3.takeAnimals(TestGenerics3.java:17)
        at com.xfoss.CollectionAndGenerics.TestGenerics3.&lt;init&gt;(TestGenerics3.java:13)
        at com.xfoss.CollectionAndGenerics.TestGenerics3.main(TestGenerics3.java:21)
</code></pre>
<blockquote>
<p><em>呃！至少JVM阻止了他的运行</em>。</p>
</blockquote>
<blockquote>
<p><em>难道想要一种仍然可以使用多态数据集类型，作为方法参数的方式，以致我写的兽类程序可以取得<code>Dog</code>与<code>Cat</code>类型清单，就是异想天开吗？如果能那样做，那么就可以对清单进行遍历，从而既可以调用这些猫猫狗狗的 <code>immunize()</code> 方法，还必须确保无法将一个<code>Cat</code>对象添加到 <code>Dog</code> 类型清单方面的安全性。然而我猜我这个想法终将是个幻想而已了</em>......</p>
<p><em>Wouldn't it be dreamy if there were a way to still use polymorphic collection types as method arguments, so that my veterinary program could take <code>Dog</code> lists and <code>Cat</code> lists? That way I could loop through the lists and call their <code>immunize()</code> method, but it would still have to be safe so that you couldn't add a <code>Cat</code> in to the <code>Dog</code> list. But I guess that's just a fantasy</em>...</p>
</blockquote>
<h3 id="通配符来挽救"><a class="header" href="#通配符来挽救">通配符来挽救</a></h3>
<p><strong>Wildcards to the rescue</strong></p>
<blockquote>
<p><strong>注</strong>：本书出现了三次 to the rescue，这里是第三处，其余两处为：1、<a href="Ch08_Interfaces_and_Abstract_Classes.html#interface_rescue">Interface to the rescue!</a>；2、<a href="Ch12_Getting_GUI_A_Very_Graphic_Story.html#inner_class_rescue">Inner class to the rescue!</a></p>
</blockquote>
<p>虽然看起来非同寻常，不过 <em>确实</em> 有种创建可接受任意 <code>Animal</code> 子类型的<code>ArrayList</code>作为方法参数的方式。最简单的做法，就是使用 <strong>通配符（wildcard）</strong> -- 正式因为这个原因，通配符才被显式地加入到Java编程语言的（it looks unusual, but there <em>is</em> a way to create a method argument that can accept an <code>ArrayList</code> of any <code>Animal</code> subtype. The simplest way is to use a <strong>wildcard</strong>--added to the Java language explicitly for this reason）。</p>
<pre><code class="language-java">public void takeAnimals(ArrayList&lt;? extends Animal&gt; animals) {
    for (Animal a: animals) {
        a.eat();
    }
}
</code></pre>
<blockquote>
<p><em>还记得吧，这里的关键字 <code>extends</code>的意思，根据他后面类型的不同，既可以是 <code>extends</code>，也可以是 <code>implements</code>。那么在想要取一个实现了 <code>Pet</code> 接口类型的 <code>ArrayList</code> 做参数时，就可以这样来申明这个参数</em>：</p>
</blockquote>
<pre><code class="language-java">ArrayList&lt;? extends Pet&gt;
</code></pre>
<p>那么现在你肯定在想，“这有 <em>区别</em> 吗？不会还有之前同样的问题吧？上面的那个方法，并没有做什么危险的事情--仅仅是调用了任何<code>Animal</code>子类型都必定有的方法--然而有的人不还可以把这个方法，修改为把<code>Cat</code>对象添加到那个 *<code>Animal</code>*清单吗，即使这个清单实际上是个<code>ArrayList&lt;Dog&gt;</code>？而且由于在运行时这没有被检查呢，既然这样，这样做与不带通配符又有怎样的不同呢”？</p>
<p>你的顾虑或许是对的。然而答案是否定的。当在声明中使用了通配符<code>&lt;?&gt;</code>时，编译器就不会允许将任何东西添加到那个清单了（）！</p>
<blockquote>
<p><strong>当在方法声明中使用了通配符时，编译器会阻止任何的那些可能危害到被这个方法参数所引用清单的操作（When you use a wildcard in your method argument, the compiler will STOP you from doing anything that could hurt the list referenced by the method parameter）</strong>。</p>
<p><em>注</em>：关于Java中的形式参数与实际参数：<a href="https://www.geeksforgeeks.org/argument-vs-parameter-in-java/">Argument vs Parameter</a></p>
<p><strong>这个时候仍然可以运行这个清单中元素上的方法，但不可以往清单添加元素了</strong>。</p>
<p><strong>也就是说，可以对这些清单元素进行任何操作，但不能将新东西放入到这个清单。由于编译器不会允许任何在运行时可怕操作，因此在运行时就是安全的</strong>。</p>
<p><strong>那么，在那个 <code>takeAnimals()</code> 里边，这样做是没有问题的</strong>：</p>
</blockquote>
<pre><code class="language-java">for (Animal a: animals) {
    a.eat();
}
</code></pre>
<blockquote>
<p><strong>但下面的就不会编译</strong>：</p>
</blockquote>
<pre><code class="language-java">animals.add(new Dog());
</code></pre>
<blockquote>
<p><strong><em>注</em>：除了 <code>add()</code> 方法不允许外，<code>set()</code> 方法也是不被允许的</strong>：</p>
</blockquote>
<pre><code class="language-java">animals.set(0, new Dog());
</code></pre>
<blockquote>
<p><strong>编译时报出的错误都是</strong>:</p>
</blockquote>
<pre><code class="language-console">.../src/main/java/com/xfoss/CollectionAndGenerics/TestGenerics2.java:20: error: incompatible types: Dog cannot be converted to CAP#1
        animals.set(0, new Dog());
                       ^
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Animal from capture of ? extends Animal
</code></pre>
<h3 id="完成同样事情的替代语法"><a class="header" href="#完成同样事情的替代语法">完成同样事情的替代语法</a></h3>
<p><strong>Alternate syntax for doing the same thing</strong></p>
<p>或许还记得在之前讲到<code>Collections.sort()</code>方法时，在该方法的声明中，以一种不寻常的、类型参数声明在返回值前边的格式，使用了泛型。那只是一种声明类型参数的不同方式，结果仍是相同的：</p>
<blockquote>
<p><em>注</em>：Java 中涉及到 类型参数（the type parameter） 与 类型变量（the type variable）。</p>
</blockquote>
<p><strong>这种类型实参的声明方式</strong>：</p>
<pre><code class="language-java">public &lt;T extends Animal&gt; void takeThing(ArrayList&lt;T&gt; list)
</code></pre>
<p><strong>执行了与下面这种声明方式同样的事情</strong>：</p>
<pre><code class="language-java">public void takeThing(ArrayList&lt;? extends Animal&gt; list)
</code></pre>
<h2 id="答疑-26"><a class="header" href="#答疑-26">答疑</a></h2>
<ul>
<li><strong>既然这两种方式完成了同样的事情，那为何不优先使用其中一种方式呢</strong>？</li>
</ul>
<blockquote>
<p>是否要优先选择其中之一，完全取决于是不是想要在其他地方使用这个 <code>T</code>。比如如果希望那个方法有两个参数--这两个参数都是对<code>Animal</code> 进行扩展的类型的清单时，会怎样呢？在这种情况下，只声明一次这个类型参数，就更加高效了：</p>
</blockquote>
<pre><code class="language-java">public &lt;T extends Animal&gt; void takeThing(ArrayList&lt;T&gt; one, ArrayList&lt;T&gt; two)
</code></pre>
<blockquote>
<p>而不需要像下面这样写：</p>
</blockquote>
<pre><code class="language-java">public void takeThing(ArrayList&lt;? extends Animal&gt; one, ArrayList&lt;? extends Animal&gt; two)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打包jars-与部署发布代码"><a class="header" href="#打包jars-与部署发布代码">打包、JARs 与部署：发布代码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-rmi-特性进行远端部署分布式计算"><a class="header" href="#使用-rmi-特性进行远端部署分布式计算">使用 RMI 特性进行远端部署：分布式计算</a></h1>
<p><strong>remote deployment with RMI: Distributed Computing</strong></p>
<blockquote>
<p>所有人都说那些遥远关系都很难，但因为Java有着 RMI 特性，就不那么难了。不论二人隔得有多远，RMI让相隔两地的二人，看起来像是在一起。</p>
<p><em>Everyone says long-distance relationships are hard, but with RMI, it's easy. No matter how far apart we <em>really</em> are, RMI makes it seem like we're together</em>.</p>
</blockquote>
<p><strong>隔得远远的并不一定有什么不好（Being remote doesn't have to be a bad thing）</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-a十个未列入到本书正式章节的题目"><a class="header" href="#附录-a十个未列入到本书正式章节的题目">附录 A：十个未列入到本书正式章节的题目</a></h1>
<p><strong>Appendix A: Ten Topics that almost made it into the Real Book</strong>...</p>
<blockquote>
<p>这里的意思，是还有更多的内容？这本书还没完？</p>
</blockquote>
<p>这本书涵盖了很多基础知识，而你也快要学完这本书了。感谢你认真学完本书，不过在你投身于Java编程之前，我们还是希望给你更多的一些准备。对于这个附录，也不可能给到你想要的全部，原本这里通过将字型像素点大小缩减到 <code>.00003</code>，而尽力将所有需要掌握的Java知识都包含进来（不是之前那些章节中包含的）。这样是可行的，但那样就没有人能够阅读了。就这样，这里抛弃了很多内容，仅保留了是个最优的方面作为了附录（We covered a lot of ground, and you're almost finished with this book. We'll miss you, but before we let you go, we wouldn't feel right about sending you out into JavaLand without a little more preparation. We can't possibly fit everything you'll need to know into this relatively small appendix. Actually, we <em>did</em> originally include everything you need to know about Java(not already covered by the other chapters), by reducing the type point size to <code>.00003</code>. It all fit, but nobody could read it. So, we threw most of it away, but kept the best bits for this Top Ten appendix）。</p>
<p>这是本书 <em>真正的</em> 结尾了。当然还有一个索引（那也是必读部分）！</p>
<h2 id="第10名位操作"><a class="header" href="#第10名位操作">第10名：位操作</a></h2>
<p><strong>#10 Bit Manipulation</strong></p>
<h3 id="为何要关注"><a class="header" href="#为何要关注">为何要关注？</a></h3>
<p><strong>Why do you care</strong>?</p>
<p>前面提到过，一个字节中有8个二进制位，短整型则有16个等待的事实。而在某些场合，可能需要对这些单独的二进制位，进行翻转。比如就可能出现给一台新的、启用了Java的烤面包机编写代码，并意识到由于严重的内存限制，一些确切的烤面包机设置，要在二进制位级别上加以控制。为了易于阅读，下面的代码注释中，仅展示了整数的后八位，而不是其整个的32位。</p>
<h3 id="按位非运算符"><a class="header" href="#按位非运算符">按位非运算符：<code>~</code></a></h3>
<p><strong>Bitwise NOT operator: <code>~</code></strong></p>
<p>此运算符对原生值进行 “所有二进制位的翻转”：</p>
<pre><code class="language-java">int x = 10;     // 其二进制位为 00001010
x = ~x;         // 现在的二进制位为 11110101
</code></pre>
<blockquote>
<p><strong>注意</strong>：只有能转化为整型的原生类型，才能做二进制位翻转的非运算。经测试，整型、字符等都可以进行非运算；而逻辑值、浮点数等其他类型则不行（<code>error: bad operand type float for unary operator '~'</code>）</p>
</blockquote>
<p>接下来的三个运算符，是对两个原生值，在位的基础上按位进行比较，进而返回一个基于这些位的比较的结果（The next three operators compare two primitives on a bit by bit basis, and return a result based on comparing these bits）。后面三个运算符都将用到下面整个示例：</p>
<pre><code class="language-java">int x = 10;
int y = 6;
</code></pre>
<h3 id="按位与运算符"><a class="header" href="#按位与运算符">按位与运算符：<code>&amp;</code></a></h3>
<p><strong>Bitwise AND Operator: <code>&amp;</code></strong></p>
<p>此运算符会返回一个仅在原先原本的两个二进制位 <em><strong>均为</strong></em> 开启时，二进制位才开启的值（This operator returns a value whose bits are turned on only if <em><strong>both</strong></em> bits are turned on）。</p>
<pre><code class="language-java">int a = x &amp; y; // x 的二进制位为：0000 0010
</code></pre>
<h3 id="按位或运算符"><a class="header" href="#按位或运算符">按位或运算符：<code>|</code></a></h3>
<p><strong>Bitwise OR Operator: <code>|</code></strong></p>
<p>此运算符返回一个仅在两个原本两个二进制位 <em><strong>其一</strong></em> 为开启时，二进制位才开启的值（This operator returns a value whose bits are turned on only if <em><strong>either</strong></em> of the original bits are turned on）。</p>
<pre><code class="language-java">int a = x | y;  // x 的二进制位为：0000 1110
</code></pre>
<h3 id="按位异或运算符"><a class="header" href="#按位异或运算符">按位异或运算符：<code>^</code></a></h3>
<p><strong>Bitwise XOR(exclusive OR) Operator: <code>^</code></strong></p>
<p>此运算符返回一个仅在原本两个二进制位 <em><strong>只有其一</strong></em> 开启时，二进制位才开启的值（This operator returns a value whose bits are turned on only if <em><strong>exactly one</strong></em> of the original bits are turned on）。</p>
<pre><code class="language-java">int a = x ^ y;  // x 的二进制位为：0000 1100
</code></pre>
<h3 id="移位运算符"><a class="header" href="#移位运算符">移位运算符</a></h3>
<p><strong>The Shift Operators</strong></p>
<p>这些运算符取单个的整型原生变量，并对其全部二进制位在某个方向或另一方向上进行移位（或者说滑动）。只要稍加磨砺一下二进制数学技能，就应该知道，<em>往左</em> 对二进制位进行移位，就相当于把一个数 <em>乘以</em> 了某个二的某个幂次方，而 <em>往右</em> 移动二进制位，则相当于把一个数 <em>除以</em> 了一个二的某个幂次方（These operators take a single integer primitive and shift(or slide) all of its bits in one direction or another. If you want to dust off your binary math skills, you might realize that shifting bits <em>left</em> effectively <em>multiplies</em> a number by a power of two, and shifting <em>right</em> effectively <em>divides</em> a number by a power of two）。</p>
<p>这里将使用下面的示例，来讲解接下来的三个运算符：</p>
<pre><code class="language-java">int x = -11;    // 二进制位为：1111 1111 1111 1111 1111 1111 1111 0101
</code></pre>
<p>好吧，好吧，之前一直回避了整个问题，那么现在就来以世界上最简短形式，讲一下负数存储，与 <em>二进制补码（two's complement）</em> 的问题。请记住，整型数最左边的那一位，被叫做 <em>符号位（sign bit）</em>。Java中负整型数的符号位始终是开启的（即被设置为 <code>1</code>）。而正整型数的符号位，则始终是关闭的（<code>0</code>）。Java 使用了 <em>二进制</em> 补码公式（二补公式）来存储负数。为了采用二进制补码，去改变某个数的符号，就要将这个数的的所有二进制位加以翻转，然后加上 <code>1</code>（对于一个字节表示整数来讲，这就意味着要将 <code>0000 0001</code>加到翻转后的值），这就是所谓的“二补公式”。</p>
<h3 id="向右移位运算符"><a class="header" href="#向右移位运算符">向右移位运算符：<code>&gt;&gt;</code></a></h3>
<p><strong>Right Shift Operator: <code>&gt;&gt;</code></strong></p>
<p>此运算符将某个数的所有二进制位，往右移动某个确切数目，对于移动后左侧留下的那些空白二进制位，将以原先二进制数最左边的位填充。因此<strong>符号位是不会改变的</strong>：</p>
<pre><code class="language-java">int y = x &gt;&gt; 2; // 此时二进制位为：1111 1111 1111 1111 1111 1111 1111 1101 -&gt; -3
</code></pre>
<h3 id="无符号向右移位运算符"><a class="header" href="#无符号向右移位运算符">无符号向右移位运算符：<code>&gt;&gt;&gt;</code></a></h3>
<p>此运算符与上面的右移运算符类似，但这个运算符会始终以零填充最左边的那些二进制位。因此 <strong>符号就可能会改变</strong>：</p>
<pre><code class="language-java">int y = x &gt;&gt;&gt; 2;    // 此时二进制位为：0011 1111 1111 1111 1111 1111 1111 1101 -&gt; 1,073,741,821
</code></pre>
<h3 id="向左移位运算符"><a class="header" href="#向左移位运算符">向左移位运算符：<code>&lt;&lt;</code></a></h3>
<p><strong>Left Shift Operator: <code>&lt;&lt;</code></strong></p>
<p>此运算符与上面的无符号右移运算符类似，不过是往另一方向而已；最右边的那些二进制位是以全零填充的。因此 <strong>符号位可能改变</strong>。</p>
<pre><code class="language-java">int y = x &lt;&lt; 2; // 此时二进制位为：1111 1111 1111 1111 1111 1111 1101 0100 -&gt; -44
</code></pre>
<h2 id="不变性"><a class="header" href="#不变性">不变性</a></h2>
<p><strong>Immutability</strong></p>
<h3 id="为何要留意字符串是-immutable-类型的"><a class="header" href="#为何要留意字符串是-immutable-类型的">为何要留意字符串是 <code>Immutable</code> 类型的？</a></h3>
<p><strong>Why do you care that Strings are <code>Immutable</code></strong>?</p>
<p>在Java程序变得大起来时，最后就将不可避免地有着很多很多的 <code>String</code> 对象。为了安全目的，以及节省内存的缘故（请记住Java程序可在那些启用了Java的内存极少的移动电话上运行），Java中的字符串是不可更改的。这意味着在下面这样写代码时：</p>
<pre><code class="language-java">String s = &quot;0&quot;;

for (int x = 1; x &lt; 10; x++) {
    s = s + x;
}
</code></pre>
<p>这实际上进行的是在创建10个<code>String</code>对象（他们的值分别是 <code>0</code>、<code>01</code>、<code>012</code> 直到 <code>0123456789</code>）。最后的那个 <code>s</code> 中指向的是值为<code>0123456789</code>的字符串，但是此刻存在着多大 <em>十个</em> 的字符串！</p>
<p>无论何时构造一个新的 <code>String</code> 对象，JVM 都会将其放入到一个名为 &quot;字符串池（<code>String</code> Pool）&quot; 的内存部分（是不是听起来很新奇？）。在字符串池中已经有一个同样值的<code>String</code>对象时，JVM就不再会创建一个重复的了，JVM会简单地将其他引用变量指向到这个既有条目。JVM之所以能侥幸做到这点，就是因为字符串具有不变性；引用变量无法修改某个<code>String</code>对象的值，是由于有别的引用变量引用了这同一个<code>String</code>对象（The JVM can get away with this because Strings are immutable; one reference variable can't change a <code>String</code>'s value out from under another reference variable referring to the same things）。</p>
<p><code>String</code>对象池的另一问题在于，垃圾回收器 <em>无法触及到那里</em>。因此在此示例中，除非碰巧随后要构造一个，比如说<code>01234</code>的<code>String</code>对象，那么在那个 <code>for</code> 循环中构造的前 9 个字符串，就将在那里白白浪费内存。</p>
<h3 id="这样做为何能节省内存"><a class="header" href="#这样做为何能节省内存">这样做为何能节省内存？</a></h3>
<p>好吧，若没有用心编写代码，<em>这种不可变性还是无法节省内存的</em>！不过在掌握了 <code>String</code> 类不可更改能力的原理时，那么就可以利用到不可更改性的有点，从而节省到内存。在势必要进行很多 <code>String</code> 对象操作（比如字符串连接等等）时，尽管有另一个类 <code>StringBuilder</code>更加适合这样的目的。关于 <code>StringBuilder</code>类，后面会有篇幅会讲到。</p>
<h3 id="为何要对包装器的不可更改性加以留意"><a class="header" href="#为何要对包装器的不可更改性加以留意">为何要对包装器的不可更改性加以留意？</a></h3>
<p><strong>Why do you care that Wrappers are <code>Immutable</code></strong>?</p>
<p>之前在涉及到数学计算的那一章，曾讲到包装类的两个主要用途：</p>
<ul>
<li>将原生值加以包装，从而这个原生值可表现为一个对象；</li>
<li>一些静态工具方法的使用（比如，<code>Integer.parseInt()</code>）。</li>
</ul>
<p>记住可像下面这样创建一个包装器对象，至关重要：</p>
<pre><code class="language-java">Integer iWrap = new Integer(42);
</code></pre>
<p>其中 <code>iWrap</code> 就是包装器对象了。他的值将 <em>始终</em> 是 <code>42</code>。<em><strong>包装器对象，是没有设置器方法的（There is no setter method for a wrapper object）</strong></em>。当然，是可以将这个 <code>iWrap</code> 引用变量，指向一个 <em>不同的</em> 包装器对象的，然而这时就会有 <em>两个</em> 对象了。一旦创建出一个包装器对象，那么就没有办法去修改那个对象的 <em>值</em> 了！</p>
<blockquote>
<p><strong>牢牢记住</strong></p>
<p><em>Roses are red, violets are blue</em>.</p>
<p><em><strong>Strings are immutable, wrappers are too</strong></em>.</p>
</blockquote>
<h2 id="断言assertions"><a class="header" href="#断言assertions">断言（Assertions）</a></h2>
<p>关于在开发Java程序的过程中，如何调试的问题，这里尚未涉及。相信大家是在命令行中学习Java语言的，就如同本书一直以来所做的那样。一旦成为了一名Java专业人员，就要决定使用某种集成开发环境了，就可能会用到别的调试工具。在过去的日子里，Java程序员要调试代码时，就会依赖大量贯穿于程序中间的 <code>System.out.println()</code> 语句，打印出当前变量的值，及“已达到此处”的消息，来检查流程控制是否正常工作。（第6章中已编写好的代码，就留下了代码中的一些<code>print</code>语句。）尔后一旦程序正确工作了，就要挨个地将所有这些 <code>System.out.println()</code> 语句再清理掉。这样做是繁琐且易于出错的。而自Java 1.4（即 5.0） 版本开始，程序调试就变得容易得多了。那么答案到底是什么呢？</p>
<h3 id="断言assertions-1"><a class="header" href="#断言assertions-1">断言（Assertions）</a></h3>
<p>断言就跟吃了兴奋剂的 <code>System.out.println()</code>语句一样。把断言添加到代码，就跟加入了 <code>println</code> 语句是一样的。Java 5.0 的编译器，假定即将编译的源文件是兼容 5.0 版本的，那么自 Java 5.0 开始，默认就开启了带断言的编译了。</p>
<p>在运行时，若什么也没做，那么添加到代码的那些断言语句，就会被JVM忽略，且不会减慢程序运行。但在告诉了JVM <em>开启</em> 那些断言时，在无需修改任何一行代码的情况下，这些断言就将有助于程序调试！</p>
<p>一些人曾抱怨，这必将在生产代码中留下这些断言语句，然而在代码已经部署在现场时，将这些断言语句留下来，会是相当有价值的。在客户遇到问题时，就可以指导他们在开启断言下，运行程序，然后让客户将输出发送过来。而在把这些断言从代码中剥离出来时，就永久失去了这样的选项了。同时保留下断言语句，并没有任何缺点；在断言未被开启时，他们是完全被JVM忽略的，因此并没有任何需要担心的性能问题。</p>
<h3 id="怎样让断言发挥作用"><a class="header" href="#怎样让断言发挥作用">怎样让断言发挥作用</a></h3>
<p><strong>How to make <code>Assertion</code>s work</strong></p>
<p>在任何自认为某个事情 <em>必定为真</em> 的地方，加入断言语句。比如：</p>
<pre><code class="language-java">assert (height &gt; 0);
// 若 height &gt; 0 为真，那么程序将正常继续运行；
// 若为假，那么将抛出一个 AssertionError 异常
</code></pre>
<p>而通过下面这样写，就可以将更多信息添加到栈轨迹（the stack trace）：</p>
<pre><code class="language-java">assert (height &gt; 0) : String.format(&quot;height = %d weight = %d&quot;, height, weight);
</code></pre>
<h3 id="带有断言的编译和运行"><a class="header" href="#带有断言的编译和运行">带有断言的编译和运行</a></h3>
<p><strong>Compiling and running with <code>Assetion</code>s</strong></p>
<p>带有断言的 <em>编译</em>，与普通编译一样，不需要特定的命令行选项。</p>
<p>而带有断言的 <em>运行</em>：</p>
<pre><code class="language-console">java -ea TestDrive
</code></pre>
<h2 id="代码块作用域block-scope"><a class="header" href="#代码块作用域block-scope">代码块作用域（Block Scope）</a></h2>
<p>在第9章里，曾讲到本地变量，是如何仅伴随驻留在栈上、其被声明所在的方法而存活的（In chapter 9, we talked about how local variables live only as long as the method in which they're declared stays on the stack）。然而一些变量甚至会有着 <strong>更短</strong> 的生命周期。在方法内部，常常会创建一些代码 <em>块</em>。虽然之前一直都在这样做，但还不曾特意 <em>讨论</em> 过 <em>代码块</em> 这个说法。典型的代码块，是出现在方法里面的，且是由花括弧 <code>{}</code> 界定出来。后续将见到的一些常见代码块，包括了循环（<code>for</code>、<code>while</code>）及条件表达式（比如 <code>if</code> 语句）等。</p>
<p>来看看这个示例：</p>
<pre><code class="language-java">//               ↙ 方法代码块的开始
void doStuff () {
    // 作用范围为整个方法的本地变量
    int x = 0;

    //                           ↙ for 循环代码块的开头，同时 y 的作用范围仅限这个 for 循环！
    for (int y = 0; y &lt; 5; y++) {
        // 这里没有问题，x 与 y 都是在作用域
        x = x + y;
//   ↙ 这是 for 循环代码块的结束
    }

    // 哎呀！这不会编译！这里的 y 是超出作用域了！（注意，这是与某些其他语言工作方式所不同的！）
    x = x * y;
}
</code></pre>
<p>在上个示例中，<code>y</code>是个块级变量，是在一个块中被声明的，同时在那个 <code>for</code> 循环结束时，<code>y</code> 就立即失去了其作用域了。<em><strong>尽可能地优先使用本地变量而不是实例变量，进而优先使用块级变量而非本地变量，将令到所编写的 Java 程序更具可调试性与扩展性（Your Java programs will be more debuggable and expandable if you use local variables instead of instance variables, and block variables instead of local variables, whenever possible）</strong></em>。编译器将确保代码编写者没有尝试使用已超出作用范围的变量，因此不必担心运行时崩溃问题。</p>
<h2 id="链式调用运行linked-invocations"><a class="header" href="#链式调用运行linked-invocations">链式调用/运行（Linked Invocations）</a></h2>
<p>由于本书尽量维持语法尽可能简洁和易读，因此本书中用到这个特性的地方很少。但在Java中，是有着许多合法捷径的，这些是在今后肯定会碰到的，尤其是在阅读其他人写的代码的时候。会遇到较为常见的代码结构之一，便是被称作 <em>链式调用/运行</em> 的东西。比如：</p>
<pre><code class="language-java">StringBuffer sb = new StringBuffer (&quot;spring&quot;);
sb = sb.delete(3, 6).insert(2, &quot;umme&quot;).deleteCharAt(1);
System.out.format(&quot;sb = %s&quot;, sb);
// 运行结果为：sb = summer
</code></pre>
<p>在上面代码的第二行，到底发生了什么呢？固然，这是个刻意为之的示例，不过仍需掌握该怎么去解读这些东西。</p>
<ol>
<li>
<p>是从左往右进行处理的；</p>
</li>
<li>
<p>找出最左边方法调用的结果，此示例中即为 <code>sb.delete(3, 6)</code>。在检查了 API 文档中的 <code>StringBuffer</code>类后，就会发现这个 <code>delete()</code> 方法返回的是一个 <code>StringBuffer</code> 对象。运行 <code>delete()</code> 方法的结果，是个值为 <code>spr</code> 的 <code>StringBuffer</code> 对象；</p>
</li>
<li>
<p>接下来最左边的方法（<code>insert()</code>）是在新创建出的 <code>StringBuffer</code> 对象 <code>spr</code> 上调用的。该方法调用（即 <code>insert()</code> 方法）的结果，<em>同样</em> 是个 <code>StringBuffer</code> 对象（虽然该方法返回值不必与前一方法返回值类型一致），同时随着程序继续运行，所返回的对象又被用于右边的下一方法。理论上，在单个语句中是可以链接任意多想要的方法（虽然很少见到在一个语句中有多余三个链接方法）。若没有这样的链接特性，那么上面的第二行代码，将更具可读性，而看起来像下面这样：</p>
</li>
</ol>
<pre><code class="language-java">sb = sb.delete(3, 6);
sb = sb.insert(2, &quot;umme&quot;);
sb = sb.deleteCharAt(1);
</code></pre>
<p>但还有一个之前曾见到用过的、更为常见而有用的实例，这里认为应该再次指出来。那就是在 <code>main()</code> 方法需要运行主类的一个实例方法，而又不需要保留一个到该类实例的 <em>引用变量</em> 时。也就是说，<code>main()</code>方法为可以运行此实例的 <em>方法</em> 之一，<em>仅</em>需要创建该实例即可。</p>
<pre><code class="language-java">class Foo {
    public static void main (String[] args) {
        // 这里是要调用 go() 方法，而并不在意那个 Foo 的实例，因此就
        // 没有刻意把这个新的 Foo 对象赋值给某个引用变量了。
        new Foo().go();
    }

    void go () {
        // 这里是那些真正想要的......
    }
}
</code></pre>
<h2 id="匿名及静态嵌套类"><a class="header" href="#匿名及静态嵌套类">匿名及静态嵌套类</a></h2>
<p><strong>Anonymous and Static Nested Classes</strong></p>
<h3 id="嵌套类有着多种形式"><a class="header" href="#嵌套类有着多种形式">嵌套类有着多种形式</a></h3>
<p><strong>Nested classes come in many flavors</strong></p>
<p>在本书的 GUI 事件处理章节，开始将内部（嵌套）类用作实现事件收听器接口的一个解决办法。那正是内部类的最常见、最实用及最具可读性的一种形式 -- 其中用到的类，是简单地嵌套在另一包含他们类的花括弧里头的（That's the most common, practical, and readable form of an inner class--where the class is simply nested within the curly braces of another enclosing class）。同时请记住，因为内部类是外部/包覆类的成员，这就意味着为了获取到一个内部类的实例，是需要外部类的一个实例的。</p>
<p>然而，还有一些其他种类的内部类，包括 <em>静态</em> 及 <em>匿名</em> 的内部类。这里不会涉及到细节性的东西，但这里又不愿让你在看到一些人的代码中，奇怪语法时被震惊到。这是因为在Java语言下所能做的任何事情里头，或许没有什么能比匿名内部类，产生出更加怪模怪样的代码了。不过这里是要从一些更简单的东西开始 -- 静态嵌套类（Because out of virtually anything you can do with the Java language, perhaps nothing produces more bizarre-looking code than anonymous inner classes. But we'll start with something simpler--static nested classes）。</p>
<h3 id="静态嵌套类static-nested-classes"><a class="header" href="#静态嵌套类static-nested-classes">静态嵌套类（Static nested classes）</a></h3>
<p>这里已知 <code>static</code> 的意思 -- 一些与类，而非特定实例捆绑的东西。而静态嵌套类，除了被关键字 <code>static</code> 标记了外，则与那些用于事件收听器的非静态类看起来是差不多的。</p>
<pre><code class="language-java">package com.xfoss.Appendix;

class FooOuter {
    // 静态嵌套类只是 -- 包含在另一个类中，并用 static 标识符
    // 标记了的类。
    static class BarInner {
        void sayIt () {
            System.out.println(&quot;一个静态内部类的方法&quot;);
        }
    }
}

public class TestDrive {
    public static void main (String[] args) {
        // 由于静态嵌套类是......静态的，因此就不会用到外部类的实例。而只
        // 使用这个静态嵌套类的名称，这与运行静态方法或访问静态变量的方式
        // 是一致的。
        FooOuter.BarInner foo = new FooOuter.BarInner();
        foo.sayIt();
    }
}
</code></pre>
<h3 id="嵌套与内部类之间的区别"><a class="header" href="#嵌套与内部类之间的区别">嵌套与内部类之间的区别</a></h3>
<p><strong>The difference between <em>nested</em> and <em>inner</em></strong></p>
<p>所有定义在别的类作用范围内部的Java类，都被称作是 <em><strong>嵌套（nested）</strong></em> 类。而不管这个类是匿名的、静态的，还是正常的。只要他是在另一个类里头，那么技术上将，他就是个 <em>嵌套</em> 类。但那些 <em>非静态</em> 嵌套类，通常被称为是 <em>内部</em> 类，也就是本书早先叫做的那样。底线则是：所有内部类都是嵌套类，但并非所有嵌套类都是内部类。</p>
<h3 id="匿名内部类"><a class="header" href="#匿名内部类">匿名内部类</a></h3>
<p>请设想正在编写一些 GUI 代码，而猛然意识到需要某个实现了 <code>ActionListener</code> 类的实例。却发现手头并没有一个 <code>ActionListener</code> 类型的实例。进而意识到还不曾编写过那种收听器的 <em>类</em>。这个时候有两个选择：</p>
<ol>
<li>
<p>在代码中编写一个内部类，也就是前面GUI代码中所做的那种方式，进而对其初始化并将得到的实例，传入到按钮的事件注册（<code>addActionListener()</code>）方法；</p>
<p>或者</p>
</li>
<li>
<p>就在这里，立即创建一个 <em>匿名</em> 内部类并对其进行初始化。<em><strong>明确地就在需要收听器类型对象的地方</strong></em>。没错，就是在通常要提供到实例的地方，创建类和相应的实例。请稍加思考一下这种做法 -- 那意味着是在通常只传入一个 <em>实例</em> 到方法参数的地方，传入了整个的 <em>类</em>！</p>
</li>
</ol>
<pre><code class="language-java">package com.xfoss.Appendix;

import java.awt.event.*;
import javax.swing.*;

public class TestAnon extends JFrame {

    public static void main (String[] args) {
        new TestAnon();
    }

    public TestAnon () {

        // 这里构造了一个视窗框，并添加了一个按钮，现在需要将
        // 一个动作事件收听器注册到整个按钮。只是这里并没有构造
        // 一个实现了 ActionListener 接口的类......
        super(&quot;TestAnon&quot;);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JButton btn = new JButton (&quot;点击&quot;);
        // 正常情况下是要像下面这样做的--传入一个到某个内部类 -- 一个实现
        // 了 ActionListener 接口（已经 actionPerformed() 方法）的内部类，实例
        // 的引用变量......
        // btn.addActionListener(quitListener);

        // 不过现在传入不再是个引用变量，这里传入的是......整个新类的定义！！
        // 也就是说，这里是在正好需要那个类的地方，直接写出的那个实现了
        // ActionListener 接口的类。这种语法还自动创建了一个该类的实例。
        //
        // 请注意尽管 ActionListener 是个接口，但这里仍是写的 “new ActionListener()” 
        // 而这样是无法构造出 ActionListener 类型的一个实例的！但这种语法真正的意义
        // 在于，“创建一个新的，实现了 ActionListener 接口的类（不带名字），并顺便
        // 在接下来提供到该接口所需的方法实现，即这里的 actionPerformed()”。
        btn.addActionListener(new ActionListener () {
            public void actionPerformed (ActionEvent ev) {
                System.exit(0);
            }
        }); // 整个语句到这里才算结束！

        getContentPane().add(btn);

        setBounds(50, 50, 640, 480);
        pack();
        setVisible(true);
    }
}
</code></pre>
<h2 id="访问级别与访问修饰符谁看见什么的问题"><a class="header" href="#访问级别与访问修饰符谁看见什么的问题">访问级别与访问修饰符（谁看见什么的问题）</a></h2>
<p><strong>Access Levels and Access Modifiers(Who Sees What)</strong></p>
<p>Java 语言有着 <em>四个</em> 访问 <em>级别</em>，以及 <em>三个</em> 访问 <em>修饰符</em>。之所以只有 <em>三个</em> 修饰符，是因为 <em>默认的那个</em> （即在不使用任何访问修饰符时所得到的） <em>即为</em> 四个访问级别之一。</p>
<h3 id="访问级别"><a class="header" href="#访问级别">访问级别</a></h3>
<p>（以他们各自限制程度排序，自最少限制到最大限制，in order of how restritive they are, from least to most restrictive）</p>
<ul>
<li><code>public</code> &lt;-- <code>public</code> 访问级别表示任何地方的任何代码，都可以访问公开物件（这里的“物件”，指的是类、变量、方法、构造器等等）；</li>
<li><code>protected</code> &lt;-- 除了允许打包外部对<code>protected</code>装饰的物件进行子类化，从而对其进行继承外，与默认（不带访问级别修饰符）方式工作完全类似，即同一打包中有着访问权限（<code>protected</code> works just like default(code in the same package has access), EXCEPT it also allows subclasses outside the package to inherit the protected thing）；</li>
<li><code>default</code> &lt;-- <code>default</code> 访问级别表示只有与具有<code>default</code>物件类在同一打包里头的代码，才能访问到该<code>default</code>的物件（<code>default</code> access means that only code within the same package as the class with the default thing can access the <code>default</code> thing）；</li>
<li><code>private</code> &lt;-- <code>private</code> 访问级别表示只有同一类里头的代码，才能访问到该 <code>private</code> 物件。请记住这表示对类是<code>private</code>的，而非相对对象。一个 <code>Dog</code>对象可以看到另一<code>Dog</code>对象的私有成员，但<code>Cat</code>对象是无法看到<code>Dog</code>对象的私有成员的。</li>
</ul>
<h3 id="访问装饰符access-modifiers"><a class="header" href="#访问装饰符access-modifiers">访问装饰符（Access modifiers）</a></h3>
<pre><code class="language-java">public 
protected
private
</code></pre>
<p>多数时间都将只会用到 <code>public</code> 与 <code>private</code> 访问级别。</p>
<h3 id="public"><a class="header" href="#public"><code>public</code></a></h3>
<p>对于类、常量（<code>static final</code>的变量），与那些要暴露给其他代码的方法（比如访问器和设置器），以及多数的构造器，就要使用 <code>public</code> 访问级别装饰符。</p>
<h3 id="private"><a class="header" href="#private"><code>private</code></a></h3>
<p>显然对于全部的实例变量，还有那些不打算外部代码调用到的方法（也就是说，被自己类中 <code>public</code> 方法使用的那些方法），请使用 <code>private</code> 装饰符。</p>
<p>由于在其他人的代码中会见到另外两个装饰符（<code>protected</code>与<code>default</code>），因此尽管不大会用到另外两个装饰符（<code>protected</code> 与 <code>default</code>），还是要知道他们的作用。</p>
<h3 id="default-与-protected"><a class="header" href="#default-与-protected"><code>default</code> 与 <code>protected</code></a></h3>
<p><strong><code>default</code></strong></p>
<p><code>protected</code> 与 <code>default</code> 二者都是捆绑到封包的。默认访问级别比较简单 -- 表示只有 <em>同一封包里头</em> 的代码，才能访问带有默认访问级别的代码。那么比如对于某个<code>default</code>的类（这表示一个未被显示地声明为 <code>public</code> 的类），就只能被与该默认类在同一封包的其他类访问。</p>
<p>然而所谓 <em>访问</em> 某个类，到底指的是什么呢？无权访问某个类的代码，甚至连 <em>想想</em> 该类都是不允许的（Code that does not have access to a class is not allowed to even <em>think</em> aobut the class）。而这里所说的 “想想”，指的是在代码中 <em>使用到</em> 整个类。比如，在由于访问限制，而没有对某个类的访问权限时，是不允许对整个类进行初始化，或者甚至不能用这个类来声明变量、参数或返回值类型的。直接就不可以将其敲入到你的代码中！若执意要敲入，那么编译器就会报出错误。</p>
<p>请思考一下深层次的影响 -- 即使一些方法是<code>public</code>的，但如果这些方法是在一个默认类中，那么这些 <code>public</code> 的方法，也并非真的是 <code>public</code> 的了。在没法 <code>看到</code> 类的时候，也就无法访问其中的方法了。</p>
<p>那为什么要将访问级别限制到只在同一封包内部呢？通常封包是设计为一组以一种关联集合方式工作的类（Typically, packages are designed as a group of classes that work together as a related set）。这样同一封包中的类，需要访问另一类的代码，就说得通了，同时作为一个封包，仅有少量类和方法暴露给外部世界（即封包外面的代码）。</p>
<p>好吧，这就是 <code>default</code> 访问级别了。他是简单的 -- 在某个物件有着 <code>default</code> 访问级别时（请记住，这指的就是没有显式访问级别修饰符！），那么就只有与那个 <code>default</code> <em>物件</em>（类、变量、方法、内部类） 在同一封包里头的代码，才能访问那个 <em>物件</em>。</p>
<p><strong><code>protected</code></strong></p>
<p>受保护访问级别，与默认访问级别极为相似，只是有一个例外：<em>即使子类在所扩展超类封包外部</em>，这些子类仍运行 <em>继承</em> 受保护的物件。这就是了。这就是使用 <code>protected</code> 访问级别的全部好处 -- 这种实现了即使在超类所在封包外部的子类，也仍然 <em>继承到</em> 该超类包括方法与构造器等的组成部分（Protected access is almost identical to default access, with one exception: it allows subclasses to <em>inherit</em> the protected thing, <em>even if those subclasses are outside the package of the superclass they extend</em>. That's it. That's <em>all</em> <code>protected</code> buys you--the ability to let your subclasses be outside your superclass package, yet still <em>inherit</em> pieces of the class, including methods and constructors）。</p>
<p>虽然许多开发者都发现，使用 <code>protected</code> 的理由极少，不过在一些设计中会用到他，同时终有一天你会发现他正是所要的访问级别。<code>protected</code>访问级别有趣的地方之一，就是--与其他访问级别不同--<code>protected</code>访问级别只使用于 <em>继承</em> 方面。在某个位处封包外部的子类有着到该超类（比如说这个超类有着一个 <code>protected</code> 的方法）的一个实例的 <em>引用变量</em> 时，那么这个子类是无法使用该超类类型的引用变量，访问到那个受保护方法的（One of the interesting things about <code>protected</code> is that--unlike the other access levels--<code>protected</code> access applies only to <em>inheritance</em>. If a subclass-outside-the-package has a <em>reference</em> to an instance of the superclass(the superclass that has, say, a <code>protected</code> method), the subclass can't access the protected method using that superclass reference）！该子类要能访问那个方法的唯一途径，就是通过 <em>继承到</em> 那个方法。也就是说，位处封包外部的子类，不具有对受保护方法的 <em>访问权限</em>，他只是<em>拥有</em> 经由继承得来的那个方法。</p>
<h2 id="string-类与-stringbufferstringbuilder-的那些方法"><a class="header" href="#string-类与-stringbufferstringbuilder-的那些方法"><code>String</code> 类与 <code>StringBuffer</code>/<code>StringBuilder</code> 的那些方法</a></h2>
<p>Java API 中最常用到的两个类，分别是 <code>String</code> 与 <code>StringBuffer</code> （还记得前面的 #9 就提到，<code>String</code>都是不可更改的，那么这里的<code>StringBuffer</code>/<code>StringBuilder</code>在要操作字符串时，要高效得多了）。而自Java 5.0 开始，除非是不常见的、需要线程安全的字符串操作，那么就应使用 <code>StringBuilder</code> 而不是 <code>StringBuffer</code>。下面是这些类中 <strong>关键</strong> 方法的简要概述：</p>
<h3 id="string-与-stringbufferstringbuilder-都有的方法"><a class="header" href="#string-与-stringbufferstringbuilder-都有的方法"><em><code>String</code> 与 <code>StringBuffer</code>/<code>StringBuilder</code> 都有的方法</em>：</a></h3>
<pre><code class="language-java">char charAt(int index);                 // 在确切位置处是什么字符
int length();                           // 这个字符串对象有多长
String substring(int start, int end);   // 获取此对象的一部分
String toString();                      // 该 String 对象的字符串值是什么
</code></pre>
<h3 id="要连接字符串to-concatenate-strings"><a class="header" href="#要连接字符串to-concatenate-strings"><em>要连接字符串（to concatenate Strings）</em>:</a></h3>
<pre><code class="language-java">String concat(string);                  // 对于 String 类
String append(String);                  // 对于 StringBuffer 与 StringBuilder
</code></pre>
<h3 id="string类有这些方法"><a class="header" href="#string类有这些方法"><em><code>String</code>类有这些方法</em>：</a></h3>
<pre><code class="language-java">String replace(char old, char new);     // 替换所有出现的某个字符
String substring(int begin, int end);   // 获取某个字符串的一部分
char [] toCharArray();                  // 转化为字符数组
String toLowerCase();                   // 将所有字符转为小写
String toUpperCase();                   // 将所有字符转为大写
String trim();                          // 移除两端的空白字符
String valueOf(char []);                // 从字符数组构造处一个 String 对象
String valueOf(int i);                  // 从某个原生值构造出一个 String 对象，也支持其他类型的原生值
</code></pre>
<h3 id="stringbuffer与stringbuilder有着的方法"><a class="header" href="#stringbuffer与stringbuilder有着的方法"><em><code>StringBuffer</code>与<code>StringBuilder</code>有着的方法</em>：</a></h3>
<pre><code class="language-java">StringB... delete(int start, int end);                      // 删除某个部分
StringB... insert(int offset, any primitive or a char[]);   // 插入一些东西
StringB... replace(int start, int end, String s);           // 使用这个字符串替换该部分
StringB... reverse();                                       // 从前往后逆转这个 StringB... 对象
void setCharAt(int index, char ch);                         // 替换指定的字符
</code></pre>
<blockquote>
<p><em>注意</em>：这里的 <code>StringB...</code> 既表示 <code>StringBuffer</code> 也表示 <code>StringBuilder</code>。</p>
</blockquote>
<h2 id="多维数组multidimensional-arrays"><a class="header" href="#多维数组multidimensional-arrays">多维数组（Multidimensional Arrays）</a></h2>
<p>在多数语言中，在创建一个比如 4x2 的二维数组时，将会设想一个 4 个元素乘以 2 个元素，总共 8 个元素的矩形。然而在Java中，这样的数组实际上将是链接起来的 5 个数组！在Java中，二维数组直接就是个 <strong>数组的数组</strong>（In java, a two dimensional array is simply <em>an array of arrays</em>）。（而三维数组，则是个数组的数组的数组，而这里将把三维数组留给你自己去玩。）下面就是其工作原理</p>
<pre><code class="language-java">int[][] a2d = new int[4][2];
</code></pre>
<p>根据这个语句，JVM 创建出有 4 个元素的数组。该数组中 <em>每个的</em> 元素，实际上都是到某个（新近创建出的）、有着 2 个元素的 <code>int</code> 数组的引用变量。</p>
<p><img src="images/Ch19_01.png" alt="Java中一个二维整型数组的数据结构" /></p>
<p><em>图 1 - Java中一个二维整型数组的数据结构</em></p>
<h3 id="多维数组的使用"><a class="header" href="#多维数组的使用">多维数组的使用</a></h3>
<ul>
<li>要访问第三个数组中的第二个元素：<code>int x = a2d[2][1];   // 请记住，索引是基于 0 的！</code>;</li>
<li>要构造一个到这些子数组之一的一维数组引用变量：<code>int[] copy = a2d[1];</code>;</li>
<li>某个 <code>2 x 3</code> 数组的便捷初始化：<code>int [][] x = { {2, 3, 4}, {7, 8, 9} };</code>;</li>
<li>要构造一个有着不规则尺寸的二维数组（非对齐的、子数组长短不一的）：</li>
</ul>
<pre><code class="language-java">int[][] y = new int[2][];   // 仅构造那个长度为 2 的前一个数组
y[0] = new int [3];     // 构造第一个长度为 3 的子数组
y[1] = new int [5];     // 构造第二个长度为 5 的子数组
</code></pre>
<p><strong>还有一个排在第一位的、难以搞明白的东西</strong>......</p>
<h2 id="枚举也叫做枚举类型或-enums"><a class="header" href="#枚举也叫做枚举类型或-enums">枚举（也叫做枚举类型或 <code>Enums</code>）</a></h2>
<p><strong>Enumerations(also called Enumerated Types or Enums)</strong></p>
<p>本书中曾讲到过一些定义在 API 中的常量，比如，<code>JFrame.EXIT_ON_CLOSE</code>。通过将某个变量标记为 <code>static final</code>，也可以创建我们自己的常量。然而在某些时候，会打算创建一套常量值，来表示某个变量 <em><strong>仅有的</strong></em> 有效值（But sometimes you'll want to create a set of constant values to represent the <em><strong>only</strong></em> valid values for a variable）。那么这套有效值，通常指的就是 <em>枚举</em>。在Java 5.0 之前，就只能在Java中进行半成品的枚举创建。而自Java 5.0起，就可以创建出成熟的、将为你的那些使用 Java 5.0 之前版本的朋友羡慕的枚举了。</p>
<h3 id="乐队里都有谁whos-in-the-band"><a class="header" href="#乐队里都有谁whos-in-the-band">乐队里都有谁（Who's in the band）？</a></h3>
<p>这里假设是在创建一个喜爱乐队的网站，进而是要确保所有评论都被导向到某名特定乐队成员。</p>
<h3 id="老式的模仿出一个假的-enum"><a class="header" href="#老式的模仿出一个假的-enum">老式的模仿出一个假的 “enum”:</a></h3>
<pre><code>public static final int JERRY = 1;
public static final int BOBBY = 2;
public static final int PHIL = 3;

// 后面的代码

// 我们正希望在此处获取到的 selectedBandMember 有着一个有效值！
if(selectedBandMember == JERRY) {
    // 完成有关JERRY 的事情
}
</code></pre>
<p>这种技巧好的一面，是他确实令到代码更加容易阅读了。而另一个好苗头，则是甚至无法修改所创建的假冒枚举的值；<code>JERRY</code> 将始终为 <code>1</code>。这样做负面的地方，就是没有一种轻易或良好的方法，来确保<code>selectedBandMember</code>将始终为 <code>1</code>、<code>2</code>或 <code>3</code>。若一些隐藏很深的代码把 <code>selectedBandMember</code> 设置为了等于 <code>812</code>，那么这代码就会几近崩溃的......</p>
<p>对于这同样情形，使用纯粹的Java 5.0 枚举特性，就不一样了。尽管这是个非常基础的枚举，但大多数枚举通常 <em>都是</em> 这样简单的。</p>
<h3 id="新的正牌的-枚举"><a class="header" href="#新的正牌的-枚举">新的、正牌的 “枚举”：</a></h3>
<pre><code class="language-java">// 这种类型看起来是不是像个简单的类定义啊？事实证明枚举确实
// 是一种特殊的类。这里创建了一个叫做 “Members&quot; 的枚举类型。
public enum Members { JERRY, BOBBY, PHIL };
// 这个 ”selectedBandMember&quot; 即为类型 “Members&quot; 的，且他只能有
// ”JERRY“、”BOBBY“ 或 ”PHIL” 三个值之一。
public Memebers selectedBandMember;

// 后续代码

// Members.JERRY 这样的语法，是对一个枚举 “实例” 的引用。
// 
// 现在就无需担心selectedBandMember这个变量的值了！
if ( selectedBandMember == Members.JERRY ) {
    // 执行 JERRY 相关的事情
}
</code></pre>
<p><strong>用到的<code>enum</code>类型，都对 <code>java.lang.Enum</code> 类进行了扩展</strong></p>
<p>在创建某个 <code>enum</code> 类型时，（本质上）是在创建一个新类，并且还 <em><strong>是在隐式地扩展着 <code>java.lang.Enum</code> 类</strong></em>。是可以在枚举自己的源文件中，将枚举声明为其独有类，当然也可以作为别的类成员而声明（You can declare an enum as its own standalone class, in its own source file, or as a member of another class）。</p>
<p><strong>在枚举下使用 <code>if</code> 与 <code>switch</code> 语句</strong></p>
<p>运用刚才创建出的枚举类型，就可以使用 <code>if</code> 或 <code>switch</code> 语句，实现代码里的分支（Using the enum we just created, we can perform branches in our code using either <code>if</code> or <code>switch</code> statement）。还请注意这里既可以使用 <code>==</code>，或者 <code>.equals()</code> 方法，来对枚举类型实例进行比较。使用 <code>==</code> 被认为是更佳风格。</p>
<pre><code class="language-java">// 将枚举值赋值给枚举类型的变量。
Members n = Members.BOBBY;
// 这两个语句工作正常！会打印出 “Rat Dog&quot;。
if (n.equals(Members.JERRY)) System.out.println(&quot;Jerrrrry!&quot;);
if (n == Members.BOBBY) System.out.println(&quot;Rat Dog&quot;);

Members ifName = Members.PHIL;
// 突击测验！输出会是什么呢？
// 答案：¡ʎpᴉssɐƆ dǝǝp oƃ
switch (ifName) {
    case JERRY: System.out.print(&quot;make it sing &quot;);
    case PHIL: System.out.print(&quot;go deep &quot;);
    case BOBBY: System.out.print(&quot;Cassidy! &quot;);
}
</code></pre>
<p><strong>类似枚举的真正迷惑人的版本（a really tricked-out version of a silimar enum）</strong></p>
<p>可将诸如构造器、方法、变量，以及一些叫做常量专用的类代码体等的一大批物件，添加到枚举（You can add a bunch of things to your enum like a constructor, methods, variables, and someting called a constant-specific class body）。虽然他们并不常见，但或许会偶遇到这些语法。</p>
<pre><code class="language-java">package com.xfoss.Appendix;

public class HfjEnum {
    enum Names {
        // 这里的 “lead guitar” 是个传入到底下声明的构造器
        // 的参数。
        JERRY(&quot;lead guitar&quot;) { 
            // 花括符中的这些，这些就是叫做“常量专用的类代码体（
            // constant-specific class bodies）” 的东西。在枚举
            // 定义中的基本方法sing() 于JERRY 或 BOBBY 上调用到时，请将
            // 他们想作是对基本枚举方法（也就是那个本示例中的&quot;sing()&quot;
            // 方法）的重写。
            public String sings (){
                return &quot;plaintively&quot;;
            }
        },
        BOBBY(&quot;rhythm guitar&quot;) {
            public String sings () {
                return &quot;hoarsely&quot;;
            }
        },
        PHIL(&quot;bass&quot;);

        private String instrument;

        // 这是该枚举的构造器。对于每个声明的枚举值，他都会运行
        // 一次（本示例中这个构造器会运行三次）。
        Names (String instrument) {
            this.instrument = instrument;
        }

        // 下面两个方法，会在 &quot;main()&quot; 方法中被调用到。
        public String getInstrument () {
            return this.instrument;
        }

        public String sings () {
            return &quot;occasionally&quot;;
        }
    }

    public static void main (String[] args) {
        // 所有枚举类型，都带有一个内建的 &quot;values()&quot; 方法，该
        // 方法一般是像下面这样，用在 “for&quot; 循环中的。
        for (Names n : Names.values()) {
            System.out.format(&quot;%s, 他的乐器是：%s, 他演唱的是：%s\n&quot;, 
                    n, n.getInstrument(), n.sings());
        }
    }
}
</code></pre>
<p>该程序的运行结果：</p>
<pre><code class="language-console">$java -jar build/libs/com.xfoss.learningJava-0.0.1.jar
JERRY, 他的乐器是：lead guitar, 他演唱的是：plaintively
BOBBY, 他的乐器是：rhythm guitar, 他演唱的是：hoarsely
PHIL, 他的乐器是：bass, 他演唱的是：occasionally
</code></pre>
<blockquote>
<p>请注意，只有在枚举值没有“常量专用类代码体（constant-specific class body）”的时候，才会调用到那个基本的 <code>sing()</code> 方法。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录b其他特性"><a class="header" href="#附录b其他特性">附录B：其他特性</a></h1>
<h2 id="注解语法"><a class="header" href="#注解语法">注解语法</a></h2>
<p><strong>Annotations</strong></p>
<p><em>注解</em>，是元数据的一种形式，提供了不作为程序本身部分的、有关程序的一些数据。注解对其所注解代码运作，并未直接影响（<em>Annotations</em>, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate）。</p>
<p>注解有着多种用途，这些用途中：</p>
<ul>
<li><strong>为编译器提供信息</strong> -- 编译器可使用注解来探测错误或抑制告警信息（<strong>Information for the compiler</strong> -- Annotations can be used by the compiler to detect errors or suppress warnings）；</li>
<li><strong>编译时与部署时的处理</strong> -- 软件工具可对注解信息加以处理，从而生成代码、XML文件等等（<strong>Compile-time and deployment-time processing</strong> -- Software tools can process annotation information to generate code, XML files, and so forth）;</li>
<li><strong>运行时的处理</strong> -- 在运行时，可对一些注解进行检查（<strong>Runtime processing</strong> -- Some annotations are available to be examined at runtime）。</li>
</ul>
<p>本课程解释了：</p>
<ul>
<li><a href="Ch20_Appendix_B.html#where">哪些地方可以使用注解语法</a>、</li>
<li>如何运用注解语法、</li>
<li><a href="Ch20_Appendix_B.html#predefined-annotation-types">Java 平台以及标准版（Standard Edtion, Java SE API）中有哪些可用的预定义好的注解类型（annotation types）</a>、</li>
<li><a href="Ch20_Appendix_B.html#type-annotations-and-pluggable-type-systems">类型注解如何与可插拔类型系统结合以编写出有着更强类型检查的代码</a>，</li>
<li><a href="Ch20_Appendix_B.html#repeating-annotations">以及怎样去实现重复性注解语法</a>。</li>
</ul>
<p>（This lesson explains where annotations can be used, how to apply annotations, what predefined annotation types are available in the Java Platform, Standard Edition(Java SE API), how type annotations can be used in conjuncton with pluggable type systems to write stronger type checking, and how to implement repeating annotations.）</p>
<h3 id="注解语法基础"><a class="header" href="#注解语法基础"><a id="annotations-basics"></a>注解语法基础</a></h3>
<p><strong>Annotations Basics</strong></p>
<h4 id="注解语法的形式"><a class="header" href="#注解语法的形式">注解语法的形式</a></h4>
<p><strong>The Format of an Annotation</strong></p>
<p>注解语法的最简单形式，看起来像下面这样：</p>
<pre><code class="language-java">@Entity
</code></pre>
<p>这个所在符号字符（<code>@</code>），是给编译器表明，接下来的是个注解。在下面的示例中，那个注解的名称为 <code>Override</code>:</p>
<pre><code class="language-java">@Override
void mySuperMethod() {...}
</code></pre>
<p>注解可以包含 <em>元素（elements）</em>，元素可以是具名的或不具名的，同时存在着这些元素的值：</p>
<pre><code class="language-java">@Author (
    name = &quot;Benjamin Franklin&quot;,
    date = &quot;3/27/2003&quot;
)
class myClass {...}
</code></pre>
<p>或者：</p>
<pre><code class="language-java">@SuppressWarnings (value = &quot;unchecked&quot;)
void myMethod() {...}
</code></pre>
<p>在仅有一个名为 <code>value</code> 的元素时，那么元素名称是可以省略的，就像这样：</p>
<pre><code class="language-java">@SuppressWarnings (&quot;unchecked&quot;)
void myMethod () {...}
</code></pre>
<p>在注解没有元素时，那么那对括号是可以省略的，就如同在上面的 <code>Override</code> 示例中那样。</p>
<p>在同一声明上，使用多个注解也是可能的：</p>
<pre><code class="language-java">@Author (name = &quot;Jane Doe&quot;)
@EBook
class MyClass {...}
</code></pre>
<p>在若干注解有着同样类型时，此时就叫重复注解（a repeating annotation）：</p>
<pre><code class="language-java">@Author(name = &quot;Jane Doe&quot;)
@Author(name = &quot;John Smith&quot;)
class MyClass {...}
</code></pre>
<p>从 Java SE 8 发布才开始支持重复注解。更多的有关情况，请参考 <a href="Ch20_Appendix_B.html#repeating-annotations">重复注解</a></p>
<p>注解类型（a Annotation Type）可以是定义在 Java SE API 的 <code>java.lang</code> 或 <code>java.lang.annotation</code> 包中类型之一。在上面的示例中，<code>Override</code>与 <code>SuppressWarnings</code>，就是 <a href="Ch20_Appendix_B.html#predefined-annotation-types">预定义的Java 注解（predefined Java annotations）</a>。定义自己的注解类型，也是可能的。前面示例中的 <code>Author</code> 与 <code>EBook</code> 就属于自定义注解类型。</p>
<h4 id="哪些地方可以使用注解语法"><a class="header" href="#哪些地方可以使用注解语法"><a id="where"></a>哪些地方可以使用注解语法</a></h4>
<p>可在将注解应用在各种声明上：类、字段、方法，以及其他一些程序元素的声明。当在某个声明上运用了注解语法时，依照约定，每条注解常常占据自己的一行。</p>
<p>自Java SE 8 发布开始，注解语法还可应用到类型的 <em>运用</em>。下面是一些示例：</p>
<ul>
<li>应用到类实例的创建表达式：</li>
</ul>
<pre><code class="language-java">new @Interned MyObject();
</code></pre>
<ul>
<li>类型强制转换：</li>
</ul>
<pre><code class="language-java">myString = (@NonNull String) str;
</code></pre>
<ul>
<li><code>implements</code> 子语句（<code>implements</code> clause）：</li>
</ul>
<pre><code class="language-java">class UnmodifioableList&lt;T&gt; implements
    @Readonly List&lt;@Readonly T&gt; {...}
</code></pre>
<ul>
<li>抛出异常的声明（Thrown exception declarations）：</li>
</ul>
<pre><code class="language-java">void monitorTemperature() throws
    @Critical TemperatureException {...}
</code></pre>
<p>这种形式的注解，叫做 <em>类型注解（a type annotation）</em>。有关类型注解的更多信息，请参考 <a href="Ch20_Appendix_B.html#type-annotations-and-pluggable-type-systems">类型注解与可插拔类型系统（Type Annotations and Pluggable Type Systems）</a>。</p>
<h3 id="注解类型的声明"><a class="header" href="#注解类型的声明">注解类型的声明</a></h3>
<p><strong>Declaring a Annotation Type</strong></p>
<blockquote>
<p><strong>注</strong>：除了 <code>java.lang</code> 和 <code>java.lang.annotations</code> 包中预定义的注解类型，对应定制注解，均需先声明注解类型，才能使用该注解类型下的注解实例。所有注解类型，都是特殊的接口，类型为 <code>@interface</code>。</p>
</blockquote>
<p>许多的注解，在代码中都是起到替代注释的作用。</p>
<p>设想某个软件团队，他们在编写所有类的代码体时，传统上都是以提供这些类重要信息的注释开始的：</p>
<pre><code class="language-java">public class Generation3List extends Generation2List {
    // Author: John Doe
    // Date: 3/17/2002
    // Current revision: 6
    // Last modified: 4/12/2004
    // By: Jane Doe
    // Reviewers: Alice, Bill, Cindy
    
    // 真正的类代码从这里开始
}
</code></pre>
<p>而要以注解来加入这些同样元数据，就必须首先定义出这个 <em>注解类型（annotation type）</em>。定义此注解类型的语法为：</p>
<pre><code class="language-java">@interface ClassPreamble {
    String author();
    String date();
    int currentVersion() default 1;
    String lastModified() default &quot;N/A&quot;;
    String lastModifiedBy() default &quot;N/A&quot;;
    // 注意下面这个使用到数组
    String[] reviewers();
}
</code></pre>
<p>这个注解类型定义，看起来类似于接口定义，其中关键字 <code>interface</code> 前面冠以了位处符号（<code>@</code>）（当这个位处符号是在注解类型中时，就等于位处<code>AT</code>）。所有注解类型，都属于 <em>接口</em> 的一种形式，<a href="Ch08_Interfaces_and_Abstract_Classes.html#interface_rescue">本课程稍后</a>会讲到这一点。此刻还不需要掌握什么是接口。</p>
<p>上面注解定义的代码体，包含了 <em>注解类型元素（annotation type element）</em> 的一些声明，这些什么看起来很像是一些方法。请留意这些注解类型元素，可定义一些可选的默认值。</p>
<p>在注解类型定义好之后，带上填入的各个取值，就可以使用那种类型的注解了，如同下面这样：</p>
<pre><code class="language-java">@ClassPreamble {
    author = &quot;John Doe&quot;,
    date = &quot;3/17/2002&quot;,
    currentRevision = 6,
    lastModified = &quot;4/12/2004&quot;,
    lastModifiedBy = &quot;Jane Doe&quot;,
    // 请注意这里的数组注解
    reviewers = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cindy&quot;}
}
public class Generation3List extends Generation2List {
    // 类的代码从这里开始
}
</code></pre>
<blockquote>
<p><strong>注意</strong>：为了让 <code>@ClassPreamble</code> 中的信息，在 <code>Javadoc</code> 所生成的文档中出现，那么就必须以 <code>@Documented</code> 注解，来对 <code>@ClassPreamble</code> 的定义进行注解（To make the information in <code>@ClassPreamble</code> appear in <code>Javadoc-generated</code> documentation, you must annote the <code>@ClassPreamble</code> definition with the <code>@Documented</code> annotation）：</p>
</blockquote>
<pre><code class="language-java">// 为使用 @Documented 注解类型，就要导入该包
import java.lang.annotation.*;

@Documented
@interface ClassPreamble {
    // 那些注解元素的定义
}
</code></pre>
<h3 id="java中预定义的注解类型"><a class="header" href="#java中预定义的注解类型"><a id="predefined-annotation-types"></a>Java中预定义的注解类型</a></h3>
<p><strong>Predefined Annotation Types</strong></p>
<p>在 Java SE API 中，预先定义了一些注解类型。其中一些为Java编译器使用到，另一些是应用到别的注解的。</p>
<h4 id="java语言用到的注解类型"><a class="header" href="#java语言用到的注解类型">Java语言用到的注解类型</a></h4>
<p><strong>Annotation Types Used by the Java Language</strong></p>
<p>在包 <code>java.lang</code> 中预定义的注解类型为：<code>@Deprecated</code>、<code>@Override</code>及 <code>SuppressWarnings</code>。</p>
<ul>
<li><strong><code>@Deprecated</code></strong> <code>@Deprecated</code> 注解表明其所标记的元素，是 <em>已弃用的</em> 且不应再被使用。在程序使用了带有 <code>@Deprecated</code> 注解的方法、类或字段（实例变量）时，编译器就会生成一条告警信息。而在某个元素为已被弃用时，就应像下面这个示例一样，使用 <code>Javadoc</code> 的 <code>@deprecated</code> 标签，将其在文档中记录下来。在<code>Javadoc</code>的注释中，和在注解语法中同时使用位处符号（<code>@</code>）的做法，并非巧合：<code>Javadoc</code>与注解语法，在概念上是有关联的。同时，请留意<code>Javadoc</code>的标签是以小写的 <em><code>d</code></em> 打头的，而注解语法是以大写的 <code>D</code> 打头的。</li>
</ul>
<pre><code class="language-java">    // 接下来是 Javadoc 的注释
     /**
      * @deprecated
      * 给出了为何这个方法被弃用的解释
      */
     @Deprecated
     static void deprecatedMethod() {}
}
</code></pre>
<blockquote>
<p><strong>注意</strong>：<a href="https://stackoverflow.com/questions/40969698/deprecated-method-not-mentioned-in-javadoc">deprecated method not mentioned in javadoc</a>
<code>javadoc</code>默认只收集 <code>public</code> 或 <code>protected</code> 元素的文档。</p>
</blockquote>
<ul>
<li><strong><code>@Override</code></strong> <code>@Override</code> 注解告诉编译器，该元素是要重写在某个超类中声明的元素。在 <a href="Ch07_Inheritance_and_Polymorphism_Better_Living_in_Objectville.html">继承与多态机制</a> 中讨论了方法的重写。</li>
</ul>
<pre><code class="language-java">// 将方法标记为一个已被重写的超类方法
@Override
int overriddenMethod () {}
</code></pre>
<p>尽管在重写某个方法时，并不要求使用这个注解，不过这样做可以防止错误发生。在某个以 <code>@Override</code> 标记的方法，未能正确重写其超类的某个方法时，编译器就会生成一个错误消息。</p>
<ul>
<li><strong><code>@SuppressWarnings</code></strong> <code>@SuppressWarnings</code> 注解，告诉编译器要抑制一些本来会生成的告警信息。在下面的示例中，使用了某个已被弃用的方法，进而编译器一般会生成一条告警信息。不过在此实例中，由于这个注解，而导致该告警信息被抑制下来了。</li>
</ul>
<pre><code class="language-java">// 这里使用了一个已被弃用的方法，并告诉编译器不要生成一条告警消息
@SuppressWarnings (&quot;deprecation&quot;)
void useDeprecatedMethod () {
    // 这里的已被弃用告警，就被抑制了
    objectOne.deprecatedMethod();
}
</code></pre>
<p>所有编译器告警，都是属于某个类别的。Java 语言规范（The Java Language Specification）列出了两个类别：<code>deprecation</code> 与 <code>unchecked</code>。在碰到那些引入 <a href="Ch16_Collections_and_Generics_Data_Structure.html">泛型</a> 之前所编写的老旧代码时，其中的 <code>unchecked</code> 告警便会出现。要将这多个类别的告警给抑制掉，就要使用下面的语法：</p>
<pre><code class="language-java">@SuppressWarnings({&quot;unchecked&quot;, &quot;deprecation&quot;})
</code></pre>
<ul>
<li><strong><code>@SafeVarargs</code></strong> 在对某个方法或构造器应用 <code>@SafeVarargs</code> 注解时，就假定了代码不会在其 <code>varargs</code> 实参上，执行潜在不安全的操作。在使用了此注解类型时，那些未受检查的、与 <code>varargs</code> 有关的告警，就会被抑制（<code>@SafeVarargs</code> annotation, when applied to a method or constructor, asserts that the code does not perform potentially unsafe oprations on its <code>varargs</code> parameter. When this annotation type is used, unchecked warnings relating to <code>varargs</code> are suppressed）。</li>
<li><strong><code>@FunctionalInterface</code></strong> <code>@FunctionalInterface</code> 注解，是在 Java SE 8 中引入的，表示其所注解的类型声明，是计划作为Java语言规范中所定义的功能性接口（<code>@FunctionalInterface</code> annotation, introduced in Java SE 8, indicates that the type declaration is intended to be a functional interface, as defined by the Java Language Specification）。</li>
</ul>
<h4 id="适用于其他注解的注解"><a class="header" href="#适用于其他注解的注解">适用于其他注解的注解</a></h4>
<p><strong>Annotations That Apply to Other Annotations</strong></p>
<p>适用于其他注解的注解，叫做 <em>元注解（meta-annotations）</em>。在 <code>java.lang.annotation</code> 包中，定义了若干元注解类型。</p>
<ul>
<li><strong><code>@Retention</code></strong> <code>@Retention</code> 注解指定了所标记的那些注解该如何存储（<code>Retention</code> annotation specifies how the marked annotation is stored）:</li>
<li><strong><code>@Documented</code></strong> <code>@Documented</code> 注解表示不论指定注解在何时被使用到，那些元素都应使用 <code>Javadoc</code> 工具以文档化处理。（默认情况下，注解是没有包含在 <code>Javadoc</code> 中的。<code>@Documented</code> annotation indicates that whenever the specified annotation is used those elements should be documented using the <code>Javadoc</code> tool）。有关 <code>Javadoc</code> 的更多信息，请参考 <a href="Ch20_Appendix_B.html#javadoc-tool"><code>Javadoc</code> 工具部分</a>。</li>
</ul>
<ul>
<li>
<p><strong><code>Target</code></strong> <code>Target</code> 注解对另一注解进行标记，以限制所标记的注解可适用的Java元素种类。<code>@Target</code> 注解，会将以下的一些元素类型，指定为他的取值：</p>
<ul>
<li><code>ElementType.ANNOTATION_TYPE</code> - 被 <code>@Target</code> 注解标记的注解可适用于另一注解类型；</li>
<li><code>ElementType.CONSTRUCTOR</code> - 被其标记的注解可适用于构造器；</li>
<li><code>ElementType.FIELD</code> - 可适用于字段或属性；</li>
<li><code>ElementType.LOCAL_VARIABLE</code> - 可适用于本地变量；</li>
<li><code>ElementType.METHOD</code> - 可适用于方法级别的注解；</li>
<li><code>ElementType.PACKAGE</code> - 可适用于包的声明；</li>
<li><code>ElementType.PARAMETER</code> - 可适用于方法的参数；</li>
<li><code>ElementType.Type</code> - 可适用于类的任意元素。</li>
</ul>
</li>
</ul>
<ul>
<li><strong><code>@Inherited</code></strong> <code>@Inherited</code> 注解表示其所标记的注解类型，可从超类继承到（<code>@Inherited</code> annotation indicates that the annotation type can be inherited from the super class）。（默认是不可以从超类继承的。）在用户查询某个注解类型，而该类又没有这个类型的注解时，那么就会对这个类的超类查询此注解类型。此注解仅适用于类的声明。</li>
<li><strong><code>@Repeatable</code></strong> <code>@Repeatable</code> 注解，是在Java SE 8 中引入的，表示所其所标记的注解，可多次应用到同意声明或类型用途。更多的有关信息，请参阅 <a href="Ch20_Appendix_B.html#repeating-annotations">重复注解（Repeating Annotations）</a>。</li>
</ul>
<h3 id="类型注解与可插拔类型系统"><a class="header" href="#类型注解与可插拔类型系统"><a id="type-annotations-and-pluggable-type-systems"></a>类型注解与可插拔类型系统</a></h3>
<p><strong>Type Annotations and Pluggable Type Systems</strong></p>
<p>在 Java SE 8 发布之前，注解只能适用于声明。而自Java SE 8 发布开始，注解就还可以适用到任何 <em>类型用途（type use）</em> 了。这意味着在所有用到类型的地方，都可以使用注解。有用到类型之处的一些示例，包括类实例创建表达式（<code>new</code>）、类型转换（casts）、<code>implements</code> 子语句，以及 <code>throws</code> 子语句等。这种形式的注解，被称为 <em>类型注解（type annotation）</em>，在之前的 <a href="Ch20_Appendix_B.html#annations-basics">注解基础</a>那里，给出了几个示例。</p>
<p>之所以创建出这些类型注解，是为了以确保以更强大的类型检查方式，支持对Java程序的分析。Java SE 8发布，并未提供类型检查框架，不过Java SE 8 是允许编写（或下载）作为一个或多个可插拔式模组实现的、与Java 编译器结合使用的类型检查框架的（Type annotations were created to support improved analysis of Java programs way of ensuring stronger type checking. The Java SE 8 release does not provide a type checking framework, but it allows you to write(or download) a type checking framework that is implemented as one or more pluggable modules that are used in conjunction with the Java compiler）。</p>
<p>比如，在想要程序中某个特定变量绝不被赋值 <code>null</code>，以期望避免触发 <code>NullPointerException</code>。那么就可以编写一个定制的插件，来对此进行检查。随后就要对代码进行修改，来对那个特定变量进行注解，从而表明其绝不会被赋值 <code>null</code>。此变量声明看起来将像这样：</p>
<pre><code class="language-java">@NonNull String str;
</code></pre>
<p>在编译此代码时，就要在命令行包含进 <code>NonNull</code> 模组，那么编译器在探测到潜在问题时，就会打印出告警信息，进而允许对代码加以修改，以避免错误。在纠正了代码而消除了全部告警之后，在程序运行期间这特定错误便不再会出现了。</p>
<p>可使用多个类型检查模组（multiple type-checking modules），其中各个模组对不同类别多维进行检查。这样的话，就可以在Java类型系统之上进行构建，在需要这些特定类型检查的各个时间点、位置，按需添加这些类型检查。</p>
<p>明智地使用类型注解，加上可插拔类型检查器（pluggable type checkers）的存在，那么就可以编写出更加强大又不会出错的代码了。</p>
<p>在许多情形中，是不必编写自己的类型检查模组的。有很多第三方以及完成了这方面的工作。比如，或许会利用到华盛顿大学所创建的检查器框架 <code>Checker Framework</code>。该框架就包含了<code>NonNull</code> 模组，还有正则表达式模组（a regular module），以及互斥锁（a mutex lock module）。更多有关该检查器框架的信息，请参考 <a href="https://checkerframework.org/">检查器框架</a>。</p>
<h3 id="重复注解"><a class="header" href="#重复注解"><a id="repeating-annotations"></a>重复注解</a></h3>
<p><strong>Repeating Annotations</strong></p>
<p>有些情况下，会希望将同一注解应用到声明或类型运用（a declaration or type use）。自Java SE 8 发布开始，<em>重复注解</em> 才支持该特性。</p>
<p>比如正在编写要用到定时器服务，来实现在给定时间或以某个特定时间表，去运行某个方法，类似于 UNIX 的 <code>cron</code> 服务的代码。那么就要设置一个定时器，来在一个月的最后一天，及每个周五晚上11点运行一个方法，<code>doPeriodicCleanup</code>。那么就要设置定时器运行，创建一个 <code>@Schedule</code> 注解，并将其两次应用到 <code>doPeriodicCleanup</code> 方法。第一次的使用，指定一个月的最后一天，同时第二次指定周五晚上11点，就跟下面的代码示例一样：</p>
<pre><code class="language-java">@Schedule(dayOfMoth=&quot;last&quot;)
@Schedule(dayOfWeek=&quot;Fri&quot;, hours=&quot;23&quot;)
public void doPeriodicCleanup() {...}
</code></pre>
<p>上面这个示例，是将注解应用到方法。可在任何会用到标志注解的地方，对某个注解加以重复。比如，有着一个处理未授权访问异常的类。就可以对这个类注解上一个针对那些管理者的 <code>@Alert</code> 的注解，和一个针对系统管理员的 <code>@Alert</code>：</p>
<pre><code class="language-java">@Alert(role=&quot;Manager&quot;)
@Alert(role=&quot;Administrator&quot;)
public class UnauthorizedAccessException extends SecurityException {...}
</code></pre>
<p>由于兼容性的原因，重复注解是被保存在由Java编译器自动生成的 <em>容器注解（container annotation）</em> 中的。为了让编译器完成此操作，就要求在代码中包含下面这两个声明。</p>
<h4 id="步骤一声明一个-repeatable-类型的注解类型"><a class="header" href="#步骤一声明一个-repeatable-类型的注解类型">步骤一、声明一个 <code>Repeatable</code> 类型的注解类型</a></h4>
<p><strong>Step 1: Declare a <code>Repeatable</code> Annotation Type</strong></p>
<p>该注解类型必须被 <code>@Repeatable</code> 元注解（the <code>@Repeatable</code> meta-annotation）标记。下面的示例定义了一个定制的 <code>@Schedule</code> 可重复注解类型：</p>
<pre><code class="language-java">import java.lang.annotation.Repeatable;

@Repeatable(Schedules.class)
public @interface Schedule {
    String dayOfMonth() default &quot;first&quot;;
    String dayOfWeek() default &quot;Mon&quot;;
    int hour() default 12;
}
</code></pre>
<p>那个 <code>@Repeatable</code> 元注解的取值，即在括号里的那个，即为Java编译器生成的、用于存储重复性注解的容器注解的类型（The value of the <code>@Repeatable</code> meta-annotation, in parentheses, is the type of the container annotation that the Java compiler generates to store repeating annotations）。在此示例中，那个容纳注解类型，即是 <code>Schedules</code>，那么重复性的 <code>@Schedule</code> 注解，就是存储在一个 <code>@Schedules</code> 的注解中的。</p>
<p>在没有首先将某个注解声明未可重复注解的情况下，将同一注解应用到某个声明，就会导致一个编译器错误。</p>
<h4 id="步骤二声明出那个容纳注解类型"><a class="header" href="#步骤二声明出那个容纳注解类型">步骤二、声明出那个容纳注解类型</a></h4>
<p><strong>Step 2: Declare the Containing Annotation Type</strong></p>
<p>容纳性注解类型，必须有着一个数组类型的 <code>value</code> 元素。该数组类型的组件类型，则必须时那个可重复注解类型。这个 <code>@Schedules</code> 容纳性类型的声明，就是下面这样：</p>
<pre><code class="language-java">public @interface Schedules {
    Schedule[] value();
}
</code></pre>
<h3 id="注解的获取"><a class="header" href="#注解的获取">注解的获取</a></h3>
<p><strong>Retrieving Annotations</strong></p>
<p>反射式API中，有着多个可用于获取到注解的方法。这些方法返回单个的、譬如<code>AnnotatedElement.getAnnotation(Class&lt;T&gt;)</code>这样的注解的表现，与存在 <em>一个</em> 这些方法所请求类型注解，而仅返回返回单个注解相比，是不会发生变化的（The behavior of the methods that return a single annotation, such as <code>AnnotatedElement.getAnnotation(Class&lt;T&gt;)</code>, are unchanged in that they only return a single annotation if <em>one</em> annotation of the requested type is present）。但若存在多个的所请求类型的注解时，那么就可以首先获取到这些注解的容器。这样的话，那些老旧代码会继续工作。在Java SE 8中引入的其他一些方法，则会对容器注解进行全面扫描，从而一次性返回多个注解，就如同 <code>AnnotatedElement.getAnnotationsByType(Class&lt;T&gt;)</code>那样。请参考 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html"><code>AnnotatedElement</code></a> 类规格，以了解有关全部方法的信息。</p>
<h3 id="设计上的考量"><a class="header" href="#设计上的考量">设计上的考量</a></h3>
<p><strong>Design Considerations</strong></p>
<p>在设计某个注解类型时，必须考虑到那个类型下注释的 <em>基数（cardinality）</em>。目前会用到这个注解 0 次、1 次都是可能的，而在这个注释被标记为了 <code>@Repeatable</code> 时，那么就可以多次使用了。同时通过使用 <code>@Target</code> 元注解，还可以限制注解可用在何处。比如，即可创建一个可重复的、仅可用在方法及字段上的注解类型。为确保 <em>用到</em> 你所设计注解类型注解的程序员，发现他是灵活且强大的，那么就要仔细的加以设计（It is important to design your annotation type carefully to ensure the programmer <em>using</em> the annotation finds it to be as flexible and powerful as posssible）。</p>
<h3 id="提问与练习注解"><a class="header" href="#提问与练习注解">提问与练习：注解</a></h3>
<h4 id="问题"><a class="header" href="#问题">问题❓</a></h4>
<ol>
<li>
<p>下面这个接口什么错了？</p>
<pre><code class="language-java">public interface House {
    @Deprecated
    public void open();
    public void openFrontDoor();
    public void openBackDoor();
}
</code></pre>
</li>
<li>
<p>试想对问题 1 中所给的 <code>House</code> 接口的下面这个实现：</p>
<pre><code class="language-java">public class MyHouse implements House {
    public void open () {}
    public void openFrontDoor () {}
    public void openBackDoor() {}
}
</code></pre>
<p>那么在编译这个程序时，由于这里的 <code>open</code> 是已被弃用的（在上面的接口中），那么编译器就会产生一条告警消息。该怎样来处理掉那条告警消息呢？</p>
</li>
<li>
<p>下面的代码在编译时将不会出错吗？为什么不会出错，或者说为什么会出错呢？</p>
<pre><code class="language-java">public @interface Meal {...}

@Meal(&quot;breakfast&quot;, mainDish=&quot;cereal&quot;)
@Meal(&quot;lunch&quot;, mainDish=&quot;pizza&quot;)
@Meal(&quot;dinner&quot;, mainDish=&quot;salad&quot;)
public void evaluateDiet() {...}
</code></pre>
</li>
</ol>
<h4 id="练习"><a class="header" href="#练习">练习🏋️</a></h4>
<ol>
<li>请定义出一个带有元素 <code>id</code>、<code>synopsis</code>、<code>engineer</code> 及 <code>date</code>的、用于一项增强请求的注解类型。将其中 <code>engineer</code> 与 <code>date</code> 的默认值，分别指定为 <code>unassigned</code>和<code>unknown</code>（define an annotation type for an enhancement request with elements <code>id</code>, <code>synopsis</code>, <code>engineer</code>, and <code>date</code>. Specify the default value as <code>unassigned</code> for engineer and <code>unknown</code> for date）。</li>
</ol>
<details>
    <summary>答案🙋</summary>
<h4 id="问题-1"><a class="header" href="#问题-1">问题</a></h4>
<ol>
<li>
<p><strong>答案</strong>：文档应当体现出为何 <code>open</code> 被弃用，以及应当用什么来代替他。比如：</p>
<pre><code class="language-java">public interface House {
    /**
     * @deprecated 对 open 方法的使用是不鼓励的，请使用
     * openFrontDoor 或 openBackDoor 予以代替。
     *
     */
    @Deprecated
    public void open();
    public void openFrontDoor();
    public void openBackDoor();
}
</code></pre>
</li>
<li>
<p><strong>答案</strong> ：可给 <code>open</code> 方法的实现加上弃用注解（you can deprecate the implementation of <code>open</code>）：</p>
<pre><code class="language-java">public class MyHouse implements House {
    // 文档是从接口继承到的。
    @Deprecated
    public void open() {}
    public void openFrontDoor() {}
    public void openBackDoor() {}
}
</code></pre>
<p>或者，可抑制告警信息：</p>
<pre><code class="language-java">public class MyHouse implements House {
    @SuppressWarinings(&quot;deprecation&quot;)
    public void open() {}
    public void openFrontDoor() {}
    public void openBackDoor() {}
}
</code></pre>
</li>
<li>
<p><strong>答案</strong> ：此代码将编译失败。在JDK 8之前，是不支持可重复注解的。即便是在 JDK 8 中，由于其中的 <code>Meal</code> 注解类型，未被定义为可重复，因此该代码仍会编译失败。可通过加上 <code>@Repeatable</code> 元注解，并定义一个容器注解类型，来修复这个问题：</p>
<pre><code class="language-java">public class AnnotationTest {
    public @interface MealContainer {
        Meal[] value();
    }

    @java.lang.annotation.Repeatable(MealContainer.class)
    public @inerface Meal {
        String value();
        String mainDish();
    }

    @Meal(value=&quot;早餐&quot;, mainDish=&quot;麦片&quot;)
    @Meal(value=&quot;午餐&quot;, mainDish=&quot;披萨&quot;)
    @Meal(value=&quot;晚餐&quot;, mainDish=&quot;沙拉&quot;)
    public void evaluateDiet() {}
}
</code></pre>
</li>
</ol>
<h4 id="练习-1"><a class="header" href="#练习-1">练习</a></h4>
<ol>
<li>
<p><strong>答案</strong> : </p>
<pre><code class="language-java">/**
 * 这里的注释，对这个增强请求
 * （the Request-for-Enhancement, RFE）注解
 * 类型，进行了描述。
 */
public @interface RequestForEnhancement {
    int id();
    String synopsis();
    String engineer() default &quot;[unassigned]&quot;;
    String date() default &quot;[unknown]&quot;;
}
</code></pre>
</li>
</ol>
</details>
<h2 id="另一个注解教程"><a class="header" href="#另一个注解教程">另一个注解教程</a></h2>
<blockquote>
<p><em>引用自</em>：<a href="https://www.geeksforgeeks.org/annotations-in-java/">Annotations in Java</a></p>
</blockquote>
<p>注解用于提供程序的补充信息（Annotations are used to provide supplemental information about a program）。</p>
<ul>
<li>注解以 <code>@</code> 开头；</li>
<li>注解不会改变已编译好的程序的行为；</li>
<li>注解帮助将一些 <em>元数据</em>（信息）与实例变量、构造器、方法、类等的程序元素关联起来（Annotations help to associate <em>metadata</em>(infomation) to the program elements i.e. instance variables, constructors, methods, classes, etc.）；</li>
<li>由于注解能够改变编译器对待程序的方式，因此注解并非纯粹的注释。请参阅下面的代码；</li>
<li>大体上注解是用于提供额外信息的，因此可作为 XML 与一些 Java 标记性接口的替代。</li>
</ul>
<h3 id="java-中注解的继承层次"><a class="header" href="#java-中注解的继承层次">Java 中注解的继承层次</a></h3>
<p><img src="images/Ch20_01.png" alt="Java 注解继承层次" /></p>
<p><em>图 1 - Java 注解继承层次</em></p>
<p><strong>实操（Implementation）</strong>：</p>
<blockquote>
<p><em><strong>注意</strong>：由于这里提到了重写（override），但并未进行重写，而是对 <code>display</code> 方法进行了过载（overloaded），因此这里会抛出编译器错误</em>。</p>
</blockquote>
<pre><code class="language-java">// 用于演示注解并非仅仅是代码注释的 Java 程序。

package com.xfoss.Annotations;

// 第一个类
class Base {

    // 方法
    public void display ()
    {
        System.out.println(&quot;类 Base 的 display()&quot;);
    }
}

// 第二个类
// 是主类（Main Class）
public class Derived extends Base {

    // 对上面那个类中已有的方法进行重写
    @Override public void display (int x)
    {
        // 在调用这个方法时运行的打印语句
        System.out.println(&quot;派生的 sisplay()&quot;);
    }

    // 第二个方法
    // 这是主驱动类方法（main driver method）
    public static void main (String args[])
    {
        // 在 main() 方法中创建出这个类的对象
        Derived obj = new Derived();

        // 在 main() 方法中调用 display() 方法
        obj.display();
    }
}
</code></pre>
<p><strong>输出</strong>:</p>
<pre><code class="language-console">.../src/main/java/com/xfoss/Annotations/Derived.java:13: error: method does not override or implement a method from a supertype
    @Override public void display(int x)
    ^
    1 error

FAILURE: Build failed with an exception.
</code></pre>
<p>只需将参数 <code>(int x)</code> 移除或移除 <code>@Override</code>，程序就会正常编译。</p>
<h3 id="注解分类categories-of-annotations"><a class="header" href="#注解分类categories-of-annotations">注解分类（Categories of Annotations）</a></h3>
<p>如下所示，粗略地划分，有着 5 个类别的注解：</p>
<ol>
<li>
<p>标记型注解（marker Annotations）</p>
</li>
<li>
<p>单一取值型注解（single value Annotations）</p>
</li>
<li>
<p>完整注解（full Annotations）</p>
</li>
<li>
<p>类型注解（type Annotations）</p>
</li>
<li>
<p>重复型注解（repeating Annotations）</p>
</li>
</ol>
<p>下面将逐一讨论这些类别的注解，并在需要的地方附带上示例代码。</p>
<h3 id="类别一标记型注解"><a class="header" href="#类别一标记型注解">类别一：标记型注解</a></h3>
<p>其唯一目的就是对某个声明进行标记。这类注解不包含成员，进而也没有任何数据。因此，他们作为注解而存在就足够了（Thus, its presence as an annotation is sufficient）。由于这类标记型接口不包含成员，那么仅仅确定它是存在还是不存在就已足够。</p>
<p><code>@Override</code> 就是标记型注解的一个例子。</p>
<p><strong>示例</strong></p>
<pre><code class="language-java">@TestAnnotation()
</code></pre>
<h3 id="类别二单一取值型注解"><a class="header" href="#类别二单一取值型注解">类别二：单一取值型注解</a></h3>
<p>这类注解仅包含一个成员，进而允许简写形式的对该成员取值的指定（These annotations contain only one member and allow a shorthand form of specifying the value of the member）。在应用到此类型注解时，就只需指定那个成员的值，而无需指定该成员的名称。然而，为了用上这种简写，其成员的名称必须是 <code>value</code>。</p>
<p><strong>示例</strong></p>
<pre><code class="language-java">@TestAnnotation(&quot;testing&quot;)
</code></pre>
<h3 id="类别三-完整注解"><a class="header" href="#类别三-完整注解">类别三： 完整注解</a></h3>
<p>这类注解包含了多个数据成员、名称、取值、成员取值对（These annotations consist of multiple data members, names, values, pairs）。</p>
<p><strong>示例</strong></p>
<pre><code class="language-java">@TestAnnotation(owner=&quot;Rahul&quot;, value=&quot;Class Geeks&quot;)
</code></pre>
<h3 id="类别四类型注解"><a class="header" href="#类别四类型注解">类别四：类型注解</a></h3>
<p>这类注解可应用到任何用到类型的地方（These annotations can be applied to any place where a type is being used）。比如，可对某个方法的返回值类型进行注解。这些注解在声明时，就已被 <code>@Target</code> 注解过了（These are declared annotated with <code>@Target</code> annotation）。</p>
<p><strong>示例</strong></p>
<pre><code class="language-java">package com.xfoss.Annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target(ElementType.TYPE_USE)
@interface TypeAnnoDemo {}

public class GFG {
    public static void main (String args[])
    {
        @TypeAnnoDemo String string = &quot;我已被某个类型注解给注解过了&quot;;
        System.out.println(string);
        abc();
    }

    static @TypeAnnoDemo int abc ()
    {
        System.out.println(&quot;此函数的返回值类型已被注解过了&quot;);
        return 0;
    }
}
</code></pre>
<p><strong>输出</strong></p>
<pre><code class="language-console">我已被某个类型注解给注解过了
此函数的返回值类型已被注解过了
</code></pre>
<h3 id="类别五重复性注解"><a class="header" href="#类别五重复性注解">类别五：重复性注解</a></h3>
<p>这类注解可多次应用到单个项目（these are the annotations that can be applied to a single item more than onece）。注解要能够可重复，其所属类型就必须被 <code>@Repeatable</code>注解给注解过，而<code>@Repeatable</code>则是在 <code>java.lang.annotation</code>包中定义的元注解。<code>@Repeatable</code>对某个注解类型进行注解时，他的<code>value</code>字段指定了被注解的可重复注解类型的 <strong>容器类型（container type）</strong>。而 <strong>容器的指定，是指<code>value</code>字段是该可重复注解类型的数组的一个注解（the container is specified as annotation whose <code>value</code> field is an array of the repeatable annotation type）</strong>。因此，要创建可重复注解，首先就要创建容器注解，进而将创建出的容器注解类型，作为参数指定给那个 <code>@Repeatable</code> 注解（也就是说元注解<code>@Repeatable</code> 是有参数的）。</p>
<p><strong>示例</strong></p>
<pre><code class="language-java">package com.xfoss.Annotations;

import java.lang.annotation.*;
import java.lang.reflect.Method;

@Retention(RetentionPolicy.RUNTIME)
@Repeatable(MyRepeatedAnnos.class)
@interface Word
{
    String word() default &quot;Hello&quot;;
    int value() default 0;
}

@Retention(RetentionPolicy.RUNTIME)
@interface MyRepeatedAnnos
{
    Word[] value();
}

public class Main {

    // 注意：这里初始化 @Word 类型的注解时：
    //      1. 不能使用非静态实例变量。这个注解的初始化，是属于其
    // 所注解的静态方法 newMethod() 的上下文的；
    //      2. 也不能使用静态实例变量。“element value must be a 
    // constant expression”，因此只能使用静态 final 的常量。
    @Word(word = &quot;First&quot;, value = 1)
    @Word(word = &quot;Second&quot;, value = 2)
    public static void newMethod()
    {
        Main obj = new Main();

        try {
            Class&lt;?&gt; c = obj.getClass();

            Method m = c.getMethod(&quot;newMethod&quot;);

            Annotation anno = m.getAnnotation(MyRepeatedAnnos.class);
            System.out.println(anno);
        }
        catch (NoSuchMethodException e) 
        {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) { newMethod(); }
}
</code></pre>
<p><strong>输出</strong></p>
<pre><code class="language-console">@com.xfoss.Annotations.MyRepeatedAnnos(value={@com.xfoss.Annotations.Word(word=&quot;First&quot;, value=1), @com.xfoss.Annotations.Word(word=&quot;Second&quot;, value=2)})
</code></pre>
<h3 id="预定义标准注解"><a class="header" href="#预定义标准注解">预定义/标准注解</a></h3>
<p><strong>Predefined/Standard Annotations</strong></p>
<p>如同在上面的继承层次图中看到的那样，Java 普遍定义了 7 个内建注解。</p>
<ul>
<li>其中四个是从 <code>java.lang.annotation</code> 包导入的：<code>@Rentention</code>、<code>@Documented</code>、<code>@Target</code> 与 <code>@Inherited</code>；</li>
<li>另外三个包含在 <code>java.lang</code> 包中：<code>@Deprecated</code>、<code>@Override</code> 和 <code>@SuppressWarnings</code>。</li>
</ul>
<p><strong>注解一：<code>@Deprecated</code></strong></p>
<ul>
<li>这是个标记型注解。他表明某个声明已作废，而已被更新的形式所取代；</li>
<li>在某个元素已被启用时，那么还应同时使用 <code>Javadoc</code> 的 [<code>@deprecated</code> 标签](http://docs.oracle.com/javase/1.5.0/docs/guide/javadoc/deprecation/deprecation.html#javadoc_tag]；</li>
<li><code>@deprecated</code> 标签用于文档，而<code>@Deprecated</code> 注解则是用于运行时反射（runtime reflection）；</li>
<li>在同时使用到 <code>@deprecated</code> 标签和 <code>@Deprecated</code> 注解时，前者有着更高的优先级。</li>
</ul>
<p><strong>示例</strong></p>
<pre><code class="language-java">package com.xfoss.Annotations;

public class DeprecatedTest {
    @Deprecated
    public void Display()
    {
        System.out.println(&quot;Deprecatedtest display()&quot;);
    }

    public static void main(String args[])
    {
        DeprecatedTest d1 = new DeprecatedTest();
        d1.Display();
    }
}
</code></pre>
<p><strong>输出</strong></p>
<pre><code class="language-console">Deprecatedtest display()
</code></pre>
<blockquote>
<p><strong>注</strong>：该程序在编译时，会报出以下错误：</p>
</blockquote>
<pre><code class="language-console">注: .../src/main/java/com/xfoss/Annotations/AnnotationTestDrive.java使用或覆盖了已过时的 API。
</code></pre>
<p><strong>注解二：<code>@Override</code></strong></p>
<p>这是个只能用在方法上的标记型注解。被 <code>@Override</code> 注解过的方法，必须对来自超类的某个方法进行重写。若被注解的方法没有这样做，那么就会导致一个编译时错误。使用这个注解来确保某个超类方法真的被重写了，而非简单地被过载（overloaded）。</p>
<p><strong>示例</strong></p>
<pre><code class="language-java">package com.xfoss.Annotations;

class BaseCls
{
    public void Display()
    {
        System.out.println(&quot;BaseCls diplay()&quot;);
    }

    public static void main(String args[])
    {
        BaseCls t1 = new DerivedCls();
        t1.Display();
    }
}

class DerivedCls extends BaseCls 
{
    @Override
    public void Display()
    {
        System.out.println(&quot;DerivedCls display()&quot;);
    }
}
</code></pre>
<p><strong>输出</strong></p>
<pre><code class="language-console">DerivedCls display()
</code></pre>
<p><strong>注解三：<code>@SuppressWarnings</code></strong></p>
<p>使用 <code>@SuppressWarnings</code> 注解来告诉编译器，对特定编译器告警加以抑制。通过字符串形式的告警名称，来指定要抑制的告警。这种类型的注解，可应用到全部类型的声明。</p>
<p>Java 将告警分组成两个类别。分别是 <code>deprecated</code> 与 <code>unchecked</code>。在老旧代码碰到使用了泛型的代码时，就会生成<code>unchecked</code>的告警（Any <code>unchecked</code> warning is generated when a legacy code interfaces with a code that uses generics）。</p>
<p><strong>示例</strong></p>
<pre><code class="language-java">// 用于演示 SuppressWarnings 注解的 Java 程序
package com.xfoss.Annotations;

// 类 1
class DeprecatedTest
{
    @Deprecated
    public void Display()
    {
        System.out.println(&quot;Deprecated display()&quot;);
    }
}

// 类 2
public class SuppressWarningTest
{
    // 若将下面的注解注释掉，那么程序就会产生告警
    @SuppressWarnings({&quot;checked&quot;, &quot;deprecation&quot;})
    public static void main(String args[])
    {
        DeprecatedTest d1 = new DeprecatedTest();
        d1.Display();
    }
}
</code></pre>
<p><strong>输出</strong></p>
<pre><code class="language-console">Deprecated display()
</code></pre>
<p><strong>注解 4：<code>@Documented</code></strong></p>
<p>这是一个告诉工具某个注解将要被编写文档的标记型接口。注解不会被包含进 <code>Javadoc</code> 的注释中（it is a marker interface that tells a tool that an annotation is to be documented. Annotations are not included in <code>Javadoc</code> comments）。<code>@Documented</code> 注解在代码中的使用，会开启诸如 <code>Javadoc</code> 这样的工具对其的处理，并将注解类型信息，包含进生成的文档中。</p>
<p><strong>注解 5：<code>@Target</code></strong></p>
<p>这个注解设计只被用作给另一注解当注解（元注解，<em>meta annotation</em>）。<code>@Target</code> 会取一个参数，而该参数必须是来自<code>ElementType</code>枚举类型（<code>java.lang.annotation.ElementType</code>）的常量。该参数指定了被 <code>@Target</code>注解的注解，可应用到那些类型的声明上。下面给出了<code>ElementType</code>枚举类型所包含的常量，以及他们各自所对象的声明类型。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><code>@Target</code> 常量</th><th style="text-align: left">可应用到的注解</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ANNOTATION_TYPE</code></td><td style="text-align: left">另一注解</td></tr>
<tr><td style="text-align: left"><code>CONSTRUCTOR</code></td><td style="text-align: left">构造器</td></tr>
<tr><td style="text-align: left"><code>FIELD</code></td><td style="text-align: left">字段（实例变量）</td></tr>
<tr><td style="text-align: left"><code>LOCAL_VARIABLE</code></td><td style="text-align: left">本地变量</td></tr>
<tr><td style="text-align: left"><code>METHOD</code></td><td style="text-align: left">方法</td></tr>
<tr><td style="text-align: left"><code>PACKAGE</code></td><td style="text-align: left">包</td></tr>
<tr><td style="text-align: left"><code>PARAMETER</code></td><td style="text-align: left">方法的参数</td></tr>
<tr><td style="text-align: left"><code>TYPE</code></td><td style="text-align: left">类、接口或枚举（Class, Interface, or enumeration）</td></tr>
</tbody></table>
</div>
<p><em>表一, <code>ElementType</code> 枚举类型下的各个常量</em></p>
<p>可在 <code>@Target</code> 注解中指定一个或多个的这些值。在指定多个值时，就必须将这些值指定在一个大括号分隔的清单中（To specify multiple values, we must specify them within a braces-delimited list）。比如，可使用这个 <code>@Target</code> 注解：<code>@Target({ElementType.FIELD, ElementType.LOCAL_VARIABLE})</code> 来指定某个注解只应用到字段及本地变量。</p>
<p><strong><code>@Rentention</code> 注解</strong></p>
<p>这个注解确定了其所注解的注解，应保留在何处及保留多长时间（it determines where and how long the annotation is retent）。<code>@Rentention</code> 注解可以有三个取值：</p>
<ul>
<li><strong><code>SOURCE</code></strong>: 注解将保留在源代码级别，并被编译器所忽略；</li>
<li><strong><code>CLASS</code></strong>：注解将保留在编译时，并被 JVM 所忽略；</li>
<li><strong><code>RUNTIME</code></strong>：这些注解将保留在运行时。</li>
</ul>
<p><strong>注解 7：用户定义（定制）注解</strong></p>
<p>用户定义注解可用于对程序元素，比如变量、构造器、方法等进行注解。这些注解可应用在紧接着元素声明（构造器、方法、类等等）开始的地方。</p>
<p><strong>语法</strong>：声明</p>
<pre><code class="language-java">[Access Specifier] @interface&lt;AnnotationName&gt;
{
    DataType &lt;Method Name&gt;() [default value];
}
</code></pre>
<p>在实现用户定义注解之前，请将以下各个要点，作为定制注解的重要原则（Do keep these certain points as rules for custom annotations before implementing user-defined annotations）。</p>
<ol>
<li><code>AnnotationName</code> 是个接口；</li>
<li>该参数不应与那些方法声明相关联，且在方法声明上不应使用 <code>throws</code> 子语句（the parameter should not be associated with method declarations and <code>throws</code> clause should not be used with method declaration）；</li>
<li>其中的参数，将不会<code>null</code> 值，但可以有默认值；</li>
<li><code>default</code> 值是可选的；</li>
<li>其中的方法返回值类型，应是原生值、枚举、字符串、类名称，或者原生值、枚举、字符串或类名称等类型的数组（the return type of method should be either primitive, enum, string, class name, or array of primitive, enum, string, or class name type）。</li>
</ol>
<p><strong>示例</strong>：</p>
<pre><code class="language-java">package com.xfoss.Annotations;

import java.lang.annotation.*;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@interface TestAnnotation
{
    String Developer() default &quot;Lenny&quot;;
    String Expirydate();
}

public class Test
{
    @TestAnnotation(Developer=&quot;Echo&quot;, Expirydate=&quot;01-10-2020&quot;)
    void fun1()
    {
        System.out.println(&quot;测试方法 1&quot;);
    }

    @TestAnnotation(Developer=&quot;Anil&quot;, Expirydate=&quot;01-10-2020&quot;)
    void fun2()
    {
        System.out.println(&quot;测试方法 2&quot;);
    }

    public static void main(String args[])
    {
        System.out.println(&quot;你好&quot;);
    }
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code class="language-console">你好
</code></pre>
<h2 id="拉姆达-lambda-表达式"><a class="header" href="#拉姆达-lambda-表达式"><a id="lambda-expressions"></a>拉姆达 Lambda 表达式</a></h2>
<p><strong>Java 8 中的 Lambda 表达式（Lambda Expressions in Java 8）</strong></p>
<p>拉姆达表达式本质上是 <a href="Ch20_Appendix_B.html#functional_interface">功能接口(functioal interface)</a> （带有单个抽象方法的接口，被称为功能接口。<code>java.lang.Runnable</code> 即是功能接口的一个示例）的表征。拉姆达表达式实现的是唯一抽象方法，进而因此实现的是功能接口。拉姆达表达式是在 Java 8 中加入的特性，从而提供了以下的这些功能。</p>
<ul>
<li>实现了将功能作为方法参数的处理，或者说将代码当作数据的处理（enable to treat functionality as a method argument, or code as data）；</li>
<li>可创建出不属于任何类的函数（a function can be created without belonging to any class）；</li>
<li>拉姆达表达式，可像对象一样传递，并在需要时被执行（a lambda expression can be passed around as if it was an object and executed on demand）。</li>
</ul>
<pre><code class="language-java">package com.xfoss.LambdaExpr;

interface FuncInterface
{
    void abstractFun(int x);

    default void normalFun()
    {
        System.out.println(&quot;你好&quot;);
    }
}

class Test
{
    public static void main(String args[])
    {
        FuncInterface fobj = (int x) -&gt; System.out.println(2*x);

        fobj.abstractFun(5);
    }
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code class="language-java">10
</code></pre>
<p><img src="images/Ch20_02.png" alt="拉姆达表达式" /></p>
<p><em>图 2 - 拉姆达表达式</em></p>
<p><strong>语法</strong>：</p>
<pre><code class="language-java">lambda operator -&gt; body
</code></pre>
<p>其中拉姆达运算符（<code>lambda operator</code>）可以是：</p>
<ul>
<li><strong>零参数</strong>：</li>
</ul>
<pre><code class="language-java">() -&gt; System.out.println(&quot;零参数的拉姆达（Zero parameter lambda）&quot;)；
</code></pre>
<ul>
<li><strong>一个参数</strong>：</li>
</ul>
<pre><code class="language-java">(p) -&gt; System.out.format(&quot;一个参数：%s&quot;, p);
</code></pre>
<p>在那个变量的类型可从上下文推导出来时，那么小括号的使用就不是强制的（it is not mandatory to use parentheses, if the type of that variable can be inferred from the context）。</p>
<ul>
<li><strong>多个参数</strong>：</li>
</ul>
<pre><code class="language-java">(p1, p2) -&gt; System.out.format(&quot;多个参数：%s, %s&quot;, p1, p2);
</code></pre>
<p>请注意：拉姆达表达式恰如函数，他们跟函数一样接受参数（lambda expressions are just like functions and they accept parameters just like functions）。</p>
<pre><code class="language-java">package com.xfoss.LambdaExpr;

import java.util.ArrayList;

class TestDrive
{
    public static void main(String args[]){

        ArrayList&lt;Integer&gt; arrL = new ArrayList&lt;Integer&gt;();
        for(int i = 1; i &lt; 5; i++) arrL.add(i);

        arrL.forEach(n -&gt; System.out.println(n));

        arrL.forEach(n -&gt; {if(n%2 == 0) System.out.println(n);});
    }
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code class="language-console">1
2
3
4
2
4
</code></pre>
<p>请注意拉姆达表达式 <em><strong>只可用于实现功能接口</strong></em>。在上面的示例中同样是这样的，其中的拉姆达表达式实现的是 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html">消费者</a> 功能接口（Consumer Functional Interface）。</p>
<pre><code class="language-java">// 用于对拉姆达表达式工作原理进行演示的 Java 程序
package com.xfoss.LambdaExpr;

public class LambdaExprDemo
{
    // 函数 operation 是使用拉姆达表达式实现的
    interface FuncInter1
    {
        int operation(int a, int b);
    }

    // 这里的 sayMessage() 也是使用拉姆达表达式实现的
    interface FuncInter2
    {
        void sayMessage(String message);
    }

    // 由这个具体的 operate 方法来完成 FuncInter1 中
    // 在 ‘a’ 与 ‘b’ 上的运算
    private int operate(int a, int b, FuncInter1 fobj)
    {
        return fobj.operation(a, b);
    }

    public static void main(String args[])
    {
        // 用于两个参数相加的拉姆达表达式
        // x 与 y 的数据类型是非必须的。
        // 该表达式实现了 'FuncInter1' 接口
        FuncInter1 add = (int x, int y) -&gt; x + y;

        // 用于两个参数相乘的拉姆达表达式
        // 这个表达式同样实现了 'FuncInter1' 接口
        FuncInter1 multiply = (int x, int y) -&gt; x * y;

        // 创建一个 LambdaExprDemo 的实力，来以 operate 的
        // 不同拉姆达表达式实现，对其进行调用
        LambdaExprDemo dobj = new LambdaExprDemo();

        // 使用拉姆达表达式，将两个数相加
        System.out.format(&quot;加法为 %d\n&quot;, dobj.operate(6, 3, add));

        // 使用拉姆达表达式，将两个数相乘
        System.out.format(&quot;乘法为 %d\n&quot;, dobj.operate(6, 3, multiply));

        // 单个参数的拉姆达表达式
        // 此表达式实现了 'FuncInter2' 接口
        FuncInter2 fobj = message -&gt; System.out.format(&quot;你好 %s\n&quot;, message);

        fobj.sayMessage(&quot;极客&quot;);
    }
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code class="language-console">加法为 9
乘法为 18
你好 极客
</code></pre>
<h3 id="要点"><a class="header" href="#要点">要点：</a></h3>
<ul>
<li>拉姆达表达式的函数体，可以包含零个、一个或更多的语句（the body of a lambda expression can contain zero, one or more statements）；</li>
<li>在只有单个语句时，花括号不是强制性的，同时该匿名函数的返回值类型与函数体表达式一致（when there is a single statement curly brackets are not mandatory and the return type of the anonymous function is the same as that of the body expression）；</li>
<li>在有多个语句时，那么这些语句就必须用花括号括起来（形成一个代码块），且该匿名函数的返回值类型，与由此代码块所返回的值类型一致，或者即为在未返回任何东西时的 <code>void</code>（when there are more than one statements, then these must be enclosed in curly brackets(a code block) and the return type of the anonymous function is the same as the type of the value return within the code block, or <code>void</code> if nothing is returned）。</li>
</ul>
<h2 id="功能接口"><a class="header" href="#功能接口"><a id="functional_interface"></a>功能接口</a></h2>
<p>Java 永远是一种面向对象的编程语言（Java has forever remained an Object-Oriented Programming language）。而由于Java 是一种面向对象编程语言，那么就可以声称，除了一些原生数据类型，和一些为完整性与简单性目的而采用的原生方法外， Java 编程语言中所出现全部事物，都可以由对象来表达（by object-oriented programming language, we can declare that everything present in the Java programming language rotates throughout the Objects, except for some of the primitive data types and primitive methods for integrity and simplicity）。在称为 Java 的编程语言中，是没有任何单独函数的。Java 编程语言中的函数，都是某个类的组成部分，而若某人想要调用这些函数，那么他们就必须使用到类或类的对象，来调用这些函数。</p>
<p><strong>功能接口</strong>是之只包含一个抽象方法的接口。他们可只有一项用于展示的功能。自Java 8 开始，就可以使用 <a href="Ch20_Appendix_B.html#lambda-expressions">拉姆达表达式</a> 来表示功能接口的实例了。功能接口可以有任意数量的默认方法（a functional interface can have any number of default methods）。<em><strong><code>Runnable</code>、<code>ActionListener</code>、<code>Comparable</code></strong></em> 等都是功能接口的一些示例。</p>
<p>功能接口又被称为 <strong>单一抽象方法接口（Single Abstract Method Interface）</strong>。简称 <strong>SAM 接口</strong>。Java 中的功能接口，属于提供到用户基础编程手段的新特性（functional interfaces in Java are the new feature that provides users with the approach of fundamental programming）。</p>
<p>自Java SE 8 开始，与拉姆达表达式及方法引用一起，加入的功能接口，为的是令到代码更具可读性、更为干净和直观（functional interfaces are included in Java SE 8 with Lambda expressions and Method references in order to make code more readable, clean, and straightforward）。功能接口是那些确保精确地只包含一个抽象方法的接口。通过以 <strong>名为 <em><code>@FunctionalInterface</code></em></strong> 加以注解的接口表示方式，来运用和执行功能接口（functional interfaces are used and executed by representing the interface with an <strong>annotation called <em><code>@FunctionalInterface</code></em></strong>）。如同先前所讲的那样，功能接口可只包含一个抽象方法。不过功能接口却可以包含任意数量的默认与静态方法。</p>
<p>在功能接口中，因为默认情况下，在接口内部定义的方法，只会是<code>abstract</code> 方法，因此使用关键字 <code>abstract</code> 就是，即无需使用关键字 <code>abstract</code>。同样也可以将拉姆达表达式，称为功能接口的实例。</p>
<p>在 Java 8 之前，就必须创建出匿名内部类的对象，或者必须要实现这些接口。</p>
<pre><code class="language-java">// 用于演示功能接口的 Java 程序
package com.xfoss.FunctionalInterface;

class Test {
    public static void main(String args[]) {
        // 创建匿名内部类对象
        new Thread(new Runnable() {
            @Override public void run()
            {
                System.out.println(&quot;新的线程已创建&quot;);
            }
        }).start();
    }
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code class="language-console">新的线程已创建
</code></pre>
<p>自 Java 8 开始，就可以像下面这样，将 <a href="Ch20_Appendix_B.html#lambda-expressions">拉姆达表达式</a> 赋值给其功能接口对象：</p>
<pre><code class="language-java">// 用于演示使用了拉姆达表达式的功能接口实现的 Java 程序
package com.xfoss.FunctionalInterface;

class Test {
    public static void main(String args[]) {
        // 创建对象的拉姆达表达式
        new Thread( () -&gt; {
                System.out.println(&quot;新的线程已创建&quot;);
        }).start();
    }
}
</code></pre>
<pre><code class="language-console">新的线程已创建
</code></pre>
<h3 id="关于-functionalinterface-注解"><a class="header" href="#关于-functionalinterface-注解">关于 <code>@FunctionalInterface</code> 注解</a></h3>
<p><code>@FunctionalInterface</code> 注解用于确保功能接口不可以有多于一个的抽象方法。若出现了多于一个的抽象方法，那么编译器就会标示出一个 <code>Unexcepted @FunctionalInterface annotation</code> 消息。不过并非强制要求使用此注解。</p>
<pre><code class="language-java">package com.xfoss.FunctionalInterface;

@FunctionalInterface
interface Square {
    int calculate(int x);
}

class TestDrive {
    public static void main(String args[])
    {
        int a = 5;

        Square s = (int x) -&gt; x * x;

        int ans = s.calculate(a);
        System.out.println(ans);
    }
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code class="language-console">25
</code></pre>
<h3 id="一些内建的-java-功能接口"><a class="header" href="#一些内建的-java-功能接口">一些内建的 Java 功能接口</a></h3>
<p>自Java SE 1.8 开始，就有了许多的转换成了功能接口的接口。这全部接口都是以 <code>@FunctionalInterface</code> 注解过的。这些接口如下所示：</p>
<ul>
<li><code>Runnable</code> -&gt; 此接口只包含了 <code>run()</code> 方法；</li>
<li><code>Comparable</code> -&gt; 此接口只保护了 <code>compareTo()</code> 方法；</li>
<li><code>ActionListener</code> -&gt; 此接口只包含了 <code>actionPerformed()</code> 方法；</li>
<li><code>Callable</code> -&gt; 此接口只包含了 <code>call()</code> 方法。</li>
</ul>
<p><strong>Java SE 8 包含了四大类功能接口</strong>，可分别应用于多种情形。</p>
<p>这四个大类分别是：</p>
<ol>
<li>消费者（Consumer）;</li>
<li>判断（Predicate）;</li>
<li>函数（Function）;</li>
<li>提供者（Supplier）。</li>
</ol>
<p>在上述四个接口中间，前三个，也就是<code>Consumer</code>、<code>Predicate</code>，与 <code>Function</code> ，还有着以下延伸补充：</p>
<ol>
<li><code>Consumer</code> -&gt; <code>Bi-Consumer</code>；</li>
<li><code>Predicate</code> -&gt; <code>Bi-Predicate</code>；</li>
<li><code>Function</code> -&gt; <code>Bi-Function</code>、一元算子/运算符、二元算子/运算符等（<code>Bi-Function</code>, Unary Operator, Binary Operator）。</li>
</ol>
<p>下面对这四个功能接口一一说明。</p>
<ol>
<li>
<p><strong><code>Consumer</code> 消费者</strong></p>
<p>功能接口中的消费者接口，是一类只接受一个参数，或者说只接受一个提升参数（the consumer interface of the functional interface is the one that accepts only one argument or a gentrified argument）。消费者接口没有返回值。他什么也不会返回。<code>Consumer</code>还有一些功能变种 -- <code>DoubleConsumer</code>、<code>IntConsumer</code>，以及 <code>LongConsumer</code>。这些变种接受原生值作为参数。</p>
<p>除了这些变种外，还有另外一种被称为<code>Bi-Consumer</code>的<code>Consumer</code>变种。</p>
<ul>
<li><strong><code>Bi-Consumer</code></strong> -- 是<code>Consumer</code>接口最为令人着迷的变种。消费者接口只会取一个参数，然而对于 <code>Bi-Consumer</code>，则会取两个参数。<code>Consumer</code>与<code>Bi-Consumer</code>二者都没有返回值。<code>Bi-Consumer</code>与<code>Consumer</code>接口一样，不会返回任何东西。在对映射数据结构进行遍历时，会用到 <code>Bi-Consumer</code> 接口。</li>
</ul>
<p><strong><code>Consumer</code> 功能接口的语法/原型</strong>：</p>
<pre><code class="language-java">Consumer&lt;Integer&gt; consumer = (value) -&gt; System.out.println(value);
</code></pre>
<p>Java <code>Consumer</code> 功能接口的这个实现，会将作为参数传入的值，打印到那个打印语句。这个实现使用了Java 的拉姆达函数。</p>
</li>
<li>
<p><strong>判断（<code>Predicate</code>）</strong></p>
<p>在现代科学的逻辑下，接受一个参数，并根据这个参数而相应地生成一个布尔值作为应答的函数，就被成为判断（in scientific logic, a function that accepts an argument and, in return, generates a boolean value as an answer is known as a predicate）。与此类似，在Java 编程语言中，Java 的判断功能接口，则是一类接受单个值或参数，而在这单个值或参数上进行某种处理，进而返回一个布尔值（<code>True</code>或<code>False</code>）的应答。<code>Predicate</code>功能接口的实现，还封装了 Java 中的筛选过程（用于在某种已有提供的判断基础上，对流式组件进行筛选的过程，the implementation of the <code>Predicate</code> functional interface also encapsualates the logic of filtering(a process that is used to filter stream components on the base of a provided predicate) in Java）。</p>
<p>正如 <code>Consumer</code> 功能接口意义，<code>Predicate</code> 功能接口也有一些扩展。他们分别是 <code>IntPredicate</code>、<code>DoublePredicate</code>，以及 <code>LongPredicate</code>。这些类型的判断功能接口，都只接受一个原生数据类型或原生值，作为参数。</p>
<ul>
<li><strong><code>Bi-Predicate</code></strong> -- <code>Bi-Predicate</code> 同样是 <code>Predicate</code> 功能接口的一个扩展，其取的是两个参数，而非一个参数，完成一些数据处理，进而返回布尔值。</li>
</ul>
<p><strong><code>Predicate</code> 功能接口的语法</strong>：</p>
<pre><code class="language-java">public interface Predicate&lt;T&gt; {
    boolean test(T t);
}
</code></pre>
<p>判断功能接口还可以用类来实现。下面给出的就是用类实现判断功能接口的语法：</p>
<pre><code class="language-java">public class CheckForNull implements Predicate {
    
    @Override
    public boolean test(Object o)
    {
        return o != null;
    }
}
</code></pre>
<p>Java 判断功能接口，还可以用拉姆达表达式实现。下面给出了<code>Predicate</code>功能接口实现的示例：</p>
<pre><code class="language-java">Predicate predicate = (value) -&gt; value != null;
</code></pre>
<p>由于使用拉姆达表达式的 Java 中功能接口实现，与使用类的实现，完成的都是同样工作，即返回了相同输出，但前者更具可管理能力，且更加高效。</p>
</li>
<li>
<p><strong><code>Function</code> 函数功能接口</strong></p>
<p>函数是 Java 中功能接口的一种只接受单个参数，并在完成所需处理之后返回一个值的类别。由于原生类型无法应用泛型参数，所以<code>Function</code> 接口有着许多版本，并且是需要这些版本的函数接口的。在诸如双精度数、整数、长整型数等原生类型中，众多不同版本的函数接口，属于工具性的接口，并被广泛使用。在参数中还会用到这些原生值类型的不同顺序组合（a function is a type of functional interface in Java that receives only a single argument and returns a value after the required processing. There are many versions of <code>Function</code> interfaces because a primitive type can't imply a general type argument, so we need these versions of function interfaces. Many different versions of the function interfaces are instrumental and are commonly used in primitive types like double, int, long. The different sequences of these primitive types are also used in the argument）。</p>
<p>这许多的函数接口版本，如下所示：</p>
<ul>
<li><strong>Bi-Function</strong> - <code>Bi-Function</code> 大致与 <code>Function</code> 有联系。除此之外，<code>Bi-Function</code> 是取两个参数的，而 <code>Function</code> 则接受一个参数。</li>
</ul>
<p><strong><code>Bi-Function</code> 的原型和语法如下</strong>：</p>
<pre><code class="language-java">    @FunctionalInterface
    public interface BiFunction&lt;T, U, R&gt;
    {
        R apply(T t, U u);
        ......
    }
</code></pre>
<p>在上面的接口代码中，<code>T, U</code> 是输入，而那里只有一个输出，即 <code>R</code>。</p>
<ul>
<li><strong>一元运算符和二元运算符（Unary Operator and Binary Operator）</strong> - 还有两个别的功能接口，分别叫做一元运算符和二元运算符。他们都各自对 <code>Function</code> 与 <code>Bi-Function</code> 进行了扩展。简单地说，一元运算符扩展了 <code>Function</code>，而二元运算符则扩展了 <code>Bi-Function</code>。</li>
</ul>
<p><strong>一元运算符和二元运算符的原型如下</strong>：</p>
<ol>
<li>
<p>一元运算符（Unary Operator）</p>
<pre><code class="language-java">@FunctionalInterface
public interface UnaryOperator&lt;T&gt; extends Function&lt;T, U&gt;
{
    ......
}
</code></pre>
</li>
<li>
<p>二元运算符（Binary Operator）</p>
<pre><code class="language-java">@FunctionalInterface
public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T, U, R&gt;
{
    ......
}
</code></pre>
</li>
</ol>
<p>从上面的示例，就可以明白一元运算符只接受一个参数，并只返回单个参数。还有就是，在一元运算符中，输入与输出值都要一致，并且要是同样的类型（we can understand from the above example that the <code>Unary Operator</code> accepts only one argument and returns a single argument only. Still, in <code>Unary Operator</code> both the input and output values must be identical and of the same type）。</p>
<p>而另一边，二元运算符则与 <code>Bi-Function</code> 相仿，要取两个值，并返回一个值。但与一元运算符类似，输入与输出值必须一致且要是同样类型（on the other way, <code>Binary Operator</code> takes two values and returns one value comparable to <code>Bi-Function</code> but similar like <code>Unary Operator</code>, the input and out value types must be identical and of the same type）。</p>
</li>
<li>
<p><strong>提供者（<code>Supplier</code>）</strong></p>
<p><code>Supplier</code> 功能接口，也是功能接口的一种类型，这种类型的功能接口，不取任何的输入或参数，而仍会返回单个输出。此种类型的功能接口，一般用于一些值的延迟生成。提供者功能接口也用于对任意序列生成的逻辑。比如 -- <code>斐波那契数列</code>背后的逻辑，就可以再 <code>Stream.generate</code> 方法的帮助下生成，而<code>Stream.generate</code>方法，就是通过提供者功能接口实现的（<code>Supplier</code> functional interface is also a type of functional interface that does not take any input or argument and ye returns a single output. This type of functional interface is generally used in the lazy generation of values. <code>Supplier</code> functional interfaces are also used for defining the logic for the generation of any sequence. For example - The logic behind the Fibonacci Series can be generated with the help of the <code>Stream.generate</code> method, which is implemented by the <code>Supplier</code> functional Interface）。</p>
<p><code>Supplier</code> 功能接口的不同扩展，包括了许多其他提供者函数，比如 <code>BooleanSupplier</code>、<code>DoubleSupplier</code>、<code>LongSupplier</code>及 <code>IntSupplier</code> 等等。这些所有衍生特定类型的返回值类型，也都只是他们各自相应的原生值类型（the different extensions of the <code>Supplier</code> functional inteface hold many other supplier functions like <code>BooleanSupplier</code>, <code>DoubleSupplier</code>, <code>LongSupplier</code>, and <code>IntSupplier</code>. The return type of all these further specializations is their corresponding primitives only）。</p>
<p><strong><code>Supplier</code> 功能接口的语法/原型如下</strong>：</p>
<pre><code class="language-java">@FunctionalInterface
public interface Supplier&lt;T&gt; {

    // 获取到一个结果
    ........

    // 返回这个特定结果
    .........

    T.get();
}
</code></pre>
</li>
</ol>
<pre><code class="language-java">package com.xfoss.FunctionalInterface;

import java.util.*;
import java.util.function.Predicate;

class PredicateDemo {
    public static void main(String args[])
    {

        // 创建一个字符串的清单
        List&lt;String&gt; names = Arrays.asList(
                &quot;G极客&quot;, &quot;G极客测试&quot;, &quot;g1&quot;, &quot;Q问答&quot;, &quot;G极客2&quot;);

        // 将这个判断类型声明为字符串，同时使用拉姆达表达式
        // 创建出对象
        Predicate&lt;String&gt; p = (s) -&gt; s.startsWith(&quot;G&quot;);

        // 对那个清单进行迭代
        for (String st : names){
            // 调用对象上的 test 方法
            if (p.test(st)) System.out.println(st);
        }
    }
}
</code></pre>
<p><strong>输出</strong></p>
<pre><code class="language-console">G极客
G极客测试
G极客2
</code></pre>
<h3 id="要点洞察important-pointsobservations"><a class="header" href="#要点洞察important-pointsobservations">要点/洞察（Important Points/Observations）</a></h3>
<p>以下是 Java 中功能接口有关的一些突出点：</p>
<ol>
<li>
<p>在功能接口里面，只支持一个抽象方法。在功能接口注解，也就是 <code>@FunctionalInterface</code> 没有被实现，或没有以函数接口方式加以编写出来时，那名就可以在其中声明多于一个的抽象方法。不过在这种有着多于一个的功能接口情形中，那个接口就不在被叫做功能接口了。那是叫做非功能接口（in functional interfaces, there is only one abstract method supported. If the annotation of a functional interface, i.e., <code>@FunctionalInterface</code> is not implemented or written with a function interface, more than one abstract method can be declared inside it. However, in this situation with more than one functional interface, that interface will not be called a functional interface. It is called a non-functional interface）；</p>
</li>
<li>
<p>由于 <code>@FunctionalInterface</code> 注解只是个自愿使用的注解，因此并不要求使用这个注解。之所以要写下这个注解，是因为其有助于在编译器层面的检查。除开这个目的，这个注解就是可选的；</p>
</li>
<li>
<p>可将无限多的方法（不管是静态的还是默认的），添加到功能接口。直白地将，功能接口对静态及默认方法的包含，没有限制；</p>
</li>
<li>
<p>对来自父类方法的重写，不会破坏Java中功能接口的规则；</p>
</li>
<li>
<p><code>java.util.function</code> 包，包含了许多 Java 8 中的内建功能接口。</p>
</li>
</ol>
<h2 id="java中的反射"><a class="header" href="#java中的反射">Java中的反射</a></h2>
<p><strong>Reflection in Java</strong></p>
<p><code>Reflection</code> 是个在运行时，用于对方法、类及接口进行检视和修改的 API。在 <code>java.lang.reflect</code> 包下，提供了用于反射的那些所需类，那么要搞清楚反射，就离不开这个包。下面这个视觉教学资料，对这个包进行了演示，以对其有更好的掌握：</p>
<p><img src="images/Ch20_03.png" alt="java.lang.reflect" /></p>
<p><em>图 3 - <code>java.lang.reflect</code></em></p>
<ul>
<li>反射给到了对象所属类，以及通过使用对象可执行其所属类的哪些方法（reflection gives us information about the class to which an object belongs and also the methods of that class that can be executed by using the object）；</li>
<li>经由反射，就可以在运行时，在不考虑要用到方法的访问指定符情况下，对方法加以调用（through reflection, we can invoke methods at runtime irrespective of the access specifier used with them）。</li>
</ul>
<p><img src="images/Ch20_04.png" alt="关于反射 API" /></p>
<p><em>图 4 - 关于反射 API</em></p>
<p>可使用反射机制，来获取到有关类、构造器，及方法的有关信息，如下表格所示：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">程序元素</th><th style="text-align: left">方法</th></tr></thead><tbody>
<tr><td style="text-align: left">类</td><td style="text-align: left">使用 <code>getClass()</code> 方法来获取到某个对象所属的类名称。</td></tr>
<tr><td style="text-align: left">构造器</td><td style="text-align: left">使用 <code>getConstructors()</code> 方法，来获取某个对象所属类的那些公共构造器。</td></tr>
<tr><td style="text-align: left">方法</td><td style="text-align: left">使用 <code>getMethods()</code> 方法，来获取到某个对象所属类的那些公共方法。</td></tr>
</tbody></table>
</div>
<p><em>表 1 - 反射机制如何获取到对象所属类、所属类的构造器与方法</em></p>
<p>在知道方法的名字和他的那些参数类型时，就可以通过反射机制调用到那个方法。为此，要用到下面所讲的两个方法：</p>
<ol>
<li><code>getDeclaredMethod()</code></li>
<li><code>invoke()</code></li>
</ol>
<p><strong>方式 1</strong>：<code>getDelcaredMethod()</code>: 这会创建出一个要调用方法的对象出来；</p>
<p><strong>语法</strong>：此方法的语法为：</p>
<pre><code class="language-java">Class.getDeclaredMethod(name, parameterType)
</code></pre>
<p><strong>参数</strong>：</p>
<ul>
<li>即将创建出对象的方法名字（name of a method whose object is to be created)</li>
<li>一个类对象的数组（an array of <code>Class</code> objects）</li>
</ul>
<p><strong>方法 2</strong>：<code>invoke()</code>: 在运行时，用下面的方式，他就会对这个类的方法进行调用；</p>
<p><strong>语法</strong>：</p>
<pre><code class="language-java">Method.invoke(Object, parameter)
</code></pre>
<blockquote>
<p><em><em>提示</em>：在该类的这个方法不接受任何参数时，那么就要将 <code>null</code> 作为参赛加以传递</em>。</p>
</blockquote>
<blockquote>
<p><em><em>注意</em>：经由反射机制，就可以在某个类对象的帮助下，访问到这个类的私有变量及私有方法，进而可通过上面讲到的对象，对方法进行调用。为此就要用到下面两个方法</em>。</p>
</blockquote>
<p><strong>方法 3</strong>：<code>Class.getDeclaredField(FieldName)</code>: 使用此方法来获取私有字段（变量/方法）。将返回一个指定字段名称的、 <code>Field</code> 类型的对象；</p>
<p><strong>方法 4</strong>：<code>Field.setAccessible(true)</code>: 实现了与该字段访问修饰符无关的情况下，对该字段的访问（Allows to access the field irrespective of the access modifier used with the field）。</p>
<h3 id="从反射式-api-得到的重要认知"><a class="header" href="#从反射式-api-得到的重要认知">从反射式 API 得到的重要认知</a></h3>
<p><strong>Important observations Drawn From Reflection API</strong></p>
<ul>
<li>实现 <strong>扩展能力特性（Extensibility Features）</strong>：应用程序可通过运用那些具备扩展能力对象中的实例完整名称，来创建出这些实例来，从而利用上这些外部的、用户定义的类（an application may make use of external, user-defined classes by creating instances of extensibility objects using their full-qualified names）；</li>
<li>用于 <strong>调试及测试工具（Debugging and Testing tools）</strong>：程序调试员会运用反射机制的属性，对类私有成员进行查看；</li>
<li>带来 <strong>性能开销（Performance Overhead）</strong>：相比于非反射的同类，反射操作有着较低性能，因此应避免在那些性能敏感的应用中、频繁调用到的代码部门，使用反射机制；</li>
<li>实现 <strong>内部暴露（Exposure of Internals）</strong>: 反射式代码破坏了抽象机制，从而会改变平台升级的方面的表现（reflective code breaks abstractions and therefore may change behavior with upgrades of the platform）。</li>
</ul>
<p><strong>示例</strong>：</p>
<pre><code class="language-java">// 用于演示反射机制运用的 Java 程序
package com.xfoss.Reflection;

// 导入所需的类: Constructor、Field 及 Method
import java.lang.reflect.*;

// 类 1
// 将创建这个类的对象
class Test {
    
    // 创建出一个私有字段（实例变量）
    private String s;

    // 该类的构造器
    //
    // 方法 1
    // 公共构造器
    public Test() { s = &quot;极客空间&quot;; }

    // 方法 2
    // 不带参数
    public void method1()
    {
        System.out.format(&quot;------------------\n该字符串为 %s\n&quot;, s);
    }

    // 方法 3
    // 一个整形参赛
    public void method2(int n)
    {
        System.out.format(&quot;------------------\n该数字为 %d\n&quot;, n);
    }

    // 方法 4
    // 这是个私有方法
    private void method3()
    {
        System.out.println(&quot;------------------\n私有方法被调用了&quot;);
    }
}

// 类 2
// 主类
class Demo {
    
    // 主类的驱动器方法
    public static void main(String args[]) throws Exception
    {

        // 创建出将对其属性进行查看的对象

        // 在 main() 方法中创建一个类 1 的对象
        Test obj = new Test();

        // 使用 getClass() 方法，从这个对象创建
        // 出类对象（class object）
        Class cls = obj.getClass();

        // 使用 getName() 方法，打印出类的名字
        System.out.format(&quot;---------------------\n类的名字为 %s\n---------------------\n&quot;,
                cls.getName());

        // 通过该类对象，获取到其构造器
        Constructor constructor = cls.getConstructor();

        // 使用 getName() 方法，打印出构造器的名字
        System.out.format(&quot;构造器的名字为 %s\n---------------------\n&quot;,
                constructor.getName());

        // 这个语句只是显示消息
        System.out.println(&quot;类的公共方法分别为：&quot;);

        // 通过在该类对象上使用 getDeclaredMethods() 方法获取到
        // 该类的那些声明的方法（getMethods() 将获取到全部方法）
        Method[] methods = cls.getDeclaredMethods();

        // 打印出这些方法的名字
        for (Method method : methods) System.out.println(method.getName());

        // 经由提供到方法名字及参数类，作为 getDeclaredMethod() 
        // 方法的参数，创建出指定方法的对象
        Method methodCall1 = cls.getDeclaredMethod(&quot;method2&quot;, int.class);

        // 在运行时调用该方法
        methodCall1.invoke(obj, 19);

        // 通过将字段名字作为参数，提供到 getDeclaredField() 方法
        // 创建出指定字段的对象来
        Field field = cls.getDeclaredField(&quot;s&quot;);

        // 这个语句实现了在无关乎该字段（实例变量）访问指示符
        // 的情况下，对该字段的访问
        field.setAccessible(true);

        // 这里的 set() 方法，取了这个对象及要赋给私有字段‘s’
        // 的新值
        field.set(obj, &quot;Java&quot;);

        // 经由提供作为参数的方法名字给 getDeclaredMethod()
        // 创建出指定方法的对象来
        Method methodCall2 = cls.getDeclaredMethod(&quot;method1&quot;);

        // 在运行时调用该方法
        methodCall2.invoke(obj);

        // 经由提供作为参数的方法名字给 getDeclaredMethod()
        // 创建出指定方法的对象来
        Method methodCall3 = cls.getDeclaredMethod(&quot;method3&quot;);

        // 这个语句实现在无关乎该方法的访问指示符的情况下
        // 对象对该方法的访问
        methodCall3.setAccessible(true);

        // 在运行时调研这个方法
        methodCall3.invoke(obj);
    }
}
</code></pre>
<p><strong>输出</strong>：</p>
<pre><code class="language-console">java -jar build/libs/com.xfoss.learningJava-0.0.1.jar                              ✔ 
---------------------
类的名字为 com.xfoss.Reflection.Test
---------------------
构造器的名字为 com.xfoss.Reflection.Test
---------------------
类的公共方法分别为：
method2
method1
method3
------------------
该数字为 19
------------------
该字符串为 Java
------------------
私有方法被调用了
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
