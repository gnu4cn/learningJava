# 接口与抽象类

__继承只开了个头__。为运用好多态，就需要使用接口（interfaces, 不是GUI中的界面）。需要超越简单继承，通过按照接口规范，来设计和编写代码，才能获得间距灵活性与扩展性的水平。Java中最酷炫的部分，在不使用接口的情况下，是达不到的。所以就算你在设计Java程序时拒绝使用接口，但你仍避免不了接口的使用。__你会明白没有接口，是无法生存的__。那么接口到底是什么呢？他是一个 100% 的抽象类。而什么又是抽象类呢？是一个无法初始化的类。有什么好处呢？很快就能看到。回顾一下上一张的结尾，通过使用多态参数，就可以让 `Vet` 中仅仅一个方法，就能够处理所有类型的 `Animal` 子类，而那仅仅只是冰山一角而已。接口就是多态（polymorphism）中的 __多（poly）__。抽象（abstract）中的 __象（ab）__。是 Java 国的 __咖啡因（caffine）__。

__在设计 `Animal` 继承树时，是不是遗漏了什么__？

这个类结构并没有什么毛病。通过设计，让重复代码降到了最低水平，同时也已经重写了那些应该有着特定子类实现的方法。从多态角度上看，因为可以使用 `Animal`参数（以及 `Animal` 的数组声明），来设计出使用到 `Animal` 类的程序，因此可以说已经很不错且灵活了，从而所有 `Animal` 的子类型 -- *包括在编写代码时想象不到的* -- 在运行时都可以传递进去并得到使用。还已经把所有 `Animal`s 的共用协议（就是那四个希望外部世界知道的所有 `Animal`s 都有的方法），放入到了 `Animal` 超类中，同时也已准备好生成新的狮子、老虎以及河马了。

![Animal 继承树](images/Ch08_01.png)

*图 1 - Animal 继承树*

__我们可以这样说__：

```java
Wolf aWolf = new Wolf ();
```

![对象与对象的引用变量类型相同时](images/Ch08_02.png)

*图 2 - 对象与对象的引用变量类型相同时*

__也可以这样说__：


```java
Animal aHippo = new Hippo ();
```

![对象与其引用变量的类型不同时](images/Ch08_03.png)

*图 3 - 对象与其引用变量的类型不同时*


__但如果像下面这样，就会显得令人费解__：

```java
Animal anim = new Animal ();
```

![创建出一个 Animal 对象时](images/Ch08_04.png)

*图 4 - 创建出一个 Animal 对象时*


__ 一个 `new Animal()` 对象会是怎样的__？

![一些可怕的对象](images/Ch08_05.png))]

*图 5 - 一些可怕的对象*

__那些实例变量的值，都是些什么呀__？

***有些类就不应该被实例化***！

去创建一个 `Wolf` 对象、一个 `Hippo` 对象，或者一个 `Tiger` 对象，这些都说得通，但一个 `Animal` 对象到底是个什么东西？它的形状是怎样？是什么颜色的？有多大？有几条腿......

尝试去创建一个 `Animal` 类型的对象，就好像 __星际迷航中噩梦般的传输机故障__。

怎样才能解决这个问题呢？为了实现继承和多态，`Animal`类肯定是需要的。但又要其他程序员只能对那些，`Animal`的不那么抽象的子类，而不是`Animal`本身进行初始化。我们要的是 `Tiger` 对象与 `Lion` 对象，而 *不是 `Animal` 对象*。

好在有这么一种简单的方法，来防止某个类不被初始化。也就是通过将类标记为 `abstract`，从而阻止人们在他前面说 `new`，之后编译器就会在任何时候、任何地方，把那些试图创建那个类型实例的举动，拦截下来。

仍可以将抽象类型，作为引用变量的类型使用。实际上这正是抽象类存在的首要原因（将抽象类用作多态参数或返回值的类型，或者用于构造多态数组）。

在设计类继承层次结构时，就面临着确定哪些是抽象类、哪些是具体的问题（When you're designing your class inheritance stucture, you have to decide which classes are *abstract* and which are *concrete*）。具体类是那些足够具体、可被初始化的类。某个具体类，就应该是可以构造出其对象的类。

要构造一个抽象类是很简单的 -- 将关键字 `abstract` 放在类的声明前面：

```java
abstract class Canine extends Animal {
    public void roam () {}
}
```

__编译器会阻止对某个抽象类的初始化__


抽象类意味着无人能构造出他的新实例。但仍然可以出于多态目的，将其用作某个引用变量声明中的类型，由于编译器会确保抽象类不会被初始化，因此就无需担心有人构建出抽象类类型的对象来。

```java
abstract public class Canine extends Animal {
    public void roam () {}
}
```

```java
public class MakeCanine {
    public void go () {
        Canine c;
        c = new Dog ();
        c = new Canine ();
        c.roam();
    }
}
```


这个时候编译器就会报错：

```console
Canine is abstract; cannot be initiated
```

抽象类在未被扩展时，实质上毫无用处、不会有取值、没有目的。

> 其中一个例外是，抽象类可以有静态成员，在 IO 那一章会涉及这个问题。

使用到抽象类时，在运行时真正做事的，是那些抽象类的子类的实例。

## 关于“抽象”与“具体”

不是抽象的类，就叫做 *具体（concrete）* 类。在 `Animal` 继承树中，是将 `Animal`、`Canine` 与 `Feline` 作为抽象类，将 `Hippo`、`Wolf`、`Dog`、`Tiger`、`Lion`及`Cat`作为具体类的。

![`Animal` 继承树上的抽象和具体类](images/Ch08_06.png)

*图 6 - `Animal` 继承树上的抽象和具体类*

通读 Java API 文档，就会发现很多的抽象类，尤其是在 GUI库中。那么某个GUI组件看起来是怎样的呢？所谓GUI组件类， 是指诸如按钮、文本框、滚动条、对话框等等这样的GUI相关的众多类的超类。比如在构建一个 `JButton`时，并没有构建这个通用组件的实例并把实例放在屏幕上的。而是对组件的一个具体子类进行实例化，绝不会对组件本身进行实例化。


